<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/RabbitMQ/"/>
      <url>/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.bilibili.com/video/BV1S142197x7?vd_source=7341c7fca3b496e9108bb1fd49c634ef">配合黑马的微服务课程使用</a></p><p><a href="https://b11et3un53m.feishu.cn/wiki/FYNkwb1i6i0qwCk7lF2caEq5nRe">黑马文档</a></p></blockquote><h1 id="前景提要？"><a href="#前景提要？" class="headerlink" title="前景提要？"></a>前景提要？</h1><blockquote><p>RabbitMQ是一款高性能的异步通讯组件（消息队列），官网：<code>https://www.rabbitmq.com/</code></p></blockquote><p>同步通讯</p><ul><li>就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话</li></ul><p>异步通讯</p><ul><li>就同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应，因此你可以多线操作，同时跟多人聊天</li></ul><p>两种方式各有优劣，如果你需要实时通信那么使用同步调用（OpenFeign就是同步调用），如果你追求高效率和多人通讯不需要实时响应，那么就使用异步调用</p><h1 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h1><h2 id="同步调用优缺点"><a href="#同步调用优缺点" class="headerlink" title="同步调用优缺点"></a>同步调用优缺点</h2><p>以黑马商城的用户余额支付为例：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/TJf872VqjElgHBS.png" alt="用户余额支付"></p><ul><li>从支付服务到用户服务是一个等待过程，我们必须先支付才能修改支付状态，所以这是一个同步调用</li><li>可是后续的交易、短信、积分服务和支付之间不需要等待过程，如果还是同步调用会造成一些问题：<ul><li>扩展性差</li><li>性能下降，同步调用都是需要等待上一个服务完成</li><li>级联性问题，交易服务失败对支付服务和其他服务的影响</li></ul></li></ul><p>同步调用的优势是时效性强，等待到结果后才返回</p><h2 id="异步调用优缺点"><a href="#异步调用优缺点" class="headerlink" title="异步调用优缺点"></a>异步调用优缺点</h2><p>同步调用主要有2个角色;</p><ul><li>服务调用者</li><li>服务提供者</li></ul><p>异步调用主要有三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的服务调用者</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供者</li><li>消息代理：管理、暂存、转发消息，你可以把它理解成微信服务器</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/HE4CoJBw3AmOQ71.png" alt="异步调用"></p><p>举个例子：外卖员，外卖柜，客人分别对应上面三个角色；如果是同步，外卖员需要把外卖交给客人之后才能继续送下一单外卖，如果客户临时有事无法去拿外卖，那么外卖员就会一直等待客户；可有了外卖柜，外卖员可以把该用户的外卖放到外卖柜里，然后给客人发一个开柜码就可以继续送下一单外卖</p><p>同样黑马商城的用户余额支付为例：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/3HuQlFkwLr2i8DG.png" alt="用户余额支付"></p><ul><li>支付服务不再同步调用业务关联度低的服务，而是发送消息通知到Broker(消息代理)，其他服务监听broker即可，这样具备下列优势：<ul><li>解除支付服务与短信等服务耦合，拓展性强</li><li>无需等待，支付服务在修改完订单状态后直接返回信息给用户，性能好</li><li>故障隔离，下游服务故障不影响上游业务</li><li>缓存消息，流量削峰填谷<ul><li>当QPS较高时，可以通过消息组件来平衡</li></ul></li></ul></li><li>不过异步调用也存在一些问题<ul><li>不能立即得到调用结果，时效性差</li><li>不确定下游业务执行是否成功</li><li>业务安全依赖于Broker的可靠性</li></ul></li></ul><h2 id="MO技术选型"><a href="#MO技术选型" class="headerlink" title="MO技术选型"></a>MO技术选型</h2><p>MQ（MessageQueue），中文是消息队列，字面来看就是存放消息的队列。也就是异步调用中的Broker</p><p>市面上常见的几款消息队列：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/Gz3Aetn24mkhpcy.png" alt="对比图"></p><h1 id="RabbitMQ入门"><a href="#RabbitMQ入门" class="headerlink" title="RabbitMQ入门"></a>RabbitMQ入门</h1><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>基于docker安装部署</p><ul><li>拉取镜像： rabbitmq:3.8-management</li><li>部署</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network heima \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li><li>访问:<code>虚拟机IP:15672</code>即可看到管理控制台</li></ul><p>RabbitMO对应的架构如图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/BroGIjtT8xdvE2s.png" alt="MQ架构图"></p><p>其中包含几个概念：</p><ul><li>**<code>publisher</code>**：生产者，也就是发送消息的一方</li><li>**<code>consumer</code>**：消费者，也就是消费消息的一方</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue，互不影响；不同的业务、项目可以使用不同的虚拟主机</li></ul><h2 id="新建队列、绑定交换机"><a href="#新建队列、绑定交换机" class="headerlink" title="新建队列、绑定交换机"></a>新建队列、绑定交换机</h2><p>需求：在RabbitMQ的控制台完成下列操作</p><ul><li>新建队列hello.queue1和hello.queue2<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/JckXmN9d2zae3Tn.png" alt="添加队列"></li></ul></li><li>向默认的amp.fanout交换机发送一条消息<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/PCAhdBkWyIK5JnF.png" alt="发消息"></li></ul></li><li>查看消息是否到达hello.queue1和hello.queue2<ul><li>没有任何消息到达2个队列中</li></ul></li></ul><p>分析原因</p><ul><li>首先，交换机，负责消息路由，没有存储功能</li><li>其次，这里也没有设置交换机和队列之间路由，交换机需要绑定队列</li></ul><p>添加绑定关系</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/9CNUVK68fLo4zub.png" alt="Bindings"></p><h2 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h2><p>需求：在RabbitMQ的控制台完成下列操作</p><ul><li>新建一个用户hmall<ul><li>在<code>admin</code>模块对应处，添加用户hmall</li></ul></li><li>为hmall用户创建一个virtual host<ul><li>退出，使用hmall用户登录，在<code>admin</code>模块的<code>virtual host</code>功能中常见虚拟主机&#x2F;hmall</li></ul></li><li>测试不同virtual host之间的数据隔离现象<ul><li>不同的虚拟主机，无法访问其对应的队列</li></ul></li></ul><h1 id="RabbitMQ的Java客户端"><a href="#RabbitMQ的Java客户端" class="headerlink" title="RabbitMQ的Java客户端"></a>RabbitMQ的Java客户端</h1><h2 id="快速入门案例"><a href="#快速入门案例" class="headerlink" title="快速入门案例"></a>快速入门案例</h2>]]></content>
      
      
      <categories>
          
          <category> 黑马学习课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm</title>
      <link href="/Algorithm/"/>
      <url>/Algorithm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>算法小白的学习之路~~</p></blockquote><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="何为算法"><a href="#何为算法" class="headerlink" title="何为算法"></a>何为算法</h2><p>以我目前的对此认知水平，算法是一种解决之术，算法思想是解决之道。面对一道算法题，我会在脑海中构建程序的运行，然后通过运用各种各样的算法来让流程实现，从而完成题目的解答。在这里算法是一种解决方法，完成程序的运行，算法有很多，解决问题的方法也会很多。算法是算法思想的一种体现，不同的算法思想对应着不同的算法。一道算法题完美的实现离不开好的算法，好的算法思想</p><h2 id="第一节-排序"><a href="#第一节-排序" class="headerlink" title="第一节 排序"></a>第一节 排序</h2><h3 id="排序算法的理解和思考"><a href="#排序算法的理解和思考" class="headerlink" title="排序算法的理解和思考"></a>排序算法的理解和思考</h3><p>给大家看看王者荣耀的玩家排名图</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/28/cVqAwRTP8veM35J.jpg" alt="排名图"></li></ul><p>认真观察可以知道，这张排名图，包含了玩家、区域、巅峰积分这几个关键排名要素；这里排位规则很明显是“同区，巅峰积分越高排名越靠前”，而且这里只会显示前100的用户信息</p><p>通过以上信息，我们可以知道，排序的一个条件是确定<strong>排序的规则</strong>（限制），还有一个条件是确定存储这些数据的<strong>容器</strong>（常说的数据结构），最后一个我认为的是采用什么样的<strong>排序算法</strong>可以让性能最优，毕竟需要排序的数据非常之多</p><p>人话就是排序的三要素为</p><ol><li>排序规则</li><li>数据结构</li><li>排序算法</li></ol><p>排序规则一般取决于业务的实现，每一个榜单的排序规则都不相同；而排序算法的实现和数据结构的选择息息相关，下面我主要介绍一个常见的排序算法，以及其所使用的数据结构的特点</p><h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h3><p>什么是冒泡排序？这里我就不自做修饰了，直接使用<a href="https://www.runoob.com/w3cnote/bubble-sort.html">菜鸟教程</a>的描述，我觉得已经非常贴切了</p><ul><li>冒泡排序（Bubble  Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端，就像碳酸饮料中的二氧化碳气泡最终会上浮到顶端一样</li></ul><p><strong>动画演示</strong>排序的过程</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/28/2kWIq6DNZEQs7vG.gif" alt="出自-菜鸟教程"></li></ul><p><strong>冒泡排序的思想</strong></p><ul><li>首先讲讲上面这个动画演示。每一次的排序过程都是从第一个数字一直比较到最后一个没有排序的数字，已排序的数字标黄；在该过程中，我们会选择较大的那个数字参与下一轮比较，所以在排序的过程中往往伴随着<strong>交换</strong>，一轮下来最大的数字就放在了最前面</li><li>冒泡排序的基本思想是通过不断<strong>比较</strong>相邻元素并<strong>交换</strong>位置，使得较小的元素逐渐<strong>“浮”</strong>到序列的前端，较大的元素逐渐<strong>“沉”</strong>到序列的后端，从而实现排序</li></ul><p><strong>数据结构</strong></p><ul><li>这里主要介绍数组</li><li>数组，顾名思义也就是数据的组合，数组中数据是一种线性排列，就像商场的储物柜一样从第一个柜子一直到最后一个；从储物柜中取东西是通过一张凭证，而从数组中取**元素(element)<strong>，则是通过</strong>索引(index)**；从数组中取元素很简单，而添加和删除元素则耗时间的多</li><li>不同的编程语言对数组的声明和使用有细微差别，我这里是<a href="https://www.runoob.com/java/java-array.html">Java-数组</a></li></ul><p><strong>具体代码实现Bubble Sort</strong></p><ul><li>这里给出一个具体问题来实现代码，更有利于理解，后续同理</li><li>基于冒泡排序算法，对<code>int[] arr = &#123;5,9,3,1,2,8,4,7,6&#125;;</code>进行升序排序，代码如下</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//外层循环是排序的轮数;&lt;=是为了防止索引越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//内层循环浮出当前的最大数;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//元素交换</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于元素交换，其实就是如何对调两杯水的问题（再找一个新的被子）；这里也有其他方法且不会引入新的变量；把元素交换部分的代码替换为：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arr[j]为两数之和,再分别相减实现交换</span></span><br><span class="line">arr[j] += arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j] - arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j] -= arr[j + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>题目巩固</p><ul><li><a href="https://www.luogu.com.cn/problem/P1327">洛谷-数列排序</a></li><li>由于篇幅较大，我把解答放置于博客园（后续同理）</li><li><a href="https://www.cnblogs.com/turingteam/articles/18328465">解答</a></li></ul><h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>全局唯一ID</title>
      <link href="/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/"/>
      <url>/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/</url>
      
        <content type="html"><![CDATA[<h1 id="全局ID（分布式ID）"><a href="#全局ID（分布式ID）" class="headerlink" title="全局ID（分布式ID）"></a>全局ID（分布式ID）</h1><blockquote><p>全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具。</p></blockquote><ul><li>特性<ul><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ul></li></ul><h2 id="ID的组成部分"><a href="#ID的组成部分" class="headerlink" title="ID的组成部分"></a>ID的组成部分</h2><ol><li>符号位：1bit，永远为0。</li><li>时间戳：31bit，可以使用69年，以秒为单位。</li><li>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID。</li></ol><h2 id="生成策略"><a href="#生成策略" class="headerlink" title="生成策略"></a>生成策略</h2><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><blockquote><p>UUID是一种由时间戳、节点ID和随机数生成的128位标识符。</p></blockquote><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>当前日期和时间</li><li>时钟序列</li><li>随机数</li><li>全局唯一的IEEE机器识别号<ul><li>IEEE机器识别号是一种全局唯一的识别码，通常从网络接口控制器（NIC）的MAC地址获取。</li></ul></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="java-util-UUID类"><a href="#java-util-UUID类" class="headerlink" title="java.util.UUID类"></a>java.util.UUID类</h5><ul><li>示例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUUid</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> java.util.UUID.randomUUID().toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">    <span class="comment">//id = ee43a4bb-3405-4e8d-a9ca-95aede99001d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="cn-hutool-core-lang-UUID类"><a href="#cn-hutool-core-lang-UUID类" class="headerlink" title="cn.hutool.core.lang.UUID类"></a>cn.hutool.core.lang.UUID类</h5><ul><li>功能更加完善</li><li>示例<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hutool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUUid</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">id1</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>); <span class="comment">// 没有“-”</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id2</span> <span class="operator">=</span> UUID.randomUUID().toString(); <span class="comment">// 默认false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;id1 = &quot;</span> + id1);</span><br><span class="line">    System.out.println(<span class="string">&quot;id2 = &quot;</span> + id2);</span><br><span class="line">    <span class="comment">//id1 = 82d847deca8c41f5b2ec9171bc3a845a</span></span><br><span class="line">    <span class="comment">//id2 = ee43a4bb-3405-4e8d-a9ca-95aede99001d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>实现简单。</li><li>不依赖于数据库等外部因素。</li></ul></li><li>缺点<ul><li>其值是字符串类型，数据库占用内存大。</li><li>不是严格意义上的递增有序，数据库索引性能差。</li></ul></li></ul><h3 id="Redis自增"><a href="#Redis自增" class="headerlink" title="Redis自增"></a>Redis自增</h3><ul><li>对于大型系统来说，我们可以使用Redis来生成ID，主要是依赖于 Redis 是<strong>单线程</strong>的，因此可以用来生成全局唯一ID</li><li>要实现这个功能我们可以用<strong>Redis 的原子操作 INCR和INCRBY</strong>来实现；主要思想是利用Redis单线程特性以保证操作的原子性，这样读写同一key时不会出现不同的数据</li></ul><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>符号位（1bit） + 时间戳  (31bit) + 计数器 (32bit)</li></ul><h4 id="Redis自增ID策略"><a href="#Redis自增ID策略" class="headerlink" title="Redis自增ID策略"></a>Redis自增ID策略</h4><ul><li>示例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisWorker</span> &#123;</span><br><span class="line">    <span class="comment">//原始时间戳BASE_TIME</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1704067200L</span>;</span><br><span class="line">    <span class="comment">//移动的位数bit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">//1生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowEpochSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="comment">//时间差</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowEpochSecond - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2生成序列号</span></span><br><span class="line">        <span class="comment">//2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        <span class="comment">//3拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BIT | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>Redis是<strong>基于单线程</strong>的，能够保证线程安全性。而且Redis是基于内存的，在<strong>并发性能</strong>相比于数据库较快一些</li><li>redis可以保证ID的唯一性</li><li>不依赖于数据库，灵活方便</li></ul></li><li>缺点<ul><li>可能数据会丢失</li><li>需要编码和配置的工作量比较大</li></ul></li></ul><h3 id="Snowflake算法"><a href="#Snowflake算法" class="headerlink" title="Snowflake算法"></a>Snowflake算法</h3><blockquote><p>Snowflake算法是Twitter开源的一种分布式ID生成算法，可以在分布式系统中生成唯一且有序的ID。<br>生成后是一个 64bit 的 long 型的<strong>数值</strong>，组成部分引入了<strong>时间戳</strong>，基本保持了<strong>自增</strong></p></blockquote><ul><li><a href="https://github.com/cloudyan/snowflake?tab=readme-ov-file">Snowflake-github</a></li></ul><h4 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h4><ul><li>现在的服务基本是分布式、微服务形式的，而大数据量也导致<strong>分库分表</strong>的产生，对于水平分表就需要保证表中 id 的全局唯一性。</li><li>确保水平分表之后的主键 id 唯一性和自增性。</li></ul><h4 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h4><ul><li>SnowFlake算法生成id的结果是一个<strong>64bit大小的整数</strong>，它的结构如下图：</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\zy293\Desktop\1.jpeg" alt="img"></p><ul><li>1bit，不使用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0</li><li>41bit，用来记录时间戳（毫秒）<ul><li>41bit可以表示 <code>2^&#123;41&#125;-1 </code>个数字</li><li>如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 <code>2^&#123;41&#125;-1</code>，减1是因为可表示的数值范围是从0开始算的，而不是1</li><li>也就是说41bit可以表示<code>2^&#123;41&#125;-1</code>个毫秒的值，转化成单位年则是<code>(2^&#123;41&#125;-1) / (1000 * 60 * 60 * 24 * 365) = 69</code>年</li></ul></li><li>10bit，用来记录<strong>工作机器id</strong><ul><li>可以部署在<code>2^&#123;10&#125; = 1024</code>个节点，包括5位<strong>datacenterId</strong>和5位<strong>workerId</strong></li><li>5位（bit）可以表示的最大正整数是<code>2^&#123;5&#125;-1 = 31</code>，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId</li></ul></li><li>12bit，序列号，用来记录<strong>同毫秒内产生的不同id</strong><ul><li>12位（bit）可以表示的最大正整数是<code>2^&#123;12&#125;-1 = 4095</code>，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号</li></ul></li><li><strong>0 - 41位时间戳 - 5位数据中心标识 - 5位机器标识 - 12位序列号</strong></li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zy293</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowFlake</span>&#123;</span><br><span class="line">    <span class="comment">//起始时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> startTimeStamp;</span><br><span class="line">    <span class="comment">//机器ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> workID;</span><br><span class="line">    <span class="comment">//数据中心ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span>  dataCenterID;</span><br><span class="line">    <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> sequence;</span><br><span class="line">    <span class="comment">//数据中心ID移动位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> dataCenterIndex;</span><br><span class="line">    <span class="comment">//机器ID移动位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> workIDIndex;</span><br><span class="line">    <span class="comment">//时间戳移动位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> timeStampIndex;</span><br><span class="line">    <span class="comment">//记录上一次时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> lastTimeStamp;</span><br><span class="line">    <span class="comment">//序列号掩码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> sequenceMask;</span><br><span class="line">    <span class="comment">//序列号长度12位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> sequenceLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据（也可以通过配置yaml文件实现）</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        startTimeStamp = <span class="number">1577808000000L</span>;</span><br><span class="line">        <span class="comment">//设置机器编号 1</span></span><br><span class="line">        workID = <span class="number">1L</span>;</span><br><span class="line">        <span class="comment">//设置数据中心ID 1</span></span><br><span class="line">        dataCenterID = <span class="number">1L</span>;</span><br><span class="line">        <span class="comment">//起始序列号 0开始</span></span><br><span class="line">        sequence = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">//数据中心位移位数</span></span><br><span class="line">        dataCenterIndex = <span class="number">12L</span>;</span><br><span class="line">        <span class="comment">//机器ID位移位数</span></span><br><span class="line">        workIDIndex = <span class="number">17L</span>;</span><br><span class="line">        <span class="comment">//时间戳位移位数</span></span><br><span class="line">        timeStampIndex = <span class="number">22L</span>;</span><br><span class="line">        <span class="comment">//记录上次时间戳</span></span><br><span class="line">        lastTimeStamp = -<span class="number">1L</span>;</span><br><span class="line">        <span class="comment">//序列号长度</span></span><br><span class="line">        sequenceLength = <span class="number">12L</span>;</span><br><span class="line">        <span class="comment">//序列号掩码</span></span><br><span class="line">        sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//当前系统时间小于上一次记录时间</span></span><br><span class="line">        <span class="keyword">if</span> (now &lt; lastTimeStamp)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;时钟回拨异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相同时间 要序列号进制增量</span></span><br><span class="line">        <span class="keyword">if</span> (now == lastTimeStamp)&#123;</span><br><span class="line">            <span class="comment">//防止溢出</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>)&#123;</span><br><span class="line">                <span class="comment">//溢出处理</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取下一毫秒时间 （有锁）</span></span><br><span class="line">                now = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//置0 之前序列号同一时间并发后自增 到这里说明时间不同了 版本号所以置0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录当前时间</span></span><br><span class="line">        lastTimeStamp = now;</span><br><span class="line">        <span class="comment">//当前时间和起始时间插值 右移 22位</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">handleTimeStamp</span> <span class="operator">=</span> (now - startTimeStamp) &lt;&lt; timeStampIndex;</span><br><span class="line">        <span class="comment">// 数据中心数值 右移动 17位 并且 按位或</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">handleWorkID</span> <span class="operator">=</span> (dataCenterID &lt;&lt; dataCenterIndex) | handleTimeStamp;</span><br><span class="line">        <span class="comment">// 机器ID数值 右移动 12位 并且 按位或</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">handleDataCenterID</span> <span class="operator">=</span> (workID &lt;&lt; workIDIndex) | handleWorkID;</span><br><span class="line">        <span class="comment">// 序列号 按位或</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ID</span> <span class="operator">=</span> handleDataCenterID | sequence;</span><br><span class="line">        <span class="keyword">return</span> ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><ul><li>导入实现雪花算法的依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hutool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>示例</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUUid3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Snowflake</span> <span class="variable">snowflake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Snowflake</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> snowflake.nextId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">iDString</span> <span class="operator">=</span> snowflake.nextIdStr();</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    System.out.println(iDString);</span><br><span class="line">    <span class="comment">//1797601410943664128</span></span><br><span class="line">    <span class="comment">//1797601410943664129</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h5><ul><li>IdGenerator-Java<ul><li>雪花飘移算法-Github<code>https://github.com/yitter/idgenerator/tree/master/Java</code></li></ul></li><li>组成<ul><li>第1部分，时间差，是生成ID时的系统时间减去 BaseTime 的总时间差（毫秒单位）。</li><li>第2部分，WorkerId，是区分不同机器或不同应用的唯一ID，最大值由 WorkerIdBitLength（默认6）限定。</li><li>第3部分，序列数，是每毫秒下的序列数，由参数中的 SeqBitLength（默认6）限定。</li></ul></li><li>示例<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.yitter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yitter-idgenerator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局 初始化（应用程序启动时执行一次）</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 IdGeneratorOptions 对象，可在构造函数中输入 WorkerId(默认为0)</span></span><br><span class="line">    <span class="type">IdGeneratorOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGeneratorOptions</span>();</span><br><span class="line">    <span class="comment">// 保存参数（务必调用，否则参数设置不生效）：</span></span><br><span class="line">    YitIdHelper.setIdGenerator(options);</span><br><span class="line">    <span class="comment">// 以上过程只需全局一次，且应在生成ID之前完成。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化后，在任何需要生成ID的地方，调用以下方法：</span></span><br><span class="line"><span class="type">long</span> <span class="variable">newId</span> <span class="operator">=</span> YitIdHelper.nextId();</span><br><span class="line"><span class="comment">//没有初始化也可以生成id,会有一个默认的DefaultIdGenerator</span></span><br><span class="line"><span class="keyword">if</span> (idGenInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">    idGenInstance = <span class="keyword">new</span> <span class="title class_">DefaultIdGenerator</span>(<span class="keyword">new</span> <span class="title class_">IdGeneratorOptions</span>((<span class="type">short</span>)<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h5><ul><li>开源分布式 ID 框架<ul><li>美团 Leaf：<code>https://github.com/Meituan-Dianping/Leaf</code></li><li>百度 Uid：<code>https://github.com/baidu/uid-generator</code></li></ul></li><li>示例<ul><li>引入依赖</li><li>搞定配置</li><li>如无必要，<strong>不建议引入开源方案增加系统复杂度</strong></li></ul></li></ul><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>生成ID时不依赖于数据库，完全在内存生成，高性能高可用</li><li>容量大，每秒可生成几百万ID<ul><li>SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？<ul><li>同一毫秒的ID数量 &#x3D; 1024 * 4096 &#x3D; 4194304</li></ul></li></ul></li><li><strong>所有生成的id按时间趋势递增，后续插入数据库的索引树的时候，性能较高</strong></li><li>整个分布式系统内不会产生重复id（因为有 datacenterId 和 workerId 来做区分）</li></ul></li><li>缺点<ul><li>依赖于系统时钟的一致性。如果某台机器的系统<strong>时钟回拨</strong>，有可能造成ID冲突，或者ID乱序<ul><li>时钟回拨：系统时钟向后跳变</li></ul></li><li>还有，在启动之前，如果这台机器的系统<strong>时间回拨过</strong>，那么有可能出现ID重复的危险</li></ul></li></ul><h3 id="数据库自增"><a href="#数据库自增" class="headerlink" title="数据库自增"></a>数据库自增</h3><ul><li>利用数据库本身来进行设置，在全数据库内保持唯一</li></ul><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>操作简单，建表时设置<code>auto_increment</code>即可</li><li>由于其递增有序，索引性能高</li></ul></li><li>缺点<ul><li>强依赖DB。不同数据库语法和实现不同，数据库迁移的时候、多数据库版本支持的时候、或分表分库的时候需要处理（造成 ID 不全局统一），会比较麻烦。当DB异常时整个系统不可用，属于致命问题</li><li>单点故障。在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险</li><li>数据一致性问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致<strong>重复发号</strong></li><li>难于扩展。在性能达不到要求的情况下，比较难于扩展。ID发号性能瓶颈限制在单台MySQL的读写性能</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库字段设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/SpringCloud/"/>
      <url>/SpringCloud/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在此感谢黑马程序员提供的2024版SprinCloud学习课程~~</p><p><a href="https://www.bilibili.com/video/BV1S142197x7?vd_source=7341c7fca3b496e9108bb1fd49c634ef">2024最新SpringCloud微服务开发与实战</a>，<a href="https://b11et3un53m.feishu.cn/wiki/FYNkwb1i6i0qwCk7lF2caEq5nRe">黑马文档</a></p></blockquote><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h2><blockquote><p>官网<code>https://baomidou.com/</code></p></blockquote><h3 id="使用MybatisPlus的基本步骤"><a href="#使用MybatisPlus的基本步骤" class="headerlink" title="使用MybatisPlus的基本步骤"></a>使用MybatisPlus的基本步骤</h3><ol><li>引入MybatisPlus依赖，代替Mybatis依赖</li><li>定义Mapper接口并继承BaseMapper</li></ol><h3 id="MybatisPlus概况"><a href="#MybatisPlus概况" class="headerlink" title="MybatisPlus概况"></a>MybatisPlus概况</h3><ol><li>MybatisPlus是如何知道我们要查询的是哪张表？表中有哪些字段呢？<ol><li>首先原理是基于反射</li></ol></li><li>看下图<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/04/fOawPhUYWF7K6Np.png" alt="img"></li><li>泛型中的<code>User</code>就是与数据库对应的表</li><li>MybatisPlus就是根据ROJO实体的信息来推断出表的信息，从而生成SQL</li><li>默认情况下<ul><li>MybatisPlus会把POJO实体的类名<strong>驼峰转下划线</strong>作为表名</li><li>MybatisPlus会把POJO实体的所有变量名<strong>驼峰转下划线</strong>作为表的字段名，并根据变量类型推断字段类型</li><li>MybatisPlus会把名为id的字段作为<strong>主键</strong></li></ul></li></ol></li><li>但很多情况下，默认的实现与实际场景不符，因此MybatisPlus提供了一些<strong>注解</strong>便于我们声明表信息</li></ol><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><h4 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h4><ol><li>该注解用来指定表名，使用位置在实体类</li></ol><h4 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h4><ol><li>该注解标明表的主键以及指定<code>IdType</code>，使用位置在实体类的主键字段</li><li>IdType常见得三种类型<ol><li><code>AUTO</code>：利用数据库的id自增长</li><li><code>INPUT</code>：手动生成id</li><li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略（在表中需要取消自增策略）<ol><li>雪花飘移算法<code>https://github.com/yitter/idgenerator/tree/master/Java</code>也很好用</li></ol></li></ol></li></ol><h4 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h4><ol><li>该注解指明表的普通字段</li><li>一般情况下我们并不需要给字段添加<code>@TableField</code>注解，一些特殊情况除外：<ul><li>成员变量名与数据库字段名不一致</li><li>成员变量是以<code>isXXX</code>命名，按照<code>JavaBean</code>的规范，<code>MybatisPlus</code>识别字段时会把<code>is</code>去除，这就导致与数据库不符</li><li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用<code>@TableField</code>注解给字段名添加转义字符：@TableField(“ ‘order’ “)</li></ul></li></ol><ul><li>示例</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/04/jvaZEyPbl81Vc4X.png" alt="img"></p><h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><ul><li><p>大多数的配置都有默认值；但还有一些是没有默认值的，例如：</p><ul><li><p>实体类的别名扫描包</p></li><li><p>全局id类型</p></li></ul></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/04/5BGcxrsbzAWoiKk.png" alt="img"></p></li></ul><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><h4 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h4><blockquote><p>个人感觉MP对单表的CRUD方法很好用，但是对sql的编写还是在xml文件中更舒适</p></blockquote><ol><li>构建查询条件<ol><li>QueryWrapper</li><li>UpdateWrapper</li><li>LambdaQueryWrapper 和 LambdaUpdateWrapper（推荐）<ol><li>这两种基于反射形式，没有硬编码，而且相对来说使用舒适</li></ol></li></ol></li></ol><h4 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h4><ul><li><p>复杂的where条件通过Wrapper编写，然后自定义SQL语句的剩下部分</p><ul><li>感觉还是不太友好，简单的<code>where</code>不需要，复杂的<code>where</code>不一定好，代码量的确减少</li><li>而且，拼接起来的SQL也非常危险，侵入性也高</li><li>SQL报错，mapper、service都需要看</li></ul></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">    userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h4><ol><li><p>使用</p><ol><li>自定义Service接口继承IService接口–方法声明</li><li>自定义实现类继承ServiceImpl<code>&lt;xxxMaper,xxx&gt;</code>类–方法实现</li><li>原理如图，虚线实现、实线继承，看源码即可</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/04/U1qyb92xJ3cgAGQ.png" alt="img"></li></ol></li><li><p>使用场景</p><ol><li>对一些极为简单的CRUD操作，在Contoller中就可以直接完成</li><li>对具有复杂业务的操作依然是Contoller-Service-Mapper形式完成</li><li>个人觉得，仅从实现业务的角度上看，二者配合使用效果最好<ol><li><a href="https://www.zhihu.com/question/314745062/answer/3282783134">MP使用看法</a></li></ol></li></ol></li><li><p>Lambda用法</p><blockquote><p>这个相较与前面，使用起来确实更加舒适</p></blockquote><ol><li><p>在IService中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化；我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code>，而是直接调用<code>lambdaQuery</code>和<code>lambdaUpdate</code>方法</p></li><li><p>基于LambdaQuery</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以发现LambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>list()</code>，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用<code>list()</code>，可选的方法有：<ul><li><code>.one()</code>：最多1个结果</li><li><code>.list()</code>：返回集合结果</li><li><code>.count()</code>：返回计数结果</li></ul></li></ol></li><li><p>基于LambdaUpdate</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2.校验用户状态</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.扣减余额 update tb_user set balance = balance - ?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, remainBalance) <span class="comment">// 更新余额</span></span><br><span class="line">            .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 动态判断，是否更新status</span></span><br><span class="line">            .eq(User::getId, id)</span><br><span class="line">            .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>同样，LambdaUpdate方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>update()</code>，表示更新数据</li></ol></li></ol></li><li><p>批量新增</p><ol><li><p>毫无疑问，批量新增比循环新增100000数据快的多</p><ol><li>这里批量插入更快的原因是网络请求的次数减少</li></ol></li><li><p>如果想要进一步提升批量插入的性能，如何做？</p><ol><li>看<code>MybatisPlus</code>源码分析</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);<span class="comment">//逐条插入数据</span></span><br><span class="line">    <span class="keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="type">boolean</span> <span class="title function_">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLimit</span> <span class="operator">=</span> Math.min(batchSize, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据<ol><li>简单看看这篇 <code>https://blog.csdn.net/qq_71443736/article/details/134728125</code>博客了解预编译模式</li></ol></li><li>它SQL类似</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Preparing: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time ) <span class="keyword">VALUES</span> ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br></pre></td></tr></table></figure><ol start="4"><li>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_4, <span class="number">123</span>, <span class="number">18688190004</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li><p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。</p><ol><li>参考文档：<code>https://www.mysql.com/</code></li><li>这个参数的默认值是false，我们需要修改连接参数，将其配置为true。就可以实现上述SQL语句的实现</li><li>在<code>ClientPreparedStatement</code>的<code>executeBatchInternal</code>中，会判断<code>rewriteBatchedStatements</code>值是否为true并重写SQL的功能</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8</span>      <span class="string">&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="string">&amp;rewriteBatchedStatements=true</span> </span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">abc123</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><ol><li><p>代码生成器</p><ul><li>帮助生成通用代码格式</li><li>两款插件，对生成代码来说都可以<ul><li>MyBatis-X</li><li>MyBatisPlus</li></ul></li></ul></li><li><p>静态工具</p><ol><li>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以实现CRUD功能<ol><li>何为循环依赖<code>https://blog.csdn.net/kaka_buka/article/details/139785462</code></li></ol></li></ol></li><li><p>逻辑删除</p><ol><li>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：<ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul></li><li>配置</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>注意，逻辑删除本身也有自己的问题，比如：<ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul></li><li>还有一种解决是，如果数据不能删除，可以采用把数据迁移到其它表的办法</li></ol></li><li><p>枚举处理器</p><ol><li><p>对静态字段的代替，增强代码的可阅读性</p><ol><li>也可以看看这篇blog<code>https://blog.csdn.net/qq_45036591/article/details/104159613</code></li></ol></li><li><p>枚举类型与数据库类型的相互转换</p><ol><li><p>告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值；<code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/1CNwZcoU3SzPy4i.png" alt="img"></p></li><li><p>配置（3.5.2后无需配置）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span>     <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure></li><li><p>这样查询出来的状态字段是枚举类型而不是单纯的0和1</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/eBSgTyYVUPK3kD5.png" alt="img"></li></ol></li></ol></li><li><p>使页面查询结果也是枚举格式</p><ol><li>在UserStatus枚举中通过<code>@JsonValue</code>注解标记JSON序列化时展示的字段：<code>desc</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/DpVHe96PcWxIRSM.png" alt="img"></li></ol></li></ol></li><li><p>JSON处理器</p><ol><li><p>数据库的user表中有一个<code>info</code>字段，是JSON类型</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/ePkSmYw1oALaF7E.png" alt="img"></li><li>而User实体类中却是<code>String</code>类型</li><li>这样一来，我们要读取<code>info</code>中的属性时就非常不方便；如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类</li><li>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦</li></ol></li><li><p>MybatisPlus提供了很多特殊类型字段的类型处理器（TypeHandler），解决特殊字段类型与数据库类型转换的问题</p><ol><li>例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器</li></ol></li><li><p>使用Json处理器完成JSON字段与对象间的转换</p><ol><li><p>定义一个单独实体类来与info字段的属性匹配</p></li><li><p>将User类的info字段修改为UserInfo类型，并声明类型处理器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line"><span class="keyword">private</span> UserInfo info;</span><br></pre></td></tr></table></figure></li><li><p>开启结果集映射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h3><ul><li>MP提供很多插件，分页插件最为常用</li></ul><h4 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h4><ul><li><p>在未引入分页插件的情况下，<code>MybatisPlus</code>是不支持分页功能的，<code>IService</code>和<code>BaseMapper</code>中的分页方法都无法正常起效</p></li><li><p>首先需要配置分页插件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 创建分页插件</span></span><br><span class="line">        <span class="type">PaginationInnerInterceptor</span> <span class="variable">paginationInnerInterceptor</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MysQL);</span><br><span class="line">        paginationInnerInterceptor.setMaxLimit(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">//2.添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(paginationInnerInterceptor);</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><blockquote><p>版本不同可能API会有改变</p></blockquote><ul><li>当前页pageNo，查询条数pagesize<ul><li><code>Page&lt;User&gt; page = Page.of(pageNo, pagesize);</code></li></ul></li><li>排序条件<ul><li><code>page.addorder(new OrderItem(column: &quot;balance&quot;,asc:true));</code></li></ul></li><li>通过xxxService或xxxMapper调用分页查询<ul><li><code>Page&lt;User&gt; p = userService.page(page);</code></li></ul></li><li>返回结果<ul><li>总数据<code>List&lt;User&gt; records = p.getRecords();</code></li><li>总条数<code>long total = p.getTotal()</code></li><li>总页数<code>long pages = p.getPages()</code></li></ul></li></ul></li></ul><h4 id="通用分页实体"><a href="#通用分页实体" class="headerlink" title="通用分页实体"></a>通用分页实体</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页查询实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageSize;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;排序字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否升序&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//泛型方法,用来直接返回Page&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(OrderItem ... orders)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.分页条件</span></span><br><span class="line">        Page&lt;T&gt; p = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">// 2.排序条件</span></span><br><span class="line">        <span class="comment">// 2.1.先看前端有没有传排序字段</span></span><br><span class="line">        <span class="keyword">if</span> (sortBy != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(sortBy, isAsc));</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.再看有没有手动指定排序字段</span></span><br><span class="line">        <span class="keyword">if</span>(orders != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.addOrder(orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从<code>PageQuery</code>到<code>MybatisPlus</code>的<code>Page</code>之间转换的过程还是比较麻烦；在<code>PageQuery</code>这个实体中定义工具方法，来简化开发</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">empty</span><span class="params">(Page&lt;P&gt; p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voClass 目标VO类型的字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> convertor PO到VO的转换函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类的泛型参数是在<strong>类实例化</strong>时确定的，而静态方法在实例化之前就可以被调用，因此无法直接引用类的泛型参数，而需要重新定义泛型</li><li>泛型没有字节码，所以函数调用者应该传参数<code> Class&lt;V&gt; voClass</code></li><li>调用者自定义PO到VO的转换方式，这就需要传递一个行为，也就是函数式接口<ul><li>函数式编程</li><li>Lambda表达式的使用</li><li>Stream流的使用</li></ul></li><li>自定义工具类完成对MP的转换，而不是把方法放在实体中，完成解耦合</li></ul><hr><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><blockquote><p>快速构建、运行、管理应用的工具</p></blockquote><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><blockquote><p>虚拟机VMware；L系统Centos-7；远程连接工具 MobaXterm</p><p>详细安装<code>https://b11et3un53m.feishu.cn/wiki/FJAnwOhpIihMkLkOKQocdWZ7nUc</code></p><p>docker官方交流社区<code>https://hub.docker.com</code></p><p>一个不错的docker容器管理UI <code>https://mp.weixin.qq.com/s/daB65RX41d4KgXQzGKtYOA</code></p></blockquote><ol><li><p>开启虚拟机，远程连接</p></li><li><p>卸载旧版Docker</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker<span class="literal">-client</span> \</span><br><span class="line">    docker<span class="literal">-client-latest</span> \</span><br><span class="line">    docker<span class="literal">-common</span> \</span><br><span class="line">    docker<span class="literal">-latest</span> \</span><br><span class="line">    docker<span class="literal">-latest-logrotate</span> \</span><br><span class="line">    docker<span class="literal">-logrotate</span> \</span><br><span class="line">    docker<span class="literal">-engine</span></span><br></pre></td></tr></table></figure></li><li><p>配置Docker的yum库</p><ol><li>安装yum工具 <code>yum install -y yum-utils</code></li><li>安装成功后，执行命令，配置Docker的yum源(阿里云镜像)<ol><li><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></li></ol></li></ol></li><li><p>开始安装Docker</p><ol><li><code>yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></li></ol></li><li><p>校验是否安装成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 版本查看</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 停止Docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># 查看docker状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><ol><li><p>使用阿里云的<strong>容器镜像服务</strong>或其他镜像加速器</p><ol><li>打开aliyun，得到镜像加速地址<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/06/fxRykNFotOMZi72.png" alt="img"></li></ol></li><li>具体命令</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="comment"># 复制内容，注意把其中的镜像加速地址改成自己的</span></span><br><span class="line"><span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://xxxx.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启Docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="3"><li>成功，在&#x2F;etc&#x2F;docker文件夹中有一个daemon.json文件，后续直接通过VScode修改</li></ol></li></ol><h3 id="快速入门-部署MySQL"><a href="#快速入门-部署MySQL" class="headerlink" title="快速入门-部署MySQL"></a>快速入门-部署MySQL</h3><ul><li><p>如果之前已经部署过MySQL，建议先删除</p><ul><li>具体删除文档<code>https://www.jb51.net/article/179020.htm</code></li><li>删除前先关闭MySQL的服务  <code>systemctl stop mysql 或者 service mysql stop</code><ol><li>关闭后，<code>systemctl status mysql</code> 查看是否关闭</li></ol></li><li>使用 rpm 命令查看已安装的MySQL<ol><li><code>rpm -qa|grep mysql</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/06/QfH5t7LzPC4UA9k.png" alt="img"></li></ol></li><li>使用yum安装的话，需要清除服务<code>yum remove mysql mysql-server mysql-libs mysql-server</code></li><li>再次查询<ol><li><code>rpm -qa|grep mysql</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/06/8nGDXKVCPJWLQk2.png" alt="img"></li><li>通过 <code>rpm -ev + 对应文件名</code> 删除</li></ol></li><li>查找MySQL相关的目录文件并对应删除<ol><li><code> find / -name mysql</code></li><li>使用<code>rm -rf + 查询出来的目录或文件名</code></li></ol></li><li>再次检查是否有遗漏<ol><li><code>rpm -qa|grep mysql</code></li><li><code> find / -name mysql</code></li></ol></li><li>注意<ol><li><code>rpm -ev</code>是软件包管理器，删除的是一个软件包</li><li><code>rm -rf</code>是删除某个目录或文件</li></ol></li></ul></li><li><p>如果是利用传统方式部署MySQL，大概的步骤有：</p><ul><li>搜索并下载MySQL安装包</li><li>上传至Linux环境</li><li>编译和配置环境</li><li>安装</li></ul></li><li><p>我们利用Docker来部署MySQL</p><ul><li><p>一步即可</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/11/5UjOryd3Atzpib9.png" alt="img"></p></li><li><p>部署完毕后，通过任意客户端工具连接MySQL</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/HcoW7NZfAemkF3J.png" alt="img"></li></ul></li><li><p>可以发现，当我们执行命令后，Docker做的第一件事情，是去自动搜索并下载了MySQL，然后会自动运行MySQL，我们完全不用插手</p></li><li><p>这种安装方式你完全不用考虑运行的操作系统环境，它不仅仅在CentOS系统是这样，在Ubuntu系统、macOS系统、甚至是装了WSL的Windows下，都可以使用这条命令来安装MySQL。要知道，<strong>不同操作系统下其安装包、运行环境是都不相同的</strong>！如果是<strong>手动安装，必须手动解决安装包不同、环境不同的、配置不同的问题</strong>！</p></li><li><p>使用Docker，这些完全不用考虑。就是因为Docker会自动搜索并下载MySQL</p><ul><li>注意：这里下载的不是安装包，而是<strong>镜像。</strong>镜像中不仅包含了MySQL本身，还包含了其运行所需要的<strong>环境、配置、系统级函数库</strong>。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器</strong></li><li>镜像的英文是<code>image</code>、容器的英文是<code>container</code></li></ul></li><li><p>因此，Docker安装软件的过程，就是自动搜索下载镜像，然后创建并运行容器的过程</p></li></ul></li><li><p>Docker会根据命令中的镜像名称自动搜索并下载镜像，那么问题来了，它是去哪里搜索和下载镜像的呢？这些镜像又是谁制作的呢？</p><ul><li>Docker官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利</li><li>Docker官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站，这个网站就成了Docker镜像交流的社区<code>https://hub.docker.com</code></li><li>基本上我们常用的各种软件都能在这个网站上找到</li></ul></li><li><p>像这种提供存储、管理Docker镜像的服务器，被称为<strong>DockerRegistry</strong>，可以翻译为镜像仓库</p><ul><li><p><strong>DockerHub</strong>网站是官方仓库，阿里云、华为云会提供一些第三方仓库，我们也可以自己搭建私有的镜像仓库</p></li><li><p>官方仓库在国外，下载速度较慢，一般我们都会使用第三方仓库提供的镜像加速功能，提高下载速度</p></li><li><p>企业内部的机密项目，往往会采用私有镜像仓库</p></li><li><p>镜像的来源有两种</p><ul><li><p>基于官方基础镜像自己制作</p></li><li><p>直接去DockerRegistry下载</p></li></ul></li></ul></li><li><p>总结</p><ul><li>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用</li><li>Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并运行容器，应用就部署完成了</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/06/lBtPNbYkMHxFoO4.png" alt="img"></li></ul></li></ul><h3 id="命令解读"><a href="#命令解读" class="headerlink" title="命令解读"></a>命令解读</h3><ul><li>以下是部署mysql时的命令，他们有什么含义呢？</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><ul><li><p>解读</p><ul><li><p><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器里的进程在后台运行</p></li><li><p><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code> ，全局唯一</p></li><li><p><code>-p 3306:3306</code> : 设置端口映射</p><ul><li>容器其实就是一个小型的服务，也有ip地址，但是我们无法ping通，不过我们可以ping通虚拟机的ip</li><li><strong>容器是隔离环境</strong>，外界不可访问，但是可以将<strong>宿主机（虚拟机）端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><p><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数（配置容器运行时需要的环境变量）</p><ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><p><code>mysql</code> : <strong>镜像</strong>名称（REPOSITORY），Docker会根据这个名字搜索并下载镜像</p><ul><li><p>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</p></li><li><p>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></p></li></ul></li></ul></li><li><p>镜像的名称不是随意的，而是要到DockerRegistry中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在DockerHub网站或者软件的官方网站中都能找到</p></li><li><p>如果我们要安装其它软件，也可以到<a href="https://hub.docker.com/">DockerRegistry</a>中寻找对应的镜像名称和版本，阅读相关配置即可</p></li></ul><h3 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h3><h4 id="Docker常见命令"><a href="#Docker常见命令" class="headerlink" title="Docker常见命令"></a>Docker常见命令</h4><blockquote><p>官方文档<code>https://docs.docker.com/</code></p></blockquote><ul><li><p>常见的命令有</p><ul><li><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="center">docker pull</td><td align="center">拉取镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="center">docker push</td><td align="center">推送镜像到DockerRegistry</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="center">docker images</td><td align="center">查看本地镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="center">docker rmi</td><td align="center">删除本地镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="center">docker run</td><td align="center">创建并运行容器（不能重复创建）</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="center">docker stop</td><td align="center">停止指定容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="center">docker start</td><td align="center">启动指定容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="center">docker restart</td><td align="center">重新启动容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="center">docker rm</td><td align="center">删除指定容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="center">docker ps</td><td align="center">查看容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="center">docker logs</td><td align="center">查看容器运行日志</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="center">docker exec</td><td align="center">进入容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="center">docker save</td><td align="center">保存镜像到本地压缩文件</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="center">docker load</td><td align="center">加载本地压缩文件到镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="center">docker inspect</td><td align="center">查看容器详细信息</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table></li><li><p><code>docker command --help</code>查看当前命令的帮助文档</p></li></ul></li><li><p>补充</p><ul><li><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器；通过命令可以实现开机自启</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>命令之间的关系</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/08/bSWLIyFfZn69X2O.png" alt="img"></li></ul></li><li><p>案例</p><ul><li>需求：查看DockerHub，拉取Nginx镜像，创建并运行Nginx容器<ul><li><p>查看DockerHub</p><ul><li><code>https://hub.docker.com/_/nginx</code></li></ul></li><li><p>拉取Nginx镜像</p><ul><li><code>docker pull nginx</code></li></ul></li><li><p>查看本地镜像列表</p><ul><li><code>docker images</code></li></ul></li><li><p>创建并运行Nginx容器</p><ul><li><code>dokcer run -d --name nginx -p 81:80 nginx</code></li></ul></li><li><p>查看容器</p><ul><li><code>docker ps -a</code></li><li>格式化查询<code>docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</code></li></ul></li><li><p>查看容器运行日志</p><ul><li><code>docker logs nginx</code></li></ul></li><li><p>停止容器</p><ul><li><code>docker stop nginx</code></li></ul></li><li><p>再次启动容器</p><ul><li><code>docker start nginx</code></li></ul></li><li><p>进入Nginx容器</p><ul><li><code>docker exec -it nginx bash</code></li></ul></li><li><p>删除容器</p><ul><li><code>docker rm nginx</code>，需要先关闭nginx容器</li><li>强制删除<code>docker rm -f nginx</code></li></ul></li></ul></li></ul></li><li><p>命令别名</p><ul><li><p>给常用Docker命令起别名，方便访问</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vim /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line">alias <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line">alias <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line">alias <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table&#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> /<span class="type">etc</span>/<span class="type">bashrc</span> ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>配置生效</p><ul><li><code>source /root/.bashrc</code></li></ul></li></ul></li></ul><h4 id="数据卷（volume）"><a href="#数据卷（volume）" class="headerlink" title="数据卷（volume）"></a>数据卷（volume）</h4><ul><li><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便，而以下问题的解决就依赖于数据卷</p><ul><li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让Nginx代理我的静态资源怎么办？</li></ul></li><li><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器</strong>解耦。</p></li><li><p>何为数据卷？</p><ul><li><strong>数据卷</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机</strong>目录之间映射的桥梁</li></ul></li><li><p>案例1-利用Nginx容器部署静态资源</p><ul><li><p>以Nginx为例，我们知道Nginx中有两个关键的目录</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li><li>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件</li><li>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/12/cwC6Kz8iNFd9kft.png" alt="img"></li><li>在上图中<ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li><li>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong></li><li>此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内部的<code>/usr/share/nginx/html/_data</code>目录；只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了</li></ul></li></ul></li><li><p><strong>小提示</strong></p><ul><li><p><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code></p></li><li><p>为什么不让容器目录直接指向宿主机目录呢？</p><ul><li>因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了</li></ul></li><li><p>但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与宿主机目录之间的映射关系即可</p></li><li><p>不过，我们通过由于数据卷目录比较深，不好寻找，通常我们也<strong>允许让容器直接与宿主机目录挂载</strong>而不使用数据卷</p></li></ul></li></ul></li><li><p>数据卷的相关命令</p><ul><li><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="center">docker volume create</td><td align="center">创建数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="center">docker volume ls</td><td align="center">查看所有数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="center">docker volume rm</td><td align="center">删除指定数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="center">docker volume inspect</td><td align="center">查看某个数据卷的详情</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="center">docker volume prune</td><td align="center">清除数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table></li><li><p>注意</p><ul><li>容器与数据卷的挂载要在<strong>创建容器时配置</strong>，对于创建好的容器，是不能设置数据卷的</li><li><strong>创建容器的过程中，数据卷会自动创建</strong></li></ul></li></ul></li><li><p>Nginx的html目录挂载</p><ul><li>首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷<ul><li><code>docker run -d --name nginx -p 81:80 -v html(数据卷名):/usr/share/nginx/html(容器内目录) nginx</code></li></ul></li><li>查看数据卷<ul><li><code>docker volume ls</code></li></ul></li><li>查看数据卷具体信息<ul><li><code>docker volume inspect html(数据卷名)</code></li><li>得到宿主机目录，可以查看和修改</li></ul></li><li>进入容器内部，查看容器内目录内的文件是否变化<ul><li><code>docker exec -it nginx bash</code></li><li><code>cd /usr/share/nginx/html(容器内目录)</code></li></ul></li></ul></li><li><p>本地目录&#x2F;文件挂载</p><ul><li><p>案例2-mysql容器的数据挂载</p><ul><li>需求<ul><li>查看mysql容器，判断是否有数据卷挂载</li><li>基于宿主机目录实现MySQL数据目录、配置文件、初始化脚本的挂载（查阅官方镜像文档）</li></ul></li></ul></li><li><p>查看容器是否挂载</p><ul><li><code>docker inspect 容器名</code></li></ul></li><li><p>匿名数据卷</p><ul><li><p>使用<code>docker inspect 容器名</code>后，关注</p><ul><li><p><code>.Config.Volumes</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;/var/lib/mysql&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是<strong>数据卷未定义</strong>；这就是匿名卷。</p></li><li><p><code>.Mounts</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。</li><li>Source：宿主机目录</li><li>Destination : 容器内的目录</li><li>上述配置是将容器内的<code>/var/lib/mysql</code>这个目录，与数据卷<code>29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</code>挂载。于是在宿主机中就有了<code>/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code>这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别</li></ul></li></ul></li><li><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载</p></li></ul></li><li><p>实现本地目录挂载</p><ul><li><p>查看docker-mysql官方镜像获取各个路径</p><ul><li>mysql的数据目录路径<code>/var/lib/mysql</code></li><li>配置文件路径<code>/etc/mysql/my.cnf</code></li><li>初始化脚本路径<code>/docker-entrypoint-initdb.d</code></li></ul></li><li><p>设计本地挂载目录</p><ul><li><code>/root/mysql/init</code>-&gt; <code>/docker-entrypoint-initdb.d</code></li><li><code>/root/mysql/data</code>-&gt; <code>/var/lib/mysql</code></li><li><code>/root/mysql/conf</code>-&gt;<code>/etc/mysql/my.cnf</code></li><li>注意：本地目录需要绝对路径（&#x2F; 或.&#x2F; 开头），否则会以为是数据卷挂载</li></ul></li><li><p>创建本地目录mysql</p><ul><li><code>mkdir data | mkdir init | mkdir conf</code></li><li>导入黑马的sql和配置文件</li></ul></li><li><p>命令脚本</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  <span class="literal">-v</span> ./mysql/<span class="keyword">data</span>:/var/lib/mysql \</span><br><span class="line">  <span class="literal">-v</span> ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  <span class="literal">-v</span> ./mysql/init:/docker<span class="literal">-entrypoint-initdb</span>.d \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure></li><li><p>通过Navicat等连接mysql查看是否有hmall数据库</p></li></ul></li></ul></li></ul><h4 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h4><ul><li><p>镜像结构</p><ul><li>镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖</li><li>因此，自定义镜像本质就是依次准备好程序运行的<strong>基础环境、依赖、应用本身、运行配置</strong>等文件，分成打包</li><li>举个例子，我们要从0部署一个Java应用，大概流程是这样：<ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行Jar包</li></ul></li><li>那因此，我们打包镜像也是分成这么几步：<ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li><li>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong></li><li>镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作</li><li>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像；然后再搭建其它层即可</li><li>最终整个Java项目的镜像结构如图所示<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/oPfvIlQ2eBN8aRS.png" alt="img"></li></ul></li></ul></li></ul></li><li><p><strong>DockerFile</strong></p><ul><li><p>记录镜像结构的文件</p></li><li><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可</p></li><li><p>对应语法</p><ul><li><table><thead><tr><th align="center"><strong>指令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="center"><strong>FROM</strong></td><td align="center">指定基础镜像</td><td align="center"><code>FROM centos:6</code></td></tr><tr><td align="center"><strong>ENV</strong></td><td align="center">设置环境变量，可在后面指令使用</td><td align="center"><code>ENV key value</code></td></tr><tr><td align="center"><strong>COPY</strong></td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="center"><strong>RUN</strong></td><td align="center">执行Linux的shell命令，一般是安装过程的命令</td><td align="center"><code>RUN yum install gcc</code></td></tr><tr><td align="center"><strong>EXPOSE</strong></td><td align="center">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="center">EXPOSE 8080</td></tr><tr><td align="center"><strong>ENTRYPOINT</strong></td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table></li><li><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>问题</p><ul><li>以后会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，极其麻烦</li><li>所以，就有人提供了基础的系统+JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置</li></ul><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>构建镜像</p><ul><li><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了</p></li><li><p>导入hm资料中的demo项目及对应的Dockerfile</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/ErTV7nvMLJA2lRj.png" alt="img"></li></ul></li><li><p>将<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录</p></li><li><p>构建命令</p><ul><li>进入demo目录<code>cd /root/demo</code></li><li><code>docker build -t docker-demo:1.0 .</code></li></ul></li><li><p>命令说明</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0（版本号）</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，</li><li>也可以直接指定Dockerfile目录 <code>docker build -t docker-demo:1.0 /root/demo</code></li></ul></li><li><p>查看镜像列表<code>docker images</code></p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/BS9rsWhfMTNHzLj.png" alt="img"></li></ul></li><li><p>然后尝试运行该镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建并运行容器</span></span><br><span class="line">docker run --name <span class="built_in">dd</span> -p 8080:8080 -d docker-demo:1.0</span><br><span class="line"><span class="comment"># 2.查看容器</span></span><br><span class="line">docker ps -a </span><br><span class="line"><span class="comment"># 3.查看容器运行日志</span></span><br><span class="line">docker logs -f <span class="built_in">dd</span></span><br><span class="line"><span class="comment"># 3.访问</span></span><br><span class="line">虚拟机地址:8080/hello/count</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li><p>Java项目往往需要访问其它各种中间件，例如MySQL、Redis等</p><ul><li>在以往的的单体项目中都是通过导入依赖、配置文件进行访问</li></ul></li><li><p>那容器之间能否互相访问吗？</p><ol><li>进入dd容器<code>docker exec -it dd bash</code></li><li><code>ping ip地址(其他容器)</code></li><li>结果：可以ping通，说明容器之间可以通过ip地址互相访问</li></ol></li><li><p>容器的ip从何而来？</p><ol><li><p>在安装docker时，docker会在虚拟机创建一张网卡<code>docker0</code>，该网卡会创建虚拟网桥<code>172.17.0.1/16</code></p></li><li><p>默认情况下，所有容器都是以“桥接”方式连接到Docker的一个虚拟网桥上，从而得到一个ip</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/bdXyZKP5Qe4JmiI.png" alt="img"></li></ol></li></ol></li><li><p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接失败</p></li><li><p><strong>自定义网络</strong></p><ul><li><p>docker的网络功能</p><ul><li>创建自定义网络，形成新的网桥，加入该网桥的容器可以互联，且加入自定义网络的容器可以通过容器名互相访问</li></ul></li><li><p>常见命令</p><ul><li><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="center">docker network create</td><td align="center">创建一个网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="center">docker network ls</td><td align="center">查看所有网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="center">docker network rm</td><td align="center">删除指定网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="center">docker network prune</td><td align="center">清除未使用的网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="center">docker network connect</td><td align="center">使指定容器连接加入某网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="center">docker network disconnect</td><td align="center">使指定容器连接离开某网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="center">docker network inspect</td><td align="center">查看网络详细信息</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table></li><li><p><code>docker network --help</code></p></li></ul></li><li><p>示例</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1创建新网络</span></span><br><span class="line">docker network create heima</span><br><span class="line"><span class="comment">#2使指定容器连接加入网络</span></span><br><span class="line">docker network connect 网络名 容器名</span><br><span class="line"><span class="comment">#2(2)使指定容器连接加入网络,在容器创建时就加入</span></span><br><span class="line">docker run <span class="literal">--name</span> dd <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">8080</span> <span class="literal">--network</span> heima <span class="literal">-d</span> docker<span class="literal">-demo</span></span><br><span class="line"><span class="comment">#3进入dd容器中</span></span><br><span class="line">ping 加入该网络的容器名</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><ul><li><p>部署Java项目</p><ol><li>将项目打包</li><li>将项目的hm-service.jar包和dockerfile文件上传至<code>/root/</code>下，构建镜像<code>docker build -t hmall:1.0 /root </code></li><li>创建容器<code>docker run -d --name hmall --network heima -p 8080:8080 hmall</code></li><li>测试，通过浏览器访问：<code>http://你的虚拟机地址:8080/search/list</code></li></ol></li><li><p>部署前端</p><ol><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/w1IveckyO24Q6t7.png" alt="ing"></p></li><li><p>把nginx目录上传到虚拟机的<code>/root</code>目录下</p></li><li><p>实现本地目录挂载</p><ol><li><code>/root/nginx/nginx.conf</code>挂载到<code>/etc/nginx/nginx.conf</code></li><li><code>/root/nginx/html</code>挂载到<code>/usr/share/nginx/html</code></li></ol></li><li><p>创建nginx容器</p><ol><li><p>由于需要让nginx同时代理hmall-portal和hmall-admin两套前端资源，因此我们需要暴露两个端口</p><ol><li>18080：对应hmall-portal</li><li>18081：对应hmall-admin</li></ol></li><li><p>命令如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name nginx \</span><br><span class="line">  -p 18080:18080 \</span><br><span class="line">  -p 18081:18081 \</span><br><span class="line">  -v /root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">  --network hmall \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure></li></ol></li><li><p>测试，通过浏览器访问：<code>http://你的虚拟机ip:18080</code></p></li></ol></li><li><p><strong>DockerCompose</strong></p><ul><li><p>稍微复杂的项目，其中还有各种各样的其它中间件，需要部署的东西远不止3个；如果还像之前那样手动的逐一部署，就太麻烦</p></li><li><p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>；它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器</p></li><li><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）；由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似</p><ul><li><p>用docker run部署MySQL的命令如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure></li><li><p>如果用<code>docker-compose.yml</code>文件来定义</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="comment">#多服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># mysql服务</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>黑马商城的部署文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="comment"># 依赖</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="comment">#网络创建</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>docker compose的命令</p><ul><li>命令格式<code>docker compose [OPTIONS] [COMMAND]</code></li><li>其中，OPTIONS和COMMAND都是可选参数，比较常见的有<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/qXnR24BC8OFmM1h.png" alt="img"></li></ul></li></ul></li></ul><hr><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><ul><li>根据黑马课程，导入黑马商城</li></ul><h2 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h2><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><ul><li>单体架构：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/14/cCZJiLBnTauj1Ef.jpg" alt="ing"></li></ul></li><li>优点<ul><li>架构简单</li><li>部署成本低</li></ul></li><li>缺点<ul><li>团队协作成本高<ul><li>试想一下，你们团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊；最终要把功能合并到一个分支，你绝对会陷入到解决冲突的泥潭之中</li></ul></li><li>系统发布效率低<ul><li>任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时</li></ul></li><li>系统可用性差<ul><li>单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用</li><li>当某一个接口高并发时，对tomcat的资源占用极大，导致其他接口请求速度降慢</li></ul></li></ul></li><li>总结<ul><li>单体架构可用性是比较差的，功能之间相互影响比较大，适合开发功能相对简单，规模较小的项目</li></ul></li></ul><h3 id="微服务-1"><a href="#微服务-1" class="headerlink" title="微服务"></a>微服务</h3><ul><li>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点<ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过10人（2张披萨能喂饱）</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/14/vfd8lWwXqH7SDgn.jpg" alt="img"></li></ul></li><li>微服务解决了哪些单体项目的问题<ol><li>降低团队协作成本<ul><li>由于服务拆分，每个服务代码量大大减少，参与开发的后台人员在1~3名，协作成本大大降低</li></ul></li><li>提高系统发布效率<ul><li>每个服务都是独立部署，当有某个服务有代码变更时，只需要打包部署该服务即可</li></ul></li><li>提高系统可用性<ul><li>每个服务独立部署，并且做好服务隔离，使用自己的服务器资源，不会影响到其它服务</li><li>不会因为某一个高并发功能而影响其他接口</li></ul></li><li>综上所述，微服务架构解决了单体架构存在的问题，特别适合大型互联网项目的开发，因此被各大互联网公司普遍采用。大家以前可能听说过<strong>分布式架构</strong>，分布式就是服务拆分的过程，其实微服务架构正是分布式架构的一种最佳实践的方案</li></ol></li><li>微服务架构(拆分的过程中)存在的问题<ol><li>如果出现跨服务的业务该如何处理?</li><li>页面请求到底该访问哪个服务？</li><li>如何实现各个服务之间的服务隔离？</li></ol></li></ul><h3 id="SpringCloud-微服务框架"><a href="#SpringCloud-微服务框架" class="headerlink" title="SpringCloud(微服务框架)"></a>SpringCloud(微服务框架)</h3><ul><li>微服务拆分碰到的各种问题都有对应的解决方案和微服务组件，而SpringCloud框架可以说是目前Java领域最全面的微服务组件的集合<ul><li>官方链接<code>https://spring.io/projects/spring-cloud/#overview</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/14/rTHBYRNG1fSzlDx.png" alt="img"></li></ul></li><li>SpringCloud依托于SpringBoot的自动装配能力，大大降低了其项目搭建、组件使用的成本。对于没有自研微服务组件能力的中小型企业，使用SpringCloud全家桶来实现微服务开发可以说是最合适的选择</li><li>SpringCloud版本、SpringBoot版本以及JDK版本需要对应</li></ul><h2 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h2><h3 id="微服务拆分原则"><a href="#微服务拆分原则" class="headerlink" title="微服务拆分原则"></a>微服务拆分原则</h3><ul><li>什么时候拆<ul><li>对于<strong>大多数小型项目来说，一般是先采用单体架构</strong>，随着用户规模扩大、业务复杂后<strong>再逐渐拆分为</strong>微服务架构。这样初期成本会比较低，可以快速试错。但是，这么做的问题就在于后期做服务拆分时，可能会遇到很多代码耦合带来的问题，拆分比较困难（<strong>前易后难</strong>）</li><li>而对于一些大型项目，在立项之初目的就很明确，为了长远考虑，在架构设计时就直接选择微服务架构。虽然前期投入较多，但后期就少了拆分服务的烦恼（<strong>前难后易</strong>）</li></ul></li><li>如何拆<ul><li>微服务拆分时<strong>粒度要小</strong>，这其实是拆分的目标。具体可以从两个角度来分析<ul><li><strong>高内聚</strong>：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高</li><li><strong>低耦合</strong>：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强</li></ul></li><li>明确了拆分目标，接下来就是拆分方式了。我们在做服务拆分时一般有两种方式<ul><li><strong>纵向</strong>拆分<ul><li>所谓<strong>纵向拆分</strong>，就是按照项目的功能模块来拆分。例如黑马商城中，就有用户管理功能、订单管理功能、购物车功能、商品管理功能、支付功能等。那么按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性</li></ul></li><li><strong>横向</strong>拆分<ul><li>而<strong>横向拆分</strong>，是看各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合</li></ul></li></ul></li><li>这里采用的是<strong>纵向</strong>拆分的方式<ul><li>用户服务</li><li>商品服务</li><li>订单服务</li><li>购物车服务</li><li>支付服务</li></ul></li></ul></li></ul><h3 id="拆分服务"><a href="#拆分服务" class="headerlink" title="拆分服务"></a>拆分服务</h3><ul><li><p>工程结构</p><ul><li>独立Project<ul><li>多个project</li></ul></li><li>Maven聚合<ul><li>一个工程，多个子module</li></ul></li><li>这里黑马商城采用的是Maven聚合的方式</li></ul></li><li><p>需求</p><ol><li><p>将hm-service中与商品管理相关功能拆分到一个微服务module中，命名为item-service</p></li><li><p>将hm-service中与购物车有关的功能拆分到一个微服务module中，命名为cart-service</p></li><li><p>将hm-service中与用户有关的功能拆分到一个微服务module中，命名为user-service</p></li><li><p>将hm-service中与交易有关的功能拆分到一个微服务module中，命名为trade-service</p></li><li><p>将hm-service中与支付有关的功能拆分到一个微服务module中，命名为pay-service</p></li></ol></li><li><p>需求实现</p><ol><li>在hmall工程中新建对应的item-service模块</li><li>新建<code>com.hmall.item</code>包</li><li>新建<code>ItemApplication</code>启动类在<code>com.hmall.item</code>包下</li><li>在<code>com.hmall.item</code>包新建<code>domain、mapper、service、controller</code>包</li><li>在<code>hmall-service</code>中拷贝配置文件到<code>item-service</code>的Resources中，修改其中的端口、以及一些关于<code>item</code>的配置</li><li>将<code>hmall-service</code>中各个有关<code>item</code>的类复制到<code>item-service</code>中，修改异常</li><li>测试实现，在Service中启动<code>item-service</code>，通过doc文档验证接口是否正确</li></ol></li><li><p>其他需求的实现基本同上，可能需要补充其他package</p></li></ul><h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><ul><li><p>在拆分的时候，我们发现一个问题：就是购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了<code>item-service</code>服务，导致我们无法查询</p></li><li><p>最终结果就是查询到的购物车数据不完整，因此要想解决这个问题，我们就必须改造其中的代码，把原本本地方法调用，改造成跨微服务的远程调用（RPC，即<strong>R</strong>emote <strong>P</strong>roduce <strong>C</strong>all）</p></li><li><p>因此，现在查询购物车列表的流程变成了这样</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/15/lMZ8hJVdrLKnf4i.png" alt="img"></li></ul></li><li><p>RPC的实现方式有很多，比如</p><ul><li>基于Http协议</li><li>基于Dubbo协议</li><li>hm中使用的是Http方式，这种方式不关心服务提供者的具体技术实现，只要对外暴露Http接口即可，更符合微服务的需要</li></ul></li><li><p>问题是如何实现跨服务调用呢？</p><ol><li>浏览器到购物车是通过一个http请求，所以在两个Java项目中也可以通过一个http请求来实现服务调用获取商品信息</li><li>Spring提供了一个RestTemplate的API，可以方便的实现Http请求的发送<ol><li>其支持常见的Get、Post、Put、Delete请求，如果请求参数比较复杂，还可以使用<code>exchange()</code>方法来构造请求</li></ol></li><li>使用RestTemplate发送http请求只需要注意以下四点<ol><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ol></li></ol></li><li><p>具体是实现</p><ol><li><p>首先需要设置RestTemplate的配置类，将RestTemplate作为一个Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改<code>cart-service</code>中查询商品的方法</p><ol><li>其中的暂时<code>itemDto</code>从<code>item-service</code>复制到<code>cart-service</code>中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.查询商品</span></span><br><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; responseEntity = restTemplate.exchange(</span><br><span class="line">        <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">        HttpMethod.GET,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">);</span><br><span class="line"><span class="comment">//解析响应</span></span><br><span class="line"><span class="keyword">if</span> (!responseEntity.getStatusCode().is2xxSuccessful()) &#123;</span><br><span class="line">    <span class="comment">//查询失败</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;ItemDTO&gt; items = responseEntity.getBody();</span><br></pre></td></tr></table></figure></li></ol></li><li><p>重启两个服务，通过接口文档调用”查询购物车列表“接口，购物车信息应该完整</p></li><li><p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者</p></li><li><p>通过RestTemplate手动实现接口调用的方式仍然存在问题</p></li></ul><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><ul><li>服务调用时存在的问题<ol><li>item-service这么多实例，cart-service如何知道每一个实例的地址？</li><li>http请求要写url地址，<code>cart-service</code>服务到底该调用哪个实例呢？</li><li>如果在运行过程中，某一个<code>item-service</code>实例宕机，<code>cart-service</code>依然在调用该怎么办？</li><li>如果并发太高，<code>item-service</code>临时多部署了N台实例，<code>cart-service</code>如何知道新实例的地址？</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/16/1lrZPSVAy4bd8kN.png" alt="img"></li></ol></li><li>为了解决上述问题，就必须引入注册中心的概念</li></ul><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><ol><li>在微服务远程调用的过程中，包括两个角色<ul><li>服务提供者：提供接口供其它微服务访问，比如<code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如<code>cart-service</code></li></ul></li><li>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/16/6GnOrhqJyIW51QN.jpg" alt="img"></li></ol></li><li>流程如下<ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡（随机、轮询算法），挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul></li><li>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？<ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求检测）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表（推送变更）</li></ul></li><li>注册中心，解决了服务调用时存在的问题，但其实现较为复杂，不过有许多开源框架可以使用</li></ol><h3 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h3><ul><li><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li><strong>Eureka</strong>：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li><strong>Nacos</strong>：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用<ul><li>官网<code>https://nacos.io/zh-cn/</code></li></ul></li><li><strong>Consul</strong>：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul></li><li><p><strong>基于Docker来部署Nacos的注册中心</strong></p><ol><li><p>准备MySQL数据库表，用来存储Nacos的数据</p></li><li><p>由于是Docker部署，将资料中的SQL文件导入到<strong>Docker中的MySQL容器</strong></p></li><li><p>修改黑马资料中<code>nacos/custom.env</code>文件，有一个MYSQL_SERVICE_HOST也就是mysql地址，需要修改为自己的虚拟机IP地址</p></li><li><p>将资料中的<code>nacos</code>和<code>nacos.tar</code>目录上传至虚拟机的<code>/root</code>目录</p></li><li><p>docker拉取镜像&amp;创建容器</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加载image</span></span><br><span class="line">docker load <span class="literal">-i</span> nacos.tar</span><br><span class="line"><span class="comment">#创建容器</span></span><br><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line"><span class="literal">--name</span> nacos \</span><br><span class="line"><span class="literal">--env-file</span> ./nacos/custom.env \</span><br><span class="line"><span class="literal">-p</span> <span class="number">8848</span>:<span class="number">8848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9848</span>:<span class="number">9848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9849</span>:<span class="number">9849</span> \</span><br><span class="line"><span class="literal">--restart</span>=always \</span><br><span class="line">nacos/nacos<span class="literal">-server</span>:v2.<span class="number">1.0</span><span class="literal">-slim</span></span><br></pre></td></tr></table></figure></li><li><p>启动完成后，访问下面地址：http:&#x2F;&#x2F;虚拟机IP地址:8848&#x2F;nacos</p></li><li><p>首次访问会跳转到登录页，<strong>账号密码都是nacos</strong></p></li></ol></li></ul><h3 id="基于Nacos实现服务注册"><a href="#基于Nacos实现服务注册" class="headerlink" title="基于Nacos实现服务注册"></a>基于Nacos实现服务注册</h3><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">  <span class="comment">#服务名</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="comment">#服务地址</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure></li><li><p>启动多个服务，查看nacos即可</p></li></ul><h3 id="基于Nacos实现服务发现"><a href="#基于Nacos实现服务发现" class="headerlink" title="基于Nacos实现服务发现"></a>基于Nacos实现服务发现</h3><ul><li><p>引入依赖、配置信息与前文一致（服务调用者也可以是服务提供者）</p></li><li><p>接下来，服务调用者<code>cart-service</code>订阅<code>item-service</code>服务了</p><ul><li><p><code>item-service</code>有多个实例，而真正发起调用时只需要知道一个实例的地址；因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问‘；常见的负载均衡算法有</p><ul><li><p>随机</p></li><li><p>轮询</p></li><li><p>IP的hash</p></li><li><p>最近最少访问</p></li></ul></li></ul></li><li><p>这里基于随机算法实现负载均衡</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取discoveryClient对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryClient;</span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="comment">//通过注册中心获取商品实例</span></span><br><span class="line">List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;item-service&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (instances == <span class="literal">null</span> || instances.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));</span><br><span class="line"><span class="comment">//实例的ip和端口</span></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> serviceInstance.getUri();</span><br><span class="line"><span class="comment">// 2.查询商品</span></span><br><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; responseEntity = restTemplate.exchange(</span><br><span class="line">        uri + <span class="string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">        HttpMethod.GET,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>通过swagger文档测试，实现远程调用，如商品实例控制台分别输出（先全部清空）</li></ul><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>利用Nacos实现了服务的治理，利用RestTemplate实现了服务的远程调用，但是远程调用的代码太复杂了</li><li>远程调用的关键点就在于四个参数<ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul></li><li><strong>OpenFeign</strong>利用SpringMVC的相关注解来声明以上4个参数，然后基于动态代理帮我们生成远程调用的代码，替换掉RestTemplate</li><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器 旧版中`ribbon`是一种负载均衡器，但一般都是用nginx这种网关来做反向代理和负载均衡--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在<code>cart-service</code>启动类上添加注解<code>@EnableFeignClients</code>，启动OpenFeign功能</li><li>编写Feign客户端</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>客户端详情</p><ul><li>声明接口，无需实现方法；接口中的几个关键信息<ul><li><code>@FeignClient(&quot;item-service&quot;)</code> ：声明服务的名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping(&quot;/items&quot;)</code> ：声明请求路径</li><li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul></li><li>有了上述信息，OpenFeign就可以利用动态代理实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code></li></ul></li><li><p>获取商品信息代码就可简化为</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取itemClient实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ItemClient itemClient;</span><br><span class="line"><span class="comment">//直接调用接口即可</span></span><br><span class="line">List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br></pre></td></tr></table></figure><ul><li>通过Swagger文档调式</li></ul><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><ul><li><p>原理，观看hm视频</p><ul><li>OpenFeign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：<ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池（苍穹外卖实现过）</li><li>OKHttp：支持连接池</li></ul></li><li>通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，使用OK Http</li></ul></li><li><p>使用OKHttp连接池</p><ul><li>引依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在<code>cart-service</code>的<code>application.yml</code>配置文件中开启Feign的连接池功能</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure></li><li><p>验证，在<code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code>中的<code>execute</code>方法中打断点，查看<code>delegate</code></p></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>面对的问题<ul><li>当更多其它的服务需要<code>item-service</code>越来越多时，按照前文的实现，就会创建重复的代码<code>ItemClent</code></li><li>以及<code>ItemDto</code>也会重复导入其他服务的dto包中</li></ul></li><li>解决方案<ul><li>避免重复编码的办法就是<strong>抽取</strong>。不过这里有两种抽取思路：<ul><li>思路1：抽取到微服务之外的公共module</li><li>思路2：每个微服务自己抽取一个module</li></ul></li><li>如图<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/17/KyqLjRZO8AeCrdo.jpg" alt="imag"></li></ul></li><li>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低</li></ul></li><li>这里使用方案1<ol><li>定义公共module：<code>hm-api</code></li><li>引入公共依赖</li><li>定义<code>client和dto</code>包结构以及导入相关包</li><li>解决<code>private final ItemClient itemClient;</code>无法找到bean报错<ul><li>因为<code>ItemClient</code>现在定义到了<code>com.hmall.api.client</code>包下，而<code>cart-service</code>的启动类定义在<code>com.hmall.cart</code>包下，扫描不到<code>ItemClient</code>，所以报错</li><li>解决：在<code>cart-service</code>的启动类上添加声明即可<ol><li>声明扫描包<code>@EnableFeignClients(basePackages = &quot;com.hmall.api.clients&quot;)</code>（范围广）</li><li>声明要用的FeignClient <code>@EnableFeignClients(clients = &#123;ItemClient.class&#125;)</code>(更具体)</li></ol></li></ul></li></ol></li><li>通过swagger文档查询测试</li></ul><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><ul><li><p>OpenFeign只会在FeignClient所在包的日志级别为<strong>DEBUG</strong>时，才会输出日志。而且其日志级别有4级：</p><ul><li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li><li><strong>BASIC</strong>：仅记录请求的方法，URL以及响应状态码和执行时间</li><li><strong>HEADERS</strong>：在BASIC的基础上，额外记录了请求和响应的头信息</li><li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据</li></ul></li><li><p>Feign默认的日志级别就是NONE，所以默认我们看不到请求日志</p></li><li><p>实现</p><ol><li><p>定义一个配置类，在<code>hm-api</code>中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生效</p><ol><li>局部生效：<code>@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class)</code></li><li>全局生效：<code>@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)</code></li></ol></li></ol></li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>将hm-service中的其它业务也都拆分为微服务，并基于OpenFeign完善功能</p><ul><li>user-service：用户微服务，包含用户登录、管理等功能</li><li>trade-service：交易微服务，包含订单相关功能</li><li>pay-service：支付微服务，包含支付相关功能</li></ul><p>其中交易服务、支付服务、用户服务中的业务都需要知道当前登录用户是谁，暂时写死</p><h3 id="用户微服务"><a href="#用户微服务" class="headerlink" title="用户微服务"></a>用户微服务</h3><p>用户微服务需要将<code>hm-service</code>中的config包下的<code>JwtProperties、SecurityConfig </code>类导入到<code>user-service</code>模块下</p><ul><li>JwtProperties是JsonWebToken的属性配置</li><li>SecurityConfig读取JwtProperties的信息，以及创建一个PasswordEncoder的bean用于”密码的判断”</li></ul><p>将<code>hm-service</code>中的utils包下的<code>JwtTool</code>类导入到<code>user-service</code>模块下</p><ul><li>JwtTool类主要是创建token和解析token</li></ul><p>由于拦截器和拦截器的配置没有导入，所以这个token也等同于没有，对登录&#x2F;扣款代码中的<code>UserContext.getUser()</code>统一写为<code>1L</code>。</p><p>通过swagger接口文档进行调试</p><h3 id="交易微服务"><a href="#交易微服务" class="headerlink" title="交易微服务"></a>交易微服务</h3><p>从<code>controller</code>包发现，一共有三个接口</p><ol><li><code>@ApiOperation(&quot;根据id查询订单&quot;)</code></li><li><code>@ApiOperation(&quot;创建订单&quot;)</code></li><li><code>@ApiOperation(&quot;标记订单已支付&quot;)</code></li></ol><p>只有创建订单<code>createOrder()</code>是需要进行远程调用</p><ul><li><code>private final ItemClient itemClient;</code>查询和修改商品信息</li><li><code>private final CartClient cartClient;</code>清空购物车的缓存</li></ul><p>配置信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span></span><br><span class="line"><span class="comment"># okhttp连接池</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在<code>hm-api</code>中</p><ul><li><p><code>ItemCliemt</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; items)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>CartClient</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;cart-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CartClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/carts&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteCartItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>启动类注解以及配置信息</p><ul><li><code>@EnableFeignClients(clients = &#123;ItemClient.class, CartClient.class&#125;,defaultConfiguration = DefaultFeignConfig.class)</code></li></ul><p>完整的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">createOrder</span><span class="params">(OrderFormDTO orderFormDTO)</span> &#123;</span><br><span class="line">    <span class="comment">//订单数据</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    <span class="comment">//查询商品</span></span><br><span class="line">    List&lt;OrderDetailDTO&gt; detailDTOS = orderFormDTO.getDetails();</span><br><span class="line">    <span class="comment">//获取商品id和商品数量的Map</span></span><br><span class="line">    Map&lt;Long, Integer&gt; itemNumMap = detailDTOS.stream()</span><br><span class="line">            .collect(Collectors.toMap(OrderDetailDTO::getItemId, OrderDetailDTO::getNum));</span><br><span class="line">    <span class="comment">//所有的商品id</span></span><br><span class="line">    Set&lt;Long&gt; itemIds = itemNumMap.keySet();</span><br><span class="line">    <span class="comment">//查询商品client</span></span><br><span class="line">    List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br><span class="line">    <span class="keyword">if</span> (items == <span class="literal">null</span> || items.size() &lt; itemIds.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;商品不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于商品价格、购买数量计算商品总价：totalFee</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ItemDTO item : items) &#123;</span><br><span class="line">        total += item.getPrice() * itemNumMap.get(item.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    order.setTotalFee(total);</span><br><span class="line">    <span class="comment">//订单其它属性</span></span><br><span class="line">    order.setPaymentType(orderFormDTO.getPaymentType());</span><br><span class="line">    order.setUserId(<span class="number">1L</span>);<span class="comment">// TODO 下单用户</span></span><br><span class="line">    order.setStatus(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将Order写入数据库order表中</span></span><br><span class="line">    save(order);</span><br><span class="line">    <span class="comment">//保存订单详情</span></span><br><span class="line">    List&lt;OrderDetail&gt; details = buildDetails(order.getId(), items, itemNumMap);</span><br><span class="line">    detailService.saveBatch(details);</span><br><span class="line">    <span class="comment">//清理购物车商品client</span></span><br><span class="line">    cartClient.deleteCartItemByIds(itemIds);</span><br><span class="line">    <span class="comment">//扣减库存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        itemClient.deductStock(detailDTOS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Swagger调式“创建订单”接口是否完成了远程调用</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;addressId&quot;</span><span class="punctuation">:</span> <span class="number">59</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;itemId&quot;</span><span class="punctuation">:</span> <span class="number">317578</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;num&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;itemId&quot;</span><span class="punctuation">:</span> <span class="number">546872</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;num&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;paymentType&quot;</span><span class="punctuation">:</span> <span class="number">3</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="支付微服务"><a href="#支付微服务" class="headerlink" title="支付微服务"></a>支付微服务</h3><p>从<code>PayController</code>发现两个接口</p><ul><li><code>@ApiOperation(&quot;生成支付单&quot;)</code></li><li><code>@ApiOperation(&quot;尝试基于用户余额支付&quot;)</code></li></ul><p>在生成支付单的接口中，仅仅需要修改实现类中的<code>buildPayOrder(PayApplyDTO payApplyDTO)</code>方法</p><ul><li>该接口用来生成支付订单</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PayOrder <span class="title function_">buildPayOrder</span><span class="params">(PayApplyDTO payApplyDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.数据转换</span></span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> BeanUtils.toBean(payApplyDTO, PayOrder.class);</span><br><span class="line">    <span class="comment">// 2.初始化数据</span></span><br><span class="line">    payOrder.setPayOverTime(LocalDateTime.now().plusMinutes(<span class="number">120L</span>));</span><br><span class="line">    payOrder.setStatus(PayStatus.WAIT_BUYER_PAY.getValue());</span><br><span class="line">    payOrder.setBizUserId(<span class="number">1L</span>); <span class="comment">//TODO UserContext.getUser()</span></span><br><span class="line">    <span class="keyword">return</span> payOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“尝试基于用户余额支付”接口中，需要对用户和订单服务进行远程调用</p><ul><li>导入相关依赖在<code>pay-service</code></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--公共api--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>nacos属性配置</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span></span><br><span class="line"><span class="comment"># okhttp连接池</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>用户和订单的远程调用接口</p><ul><li><p>余额支付</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;user-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/users/money/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductMoney</span><span class="params">(<span class="meta">@RequestParam(&quot;pw&quot;)</span> String pw,<span class="meta">@RequestParam(&quot;amount&quot;)</span> Integer amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改订单状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;trade-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/orders/&#123;orderId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>开启OpenFeign注解</p><ul><li><code>@EnableFeignClients(basePackages = &quot;com.hmall.api.clients&quot;,defaultConfiguration = DefaultFeignConfig.class)</code></li></ul><p>具体代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OrderClient orderClient;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPayOrderByBalance</span><span class="params">(PayOrderFormDTO payOrderFormDTO)</span> &#123;</span><br><span class="line">    <span class="comment">//查询支付单</span></span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">po</span> <span class="operator">=</span> getById(payOrderFormDTO.getId());</span><br><span class="line">    <span class="comment">//判断状态</span></span><br><span class="line">    <span class="keyword">if</span> (!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus())) &#123;</span><br><span class="line">        <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试扣减余额client</span></span><br><span class="line">    userClient.deductMoney(payOrderFormDTO.getPw(), po.getAmount());</span><br><span class="line">    <span class="comment">//修改支付单状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> markPayOrderSuccess(payOrderFormDTO.getId(), LocalDateTime.now()</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记订单已支付client</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">bizOrderNo</span> <span class="operator">=</span> po.getBizOrderNo();</span><br><span class="line">    orderClient.updateById(bizOrderNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Swagger测试，验证远程调用是否成功</p><ul><li>先修改<code>pay-order</code>表中<code>status</code>字段为1（未支付）</li><li>支付单id是表中的id字段</li><li>支付订单id是表中的pay_order_no字段，密码为123</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>如何才能在每个微服务中都拿到用户信息？如何在微服务之间传递用户信息？</p><ul><li>初步想法<ul><li>把拦截器也重新拆分为一个微服务，这样<code>UserContext</code>类就可以获取token中的用户id，从而得到用户信息</li><li>不同服务的线程是否一致呢？确保<code>UserContext</code>在各个服务是如果可以互相联系线程的话，获取到的用户id也就一致</li></ul></li></ul><h3 id="前后联调"><a href="#前后联调" class="headerlink" title="前后联调"></a>前后联调</h3><p>黑马资料提供了一个<code>hmall-nginx</code>目录，其中包含了Nginx以及我们的前端代码</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/kglCi7uMhwqByAp.png" alt="img"></p><p>将其拷贝到一个不包含中文、空格、特殊字符的目录，启动后即可访问到页面</p><ul><li>18080端口是用户端页面</li><li>18081端口是管理端页面，黑马好像没有写完全这个管理端，访问18081端口报错</li></ul><p>之前<code>nginx</code>内部会将发向服务端请求全部代理到8080端口，但是现在拆分了N个微服务，8080不可用了。通过<code>Nginx</code>配置，完成对不同微服务的反向代理</p><ul><li>每一个服务都对应一个端口号，每个请求又对应着不同的服务，也就是不同请求的所访问的服务端口都不一致</li><li>确保每一个请求对应的服务一致，不再是之前统一的8080端口</li></ul><p>如何解决上述问题呢？需要用到微服务当中网关的知识了</p><h2 id="网关及配置管理"><a href="#网关及配置管理" class="headerlink" title="网关及配置管理"></a>网关及配置管理</h2><p>前景提要，碰到的问题</p><ul><li>由于每个微服务都有不同的地址或端口，入口不同，在与前端联调的时候出现一些问题<ul><li>请求不同数据时要访问不同的入口，需要维护多个入口地址，麻烦</li><li>前端无法调用nacos，无法实时更新服务列表</li></ul></li><li>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题<ul><li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li><li>当微服务之间调用时，该如何传递用户信息？</li></ul></li></ul><p>这些问题会通过<strong>网关</strong>技术解决</p><h3 id="何为网关？"><a href="#何为网关？" class="headerlink" title="何为网关？"></a>何为网关？</h3><p>顾明思议，网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一端网络传输到另一端网络时就需要经过网关来做数据的<strong>路由</strong>和<strong>转发</strong>以及数据安全的<strong>校验</strong></p><p>举个例子</p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/nt7jobRyFH1NJEM.jpg" alt="img"></p></li><li><p>网关就像是以前园区传达室的大爷</p><ul><li>路由就像是大爷到你寻找之地的路线</li><li>校验，就是大爷对你身份的怀疑和盘问</li></ul></li><li><p>外面的人要想进入园区，必须经过大爷的认可，如果你是不怀好意的人，肯定被直接拦截（身份验证）</p></li><li><p>外面的人要传话或送信，要找大爷，大爷帮你带给目标人（路由和转发）</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/pGM2RItxH954PCj.jpg" alt="imag"></p></li><li><p>现在，微服务网关就起到同样的作用。前端请求不能直接访问微服务，而是要先请求网关</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li><li>网关可以从Nacos注册中心中获取到服务列表以及具体服务的多个实例信息</li></ul></li></ul><p>在Spring Cloud中网关的实现包括两种：</p><ul><li><strong>Spring cloud Gateway</strong>：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li><li><strong>Netfilx Zuul</strong>：基于Servlet的阻塞式编程，需要调优才能获得与Spring cloud Gateway类似的性能</li></ul><h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li><p>创建网关微服务</p></li><li><p>引入SpringCloudGateway、NacosDiscovery依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置网关路由规则</strong></p><ul><li>在<code>hm-gateway</code>模块的<code>resources</code>目录新建一个<code>application.yaml</code>文件，内容如下：</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br></pre></td></tr></table></figure><ul><li>这样，当前端请求时，网关就会根据路由断言判断时哪一个微服务实例，然后再通过负载均衡调用从nacos获取到的实例</li></ul></li></ul><h4 id="路由属性"><a href="#路由属性" class="headerlink" title="路由属性"></a>路由属性</h4><p>yaml文件中每一个属性都有一个Java类，路由routes对应的Java类是<code>GatewayProperties</code></p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/8gPEKupAa6XOli7.png" alt="image"></p></li><li><p>是一个集合，也就是说可以定义很多路由规则。集合中的<code>RouteDefinition</code>就是具体的路由规则定义，其中常见的属性如下：</p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/gVHZ4DQOKMxkeat.png" alt="img"></p></li><li><p>四个属性含义如下：</p><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件</li><li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问</li></ul></li><li><p>这里我们重点关注<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p></li><li><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host(域名)</td><td align="left">- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method&#x3D;GET,POST</td></tr><tr><td align="left"><strong>Path</strong></td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query&#x3D;name, Jack或者- Query&#x3D;name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td align="left">weight</td><td align="left">权重处理</td><td align="left">Weight&#x3D;group1,2</td></tr><tr><td align="left">XForwardedRemoteAddr</td><td align="left">基于请求的来源IP做判断</td><td align="left">-XForwardedRemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr></tbody></table></li></ul></li><li><p><a href="https://spring.io/projects/spring-cloud-gateway/">官网示例</a></p></li></ul><p>路由过滤器，和拦截器功能有些相似，拦截请求和响应信息，可以做修改</p><p>网关中提供了33种路由过滤器，这里列举几种常见的路由</p><table><thead><tr><th>名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td><td>AddrequestHeader&#x3D;headerName,headerValue</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td><td>RemoveRequestHeader&#x3D;headerName</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td><td>AddResponseHeader&#x3D;headerName,headerVaLue</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td><td>RemoveResponseHeader&#x3D;headerName</td></tr><tr><td>RewritePath</td><td>请求路径重写</td><td>RewritePath&#x3D;&#x2F;red&#x2F;?(?<segment>.*),&#x2F;$\ {segment}</td></tr><tr><td>StripPrefix</td><td>去除请求路径中的N段前缀</td><td>StripPrefix&#x3D;1，则路径&#x2F;a&#x2F;b转发时只保留&#x2F;b</td></tr></tbody></table><p>局部配置路由过滤器</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=truth,never</span> <span class="string">give</span> <span class="string">up</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br></pre></td></tr></table></figure><p>全局配置路由过滤器</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=truth,never</span> <span class="string">give</span> <span class="string">up</span></span><br></pre></td></tr></table></figure><h3 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h3><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取</p><p><em><strong>鉴权思路分析</strong></em></p><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题</p><ul><li>每个微服务都需要知道JWT的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前所有的问题就解决了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/sxTuLYoZqbEOvHD.png" alt="image"></p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li></ul><p>不过，这里存在几个问题：</p><ul><li>网关路由是配置的，请求转发是Gateway内部代码，我们如何在转发之前做登录校验？</li><li>网关校验JWT之后，如何将用户信息传递给微服务？<ul><li>可以通过请求头拦截器添加用户id</li></ul></li><li>微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</li></ul><h4 id="内部的工作原理"><a href="#内部的工作原理" class="headerlink" title="内部的工作原理"></a>内部的工作原理</h4><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/cYQuBKo1yHa4vRW.png" alt="image"></p><p>如图所示</p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）</li><li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被转发到微服务</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑</li><li>最终把响应结果返回</li></ol><p>最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最后的一个，<strong>如果我们能够自定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到</strong><code>NettyRoutingFilter</code>之前，这就可以解决转发之前如何做登录校验的问题了</p><h4 id="自定义网关过滤器"><a href="#自定义网关过滤器" class="headerlink" title="自定义网关过滤器"></a>自定义网关过滤器</h4><p>网关过滤器链中的过滤器有两种</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code></li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由</li><li>注意过滤器链之外还有一种过滤器，<strong>HttpHeadersFilter</strong>，用来处理传递到下游微服务的请求头<ul><li>例如<code>org.springframework.cloud.gateway.filter.headers.XForwardedHeadersFilter</code>可以传递代理请求原本的host头到下游微服务</li></ul></li></ul><p>其实<code>GatewayFilter</code>和<code>GlobalFilter</code>这两种过滤器的方法签名完全一致</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理请求并将其传递给下一个过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exchange 当前请求的上下文，其中包含整个过滤器链内共享数据,如request、response等各种数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chain 过滤器链，基于它向下传递请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br></pre></td></tr></table></figure><p><code>FilteringWebHandler</code>在处理请求时，会将<code>GlobalFilter</code>装饰为<code>GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行</p><p>自定义GlobalFilter，在<code>hm-gateway</code>中新建一个<code>filters</code>包，实现一个全局过滤器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 登录校验</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">        System.out.println(<span class="string">&quot;headers =&quot;</span> + headers);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录校验的过滤器应该放在请求转发到微服务<code>NettyRoutingFilter</code>过滤器前，如何实现呢？</p><ul><li>查看<code>GlobalFilter</code>的实现可知<code>NettyRoutingFilter</code>过滤器能够在最后执行的原因是实现了<code>Ordered</code>接口，且排序字段<strong>ORDER</strong>为int最大值<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/t36LwvP5hzFRriT.png" alt="image"></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/beCm7MkDWS2KFPX.png" alt="img"></li><li><code>ORDER</code>值越小，优先级越高，排序越靠前</li></ul></li><li>所以只要实现<code>Ordered</code>接口，<code>ORDER</code>字段值小于<code>Integer.MAX_VALUE</code>即可</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>,Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 登录校验</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">        System.out.println(<span class="string">&quot;headers =&quot;</span> + headers);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>MyGlobalFilter</code>和<code>NettyRoutingFilter</code>的filter方法分别做断点调试</p><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code>，最简单的方式是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求</span></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;过滤器执行了&quot;</span>);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀！（方便后续配置）然后在yaml配置后才会生效</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><ul><li>既可以配置全局路由，也可以配置局部路由</li></ul><p>另外，这种过滤器还可以支持动态配置参数，示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="comment">// 父类泛型是内部类的Config类型</span></span><br><span class="line">                <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;PrintAnyGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span></span><br><span class="line">        <span class="comment">// - GatewayFilter：过滤器</span></span><br><span class="line">        <span class="comment">// - int order值：值越小，过滤器执行优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取config值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> config.getA();</span><br><span class="line">                <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> config.getB();</span><br><span class="line">                <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> config.getC();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">                System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置属性，成员变量名称很重要，下面会用到</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将变量名称依次返回，顺序很重要，将来读取参数时按该顺序获取</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回当前配置类的类型，也就是内部的Config</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;Config&gt; <span class="title function_">getConfigClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Config.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在yaml文件中使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny=1,2,3</span> <span class="comment"># 注意，这里多个参数以&quot;,&quot;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></span><br></pre></td></tr></table></figure><p>上面这种配置方式参数必须严格按照<code>shortcutFieldOrder()</code>方法的返回参数名顺序来赋值</p><p>还有一种用法，无需按照这个顺序，就是手动指定参数名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PrintAny</span></span><br><span class="line">              <span class="attr">args:</span> <span class="comment"># 手动指定参数名，无需按照参数顺序</span></span><br><span class="line">                <span class="attr">a:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">b:</span> <span class="number">2</span></span><br><span class="line">                <span class="attr">c:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这种过滤器的使用较少，一般都是定义全局过滤器</p><h4 id="自定义GlobalFilter实现登录校验"><a href="#自定义GlobalFilter实现登录校验" class="headerlink" title="自定义GlobalFilter实现登录校验"></a>自定义<code>GlobalFilter</code>实现登录校验</h4><p>登录校验需要JWT相关配置</p><ul><li>从<code>hm-service</code>服务config包下导出与登录校验有关的配置：<code>AuthProperties</code>、<code>JwtProperties</code>、<code>SecurityConfig</code></li><li>从<code>hm-service</code>服务utils包下导出<code>JwtUtil</code>工具类</li><li>从<code>hm-service</code>服务中的reasource文件中获取密钥<code>hmall.jks</code></li><li>从<code>hm-service</code>服务的yaml文件中复制对应的属性配置</li></ul><p>实现登录拦截过滤器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>,Ordered &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthProperties authProperties;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtTool jwtTool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//判断该请求是否需要拦截</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">RequestPath</span> <span class="variable">requestPath</span> <span class="operator">=</span> request.getPath();</span><br><span class="line">        <span class="keyword">if</span> (isExcludePath(requestPath.toString())) &#123;</span><br><span class="line">            <span class="comment">//不需要拦截</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">        List&lt;String&gt; requestHeader = headers.get(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//解析得到token</span></span><br><span class="line">        Long userId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = jwtTool.parseToken(requestHeader.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//拦截,设置401状态码</span></span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//传递用户信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;userId =&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isExcludePath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">//用于路径判断</span></span><br><span class="line">        List&lt;String&gt; excludePaths = authProperties.getExcludePaths();</span><br><span class="line">        <span class="keyword">for</span> (String excludePath : excludePaths) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPathMatcher.match(excludePath,path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需知</p><ul><li>响应状态码的设置API的调用</li><li>对于请求路径的判断API调用</li></ul><h4 id="网关传递用户到微服务"><a href="#网关传递用户到微服务" class="headerlink" title="网关传递用户到微服务"></a>网关传递用户到微服务</h4><p>通过设置请求头，把用户id传到微服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传递用户信息</span></span><br><span class="line"><span class="type">ServerWebExchange</span> <span class="variable">webExchange</span> <span class="operator">=</span> exchange.mutate() <span class="comment">//对下游请求做修改</span></span><br><span class="line">        .request(builder -&gt; builder.header(<span class="string">&quot;user-info&quot;</span>, userId.toString()))</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//放行</span></span><br><span class="line"><span class="keyword">return</span> chain.filter(webExchange);</span><br></pre></td></tr></table></figure><p>微服务获取该信息，可以在每个方法中都获取<code>user-info</code>这个请求头，不过太过麻烦，我们可以在微服务与网关转发之前，再加一个SpringMVC的拦截器，和以往一样，把该用户id保存在<code>ThreadLocal</code>中，如图所示</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/pFzPiCrJWKwI7as.png" alt="image"></p><p>由于每个微服务都有获取登录用户的需求，因此拦截器我们直接写在<code>hm-common</code>中，并写好自动装配。这样微服务只需要引入<code>hm-common</code>就可以直接具备拦截器功能，无需重复编写</p><p>用户信息拦截</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.校验token</span></span><br><span class="line">        <span class="keyword">if</span> (userId == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.存入上下文</span></span><br><span class="line">        UserContext.setUser(Long.valueOf(userId));</span><br><span class="line">        <span class="comment">// 4.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 清理用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>config配置，添加拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span><span class="comment">//表示仅对包含了springMvc的核心类生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.添加拦截器</span></span><br><span class="line">        <span class="type">UserInfoInterceptor</span> <span class="variable">userInfoInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>();</span><br><span class="line">        registry.addInterceptor(userInfoInterceptor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，需要注意的是，这个配置类默认是不会生效的，因为它所在的包是<code>com.hmall.common.config</code>，与其它微服务的扫描包不一致，无法被扫描到，因此无法生效</p><p>需要解决的2个问题：SpringBoot无法扫描到该配置、该拦截器仅仅只在SpringMVC中生效（hm-gatewary也引入了hm-common依赖）</p><ol><li><p>基于SpringBoot的自动装配原理，我们要将其添加到<code>resources</code>目录下的<code>META-INF/spring.factories</code>文件中</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">  com.hmall.common.config.MyBatisConfig,\</span></span><br><span class="line"><span class="string">  com.hmall.common.config.MvcConfig,\</span></span><br><span class="line"><span class="string">  com.hmall.common.config.JsonConfig</span></span><br></pre></td></tr></table></figure></li><li><p><code>@ConditionalOnClass</code>注解是Spring Boot中的一个条件注解，它可以用来指定在类路径中存在特定的类时才加载某个配置类或Bean</p><ul><li>在这里hm-gateway不是基于springMvc的，所以该MvcConfig不应该生效，否则该拦截器会有错误</li></ul></li></ol><p>修改其他微服务中用1L替换的<code>UserContext.getUser()</code>，通过Swagger进行调试</p><h4 id="微服务获取用户"><a href="#微服务获取用户" class="headerlink" title="微服务获取用户"></a>微服务获取用户</h4><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，流程如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/NKjDf8HL5vG7l4E.jpg" alt="image"></p><ul><li>下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户ID。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，而且微服务则是通过OpenFeign发送http请求到购物车服务，所以也不会有<code>user-info</code>的请求头信息！！！</li><li>所以，在购物车服务中的购物车清理过程中因为没有用户ID而失败</li><li>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong></li></ul><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p><ul><li><p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called for every request. </span></span><br><span class="line"><span class="comment">   * Add data using methods on the supplied &#123;<span class="doctag">@link</span> RequestTemplate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>openfeign每次发起远程调用前,都会被<code>RequestInterceptor</code>拦截，底层都会自动调用apply方法！！！</p></li><li><p>我们只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息</p></li><li><p>由于<code>FeignClient</code>全部都是在<code>hm-api</code>模块，因此我们在<code>hm-api</code>模块的<code>com.hmall.api.config.DefaultFeignConfig</code>中编写这个拦截器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">requestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate requestTemplate)</span> &#123;</span><br><span class="line">            <span class="comment">//引入hm-common依赖</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userInfo</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">            <span class="keyword">if</span> (userInfo != <span class="literal">null</span> )&#123;</span><br><span class="line">                requestTemplate.header(<span class="string">&quot;user-info&quot;</span>,userInfo.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样每次远程调用时，都会先拦截，添加<code>user-info</code>请求头</p></li></ul><h4 id="章节小结，一图概括"><a href="#章节小结，一图概括" class="headerlink" title="章节小结，一图概括"></a>章节小结，一图概括</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/A4cgCz8jTZwmJua.png" alt="image"></p><p>很多功能的实现依赖于拦截器的配置。</p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>看一看微服务中关于配置的问题：</p><ul><li>网关路由在配置文件中写死了，如果变更必须<strong>重启</strong>微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要<strong>重启</strong>服务</li><li>每个微服务都有很多重复的配置（接口文档、数据库、日志等），维护成本高</li></ul><p>每一次的重启都意味着，当时程序无法运行，着不仅对用户体验不好也增加了运维的工作量。不过也有着解决的方法，这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/dXhbDrm8EngGR7U.jpg" alt="img"></p><ul><li>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置<strong>热更新</strong></li><li>网关的路由同样是配置，因此同样可以基于这个功能实现<strong>动态路由</strong>功能，无需重启网关即可修改路由配置</li></ul><h3 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h3><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在Nacos中添加共享配置</li><li>微服务拉取配置</li></ul><p>这里先进行可以共享的nacos配置，在nacos配置管理下的配置列表栏中新建配置</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/nzZAbUMslgJCFKN.png" alt="image"></p><ul><li>jdbc共享配置</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;&#123;hm.db.host:192.168.80.132&#125;:$&#123;hm.db.port:3306&#125;/$&#123;hm.db.database&#125;?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">$&#123;hm.db.username&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><ul><li>注意这里的jdbc的相关参数并没有写死，例如：<ul><li><code>数据库ip</code>：通过<code>$&#123;hm.db.host:192.168.80.132&#125;</code>配置了默认值为<code>192.168.80.132</code>，同时允许通过<code>$&#123;hm.db.host&#125;</code>来覆盖默认值</li><li><code>数据库端口</code>：通过<code>$&#123;hm.db.port:3306&#125;</code>配置了默认值为<code>3306</code>，同时允许通过<code>$&#123;hm.db.port&#125;</code>来覆盖默认值</li><li><code>数据库database</code>：可以通过<code>$&#123;hm.db.database&#125;</code>来设定，无默认值</li></ul></li><li>log共享配置</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>swagger共享配置</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">$&#123;hm.swagger.title:黑马商城接口文档&#125;</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">$&#123;hm.swagger.desc:&quot;黑马商城接口文档&quot;&#125;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">$&#123;hm.swagger.package&#125;</span></span><br></pre></td></tr></table></figure><ul><li>我们只需要在<code>application.yaml</code>中完善各自项目的配置信息即可</li></ul><p>将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化Spring Boot上下文，去读取<code>application.yaml</code>。也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos地址，该如何去加载nacos中的配置文件呢？</p><ul><li><p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的引导文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/yiUHbdR39FwZ2Np.jpg" alt="image"></p></li></ul><p>因此，微服务整合Nacos配置管理的步骤如下</p><ol><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>新建bootstrap.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure></li><li><p>修改application.yam</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp连接池支持</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">swagger:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">购物车服务接口文档</span></span><br><span class="line">    <span class="attr">package:</span> <span class="string">com.hmall.cart.controller</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">hm-cart</span></span><br></pre></td></tr></table></figure></li></ol><p>调试，验证购物车接口的功能</p><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>配置热更新：当修改配置文件中的配置时，微服务无需重启即可使配置生效</p><p>前提条件：</p><ul><li>nacos的配置文件<ul><li>**<code>spring.active.profile</code>**：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/u3qIc2UtgBrf8DH.png" alt="image"></p><ul><li>微服务中要以特定方式读取需要热更新的配置属性，两种方式，注解不同</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/jnQkBSRhzd3XfVv.png" alt="img"></p><p>通过修改<code>cat-service</code>中添加商品到购物车代码功能，引入<code>CartProperties</code>bean，修改<code>checkCartsFull()</code>方法如下，调试热更新</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkCartsFull</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> lambdaQuery().eq(Cart::getUserId, userId).count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= cartProperties.getMaxItems()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(StrUtil.format(<span class="string">&quot;用户购物车课程不能超过&#123;&#125;&quot;</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够实现热更新，依赖于当nacos的配置服务修改时，会推送最新的配置信息到微服务</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的<strong>路由表</strong>内（一个Map），不会改变。当我们的路由需要做出修改时，就需要重启网关微服务，这样的话其他微服务全部失效了，于是我们需要像配置热更新一样，让路由也实现热更新</p><p>所以，我们必须<strong>监听Nacos的配置变更</strong>，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听Nacos配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><p>在Nacos官网中给出了手动监听Nacos配置变更的SDK：<code>https://nacos.io/zh-cn/docs/sdk.html</code></p><p>如果希望 Nacos 推送配置变更实现监听效果，可以使用 Nacos 动态监听配置接口来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(String dataId, String group, Listener listener)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>请求参数说明</p><table><thead><tr><th align="left"><strong>参数名</strong></th><th align="left"><strong>参数类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">dataId</td><td align="left">string</td><td align="left">配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（”.”、”:”、”-“、”_”）。不超过 256 字节</td></tr><tr><td align="left">group</td><td align="left">string</td><td align="left">配置分组，一般是默认的DEFAULT_GROUP</td></tr><tr><td align="left">listener</td><td align="left">Listener</td><td align="left">监听器，配置变更进入监听器的回调函数</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;&#123;serverAddr&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;&#123;dataId&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;&#123;group&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// 1.创建ConfigService，连接Nacos</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;serverAddr&quot;</span>, serverAddr);</span><br><span class="line"><span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> NacosFactory.createConfigService(properties);</span><br><span class="line"><span class="comment">// 2.读取配置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> configService.getConfig(dataId, group, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 3.添加配置监听器</span></span><br><span class="line">configService.addListener(dataId, group, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置变更的通知处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;recieve1:&quot;</span> + configInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//获取线程池</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>这里核心的步骤有2步：</p><ol><li>创建ConfigService，目的是连接到Nacos</li><li>添加配置监听器，编写配置变更的通知处理逻辑</li></ol><p>由于我们采用了<code>spring-cloud-starter-alibaba-nacos-config</code>自动装配，因此<code>ConfigService</code>已经在<code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code>中自动创建好了：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/758zUjnuNesRDcW.png" alt="image"></p><p>NacosConfigManager中是负责管理Nacos的ConfigService的，具体代码如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/HTzaMxrhWItuZdD.png" alt="image"></p><p>因此，只要我们拿到<code>NacosConfigManager</code>就等于拿到了<code>ConfigService</code>，第一步就实现了</p><p>第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getConfigAndSignListener</span><span class="params">(</span></span><br><span class="line"><span class="params">    String dataId, // 配置文件id</span></span><br><span class="line"><span class="params">    String group, // 配置组，走默认</span></span><br><span class="line"><span class="params">    <span class="type">long</span> timeoutMs, // 读取配置的超时时间</span></span><br><span class="line"><span class="params">    Listener listener // 监听器</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> NacosException;</span><br></pre></td></tr></table></figure><p>既可以配置监听器，并且会根据dataId和group读取配置并返回。就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新</p><p><strong>更新路由：</strong></p><p>更新路由要用到<code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code>这个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.gateway.route;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouteDefinitionWriter</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;RouteDefinition&gt; route)</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据路由id删除某个路由</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Mono&lt;Void&gt; <span class="title function_">delete</span><span class="params">(Mono&lt;String&gt; routeId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新的路由，也就是<code>RouteDefinition</code>，包含下列常见字段：</p><ul><li>id：路由id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>我们保存到Nacos的配置也需要符合这个对象结构，如果我们像之前yaml格式配置的话，我们并不知道如何把yaml格式的数据映射到RouteDefinition，但在之前的外卖、redis项目中我们知道Json数据和对象映射，因此对路由的配置我们采用json格式，例如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以上配置等同于：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p><strong>动态路由的实现:</strong></p><ol><li><p>在网关微服务中引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载bootstrap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在网关的<code>resources</code>目录创建<code>bootstrap.yaml</code>文件，网关不需要jdbc和swagger配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure></li><li><p>修改<code>gateway</code>的<code>resources</code>目录下的<code>application.yml</code>，把之前的路由移除:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:hmall.jks</span> <span class="comment"># 秘钥地址</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">hmall</span> <span class="comment"># 秘钥别名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">hmall123</span> <span class="comment"># 秘钥文件密码</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span> <span class="comment"># 登录有效期</span></span><br><span class="line">  <span class="attr">auth:</span></span><br><span class="line">    <span class="attr">excludePaths:</span> <span class="comment"># 无需登录校验的路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/search/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/users/login</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/items/**</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>gateway</code>中定义配置监听器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRouteLoader</span> &#123; <span class="comment">//动态路由加载</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer; <span class="comment">//路由更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager; <span class="comment">//获取ConfigService，获取、监听配置</span></span><br><span class="line">    <span class="comment">// 路由配置文件的id和分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="comment">// 保存更新过的路由id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//当该类加载完成后，执行该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRouteConfigListener</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 1.注册监听器并首次拉取配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">                        <span class="comment">//更新路由配置</span></span><br><span class="line">                        updateConfigInfo(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 2.首次启动时，更新一次配置</span></span><br><span class="line">        updateConfigInfo(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;监听到路由配置变更，&#123;&#125;&quot;</span>, configInfo);</span><br><span class="line">        <span class="comment">// 1.反序列化</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo,                         RouteDefinition.class);</span><br><span class="line">        <span class="comment">// 2.更新前先清空旧路由</span></span><br><span class="line">        <span class="comment">// 2.1.清除旧路由</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            writer.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="comment">// 2.2.判断是否有新的路由要更新</span></span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(routeDefinitions)) &#123;</span><br><span class="line">            <span class="comment">// 无新路由配置，直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.更新路由</span></span><br><span class="line">        routeDefinitions.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3.1.更新路由</span></span><br><span class="line">            writer.save(Mono.just(routeDefinition)).subscribe();</span><br><span class="line">            <span class="comment">// 3.2.记录路由id，方便将来删除</span></span><br><span class="line">            routeIds.add(routeDefinition.getId());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>重启网关，任意访问一个接口，比如 <code>http://localhost:8080/search/list?pageNo=1&amp;pageSize=1</code>,请求404</p><p>我们在Nacos控制台添加路由，路由文件名为<code>gateway-routes.json</code>，类型为<code>json</code>，无需重启网关，再次访问，如果访问成功，那么配置动态路由成功</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/carts/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://cart-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/users/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/addresses/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://user-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trade&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/orders/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://trade-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pay&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/pay-orders/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://pay-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="服务保护"><a href="#服务保护" class="headerlink" title="服务保护"></a>服务保护</h2><h3 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h3><p>在微服务远程调用的过程中，还存在几个问题需要解决，一个是<strong>业务健壮性</strong>问题，另一个是服务雪崩问题 </p><p>业务健壮性问题：</p><ul><li>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服务时，是不是也会异常？从而导致购物车查询失败。</li><li>但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息</li></ul><p>雪崩问题产生的原因： </p><ul><li>微服务相互调用，服务提供者出现故障或阻塞</li><li>服务调用者没有做好异常处理，导致自身故障</li><li>调用链中的所有服务级联失败，导致整个集群故障<ul><li>服务与服务之间关联性部分错误，且没有应对措施，导致整个服务集群瘫痪（很多服务之间的远程调用非常多）</li></ul></li></ul><p>解决问题的思路：</p><ul><li>尽量避免服务出现故障或阻塞（服务提供者）<ul><li>保证代码的健壮性</li><li>保证网络的畅通</li><li>能应对较高的并发请求</li></ul></li><li>服务调用者做好远程调用异常的后备方案，避免故障扩散</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题，就属于微服务保护</p><p>服务保护方案</p><ul><li><strong>请求限流</strong>：限制访问微服务的请求的并发量，避免服务因流量激增出现故障<ul><li>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/UVZdzL2aBeP63NG.jpg" alt="限流图"></li><li>QPS（Queries Per Second）衡量的是服务器每秒能够响应的查询次数，‌也就是最大吞吐能力。‌这个指标对于评估系统的性能和容量规划非常重要，‌因为它直接关系到系统能够支持的用户数量和业务规模</li></ul></li><li><strong>线程隔离</strong>：也叫做舱壁模式，模拟船舱隔板的防水原理。通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散<ul><li>轮船的船舱会被隔板分割为N个相互隔离的密闭舱，假如轮船触礁进水，只有损坏的部分密闭舱会进水，而其他舱由于相互隔离，并不会进水。这样就把进水控制在部分船体，避免了整个船舱进水而沉没</li><li>为了避免某个接口故障或压力过大导致整个服务不可用，我们可以限定每个接口可以使用的资源范围，也就是将其“隔离”起来</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/yCu5imlG9fPzUD1.png" alt="线程隔离"></li><li>如图所示，我们给查询购物车业务限定可用线程数量上限为20，这样即便查询购物车的请求因为查询商品服务而出现故障，也不会导致服务器的线程资源被耗尽，不会影响到其它接口</li></ul></li><li><strong>服务熔断</strong>：由断路器统计请求的异常比例或慢调用比例，如果超出阈值则会熔断该业务，则拦截该接口的请求。熔断期间，所有请求快速失败，全都走fallback逻辑（也就是降级逻辑）<ul><li>线程隔离虽然避免了雪崩问题，但故障服务（商品服务）依然会拖慢购物车服务（服务调用方）的接口响应速度。而且商品查询的故障依然会导致查询购物车功能出现故障，从而购物车业务也变的不可用</li><li>所以，我们要做两件事情<ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑</li></ul></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/162UJkNGRPp3nrO.png" alt="服务熔断"></li></ul></li></ul><h3 id="服务保护技术"><a href="#服务保护技术" class="headerlink" title="服务保护技术"></a>服务保护技术</h3><p>微服务保护的技术有很多，目前国内使用较多的还是Sentinel以及Hystrix，我们主要学习Sentinel的使用</p><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件，目前已经加入到SpringCloudAlibaba中</p><ul><li>官方网站：<code>https://sentinelguard.io/zh-cn</code></li></ul><p>Sentinel 的使用可以分为两个部分</p><ul><li><strong>核心库</strong>（Jar包）：不依赖任何框架&#x2F;库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能</li><li><strong>控制台</strong>（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等</li></ul><p><strong>搭建Sentinel的控制台</strong></p><ul><li>下载jar包：<code>https://github.com/alibaba/Sentinel/releases</code>，黑马资料中有1.8.6版本</li><li>运行，将jar包放在任意非中文、不包含特殊字符的目录下<ul><li><code>java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.6.jar</code></li><li>其它启动时可配置参数可参考官方文档：<code>https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9</code></li></ul></li><li>访问<code>http://localhost:8090</code>页面，就可以看到sentinel的控制台，账号和密码均为sentinel<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/REmGzvrtV1PDXAp.png" alt="img"></li></ul></li></ul><p><strong>微服务整合sentinel</strong></p><ul><li><p>在<code>cart-service</code>模块中整合sentinel，连接<code>sentinel-dashboard</code>控制台</p></li><li><p>引入sentinel依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置控制台，修改application.yaml文件，添加下面内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br></pre></td></tr></table></figure></li><li><p>重启<code>cart-service</code>，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台</p></li></ul><p><strong>簇点链路</strong></p><p>所谓簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被<code>Sentinel</code>监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（接口）</p><p>因此，我们看到<code>/carts</code>这个接口路径就是其中一个簇点，我们可以<strong>对其进行限流、熔断、隔离</strong>等保护措施</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/Sx9BP8Zq5gkYElf.png" alt="img"></p><p>不过，需要注意的是，SpringMVC接口是按照Restful风格设计，因此购物车的查询、删除、修改等接口全部都是<code>/carts</code>路径，默认情况下Sentinel会把请求路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的</p><p>所以我们可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><p>重启服务，通过页面访问购物车的相关接口</p><p>在簇点链路后面点击流控按钮，即可对其做限流配置</p><p>在弹出的菜单中这样填写：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/XZu3s2px4TfVgYD.png" alt="img"></p><p>这样就把查询购物车列表这个簇点资源的流量限制在了每秒6个，也就是最大QPS为6.</p><p>利用Jemeter做限流测试，我们每秒发出10个请求，最终监控结果如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/KGkH6vCyhnoIrAW.png" alt="img"></p><p>可以看出<code>GET:/carts</code>这个接口的通过QPS稳定在6附近，而拒绝的QPS在4附近，符合预期</p><h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩</p><p>比如，查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/BTaphNYZQbngc23.png" alt="image"></p><p>这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且<strong>可用的线程资源也被限定在一定范围</strong>，不会导致整个购物车服务，如修改、删除等服务崩溃</p><p>对查询商品的FeignClient接口做线程隔离，开启远程调用feignclient作为簇点，可以被流量监控</p><ul><li>修改cart-service模块的application.yml文件，开启Feign的sentinel功能</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span> </span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure><p>需要注意的是，默认情况下SpringBoot项目的tomcat最大线程数是200，允许的最大连接是8492，单机测试很难打满，所以我们需要配置一下cart-service模块的application.yml文件，修改tomcat连接：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">threads:</span></span><br><span class="line">      <span class="attr">max:</span> <span class="number">50</span> <span class="comment"># 允许的最大线程数</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="number">50</span> <span class="comment"># 最大排队等待数量</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">100</span> <span class="comment"># 允许的最大连接</span></span><br></pre></td></tr></table></figure><p>重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源</p><p><strong>配置线程隔离</strong></p><ul><li><p>点击查询商品的FeignClient对应的簇点资源后面的流控按钮，设置线程隔离数为5</p></li><li><p>注意，这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝</p></li><li><p>利用Jemeter测试，每秒发送100个请求：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/ZztfsLIe23brWp9.png" alt="img"></p></li><li><p>此时如果我们通过页面访问购物车的其它接口，例如添加购物车、修改购物车商品数量，发现并不受高并发的影响</p><ul><li>响应时间非常短，这就证明线程隔离起到了作用，尽管查询购物车这个接口并发很高，但是它能使用的线程资源被限制了，因此不会影响太大到其它接口</li></ul></li></ul><h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><p>在上一节，线程隔离中我们发现购物车的查询功能完全瘫痪，尽管可以新增、修改，但是没有页面上的信息反馈，用户以为没有添加成功于是继续新增（实际上数据库已经新增完毕），很容易导致误操作</p><p>好的做法应该是，即使查询业务出现问题，返回一些默认数据或者友好提示</p><p><strong>Fallback的实现</strong></p><p>给FeignClient编写失败后的降级逻辑有两种方式</p><ul><li>方式一：FallbackClass，无法对远程调用的异常做处理</li><li>方式二：FallbackFactory，可以对远程调用的异常做处理，一般选择这种方式</li></ul><p>步骤一：在hm-api模块中给<code>ItemClient</code>定义降级处理类，实现<code>FallbackFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;远程调用ItemClient#queryItemByIds方法出现异常，参数：&#123;&#125;&quot;</span>, ids, cause);</span><br><span class="line">                <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                <span class="comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当业务请求无异常时着正确调用ItemClient，当出现异常时调用ItemClientFallback</li></ul><p>步骤二：在<code>hm-api</code>模块中的<code>com.hmall.api.config.DefaultFeignConfig</code>类中将<code>ItemClientFallback</code>注册为一个<code>Bean</code></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/p8TM9kHcm2ZBEwI.png" alt="img"></p><ul><li>直接在其类名上加<code>@Component</code>注解，为什么不行？注意该业务是<code>hm-api</code>，不会扫描到fallback包，而config包已经在其他业务的启动项中配置过，可以扫描</li></ul><p>步骤三：在<code>hm-api</code>模块中的<code>ItemClient</code>接口中使用<code>ItemClientFallbackFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;,fallbackFactory = ItemClientFallback.class)</span></span><br></pre></td></tr></table></figure><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>查询商品的RT较高（模拟的500ms），从而导致查询购物车的RT也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差</p><p>对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。当商品服务接口恢复正常后，再允许调用。这其实就是<strong>断路器</strong>的工作模式了</p><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即<strong>拦截访问该接口的一切请求，降级处理</strong>；当该接口恢复正常时，再放行对于该接口的请求</p><p>断路器的工作状态切换有一个<strong>状态机</strong>来控制</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/SGJxiIdasmQuTY3.png" alt="image"></p><p>状态机包括三个状态</p><ul><li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。<ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>通过sentinel添加熔断规则：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/nDU13ci6PsqRhuy.png" alt="img"></p><p>这种是按照慢调用比例来做熔断，上述配置的含义</p><ul><li>RT超过200毫秒的请求调用就是慢调用</li><li>统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断</li><li>熔断持续时长20s</li></ul><p>在一开始一段时间是允许访问的，后来触发熔断后，查询商品服务的接口通过QPS直接为0，所有请求都被熔断了。而查询购物车的本身并没有受到影响</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="何为分布式事务"><a href="#何为分布式事务" class="headerlink" title="何为分布式事务"></a>何为分布式事务</h3><p>项目中的下单业务整体流程：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/T5jO4cyzAhUi3dG.png" alt="image"></p><p>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务。这也导致了当库存服务提交事务失败时，只有交易服务与库存服务会回滚，购物车服务不会回滚，ACID失效！</p><ul><li>交易服务：下单事务</li><li>购物车服务：清理购物车事务</li><li>库存服务：扣减库存事务</li></ul><p>通过修改购物车中一商品的库存为0，进行测试，查看各个服务执行情况，购物车会正常清理</p><p>事务并未遵循ACID的原则，归其原因就是参与事务的多个子业务在不同的微服务，跨越了不同的数据库。虽然每个单独的业务都能在本地遵循ACID，但是它们互相之间没有感知，不知道有人失败了，无法保证最终结果的统一，也就无法遵循ACID的事务特性了</p><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。我们必须保证整个全局事务同时成功或失败</p><p>以上分布式事务问题，出现以下情况之一就可能产生分布式事务问题</p><ul><li>业务跨多个服务实现</li><li>业务跨多个数据源实现</li></ul><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在2019年开源的Seata</p><ul><li>官方文档：<code>https://www.seata.io/zh-cn/docs/overview/what-is-seata.html</code></li></ul><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务，就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现</p><p>Seata的工作架构如图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/yzT9GWvVNCuKYnx.png" alt="image"></p><p>Seata的事务管理中有三个重要的角色</p><ul><li><strong>TC (Transaction Coordinator) - 事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚</li><li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务</li><li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li></ul><p>下单业务中，调用<code>createOrder()</code>方法就是开启全局事务，其中的购物车、库存业务就是分支事物的注册和报告，方法结束完毕就会提交、回滚全局事务，那么TC就开始判断是否需要回滚这些分支事务</p><p>其中，<strong>TM</strong>和<strong>RM</strong>可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来<strong>TM</strong>和<strong>RM</strong>就会协助微服务，实现本地分支事务与<strong>TC</strong>之间交互，实现事务的提交或回滚。而<strong>TC</strong>服务则是事务协调中心，是一个独立的微服务，需要单独部署</p><h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><ol><li><p>准备数据库表</p><ul><li>Seata支持多种存储模式，但考虑到持久化的需要，一般选择基于数据库存储。执行黑马资料提供的<code>seata-tc.sql</code>，导入数据库表</li></ul></li><li><p>准备配置文件</p><ul><li>黑马资料准备了一个seata目录，其中包含了seata运行时所需要的配置文件</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/crLJOQfTyi2d9NA.png" alt="image"></li></ul></li><li><p>基于docker部署</p><ul><li><p>拷贝seata目录和seata镜像到docker的<code>/root</code>目录下</p></li><li><p>需要注意，因为配置文件中的连接都是通过服务名称，所以要确保nacos、mysql都在hm-net网络中。如果某个容器不在hm-net网络，可以参考下面的命令将某容器加入指定网络</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network connect [网络名] [容器名]</span><br></pre></td></tr></table></figure></li><li><p>在虚拟机的<code>/root</code>目录执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name seata \</span><br><span class="line">-p 8099:8099 \</span><br><span class="line">-p 7099:7099 \</span><br><span class="line">-e SEATA_IP=192.168.80.132 \</span><br><span class="line">-v ./seata:/seata-server/resources \</span><br><span class="line">--privileged=true \</span><br><span class="line">--network heima \</span><br><span class="line">-d \</span><br><span class="line">seataio/seata-server:1.5.2</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过<code>虚拟机IP:7099</code>查看UI控制台是否部署成功</p></li></ol><h3 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h3><p>为了方便各个微服务集成seata，我们需要把seata配置共享到nacos，因此<code>trade-service</code>模块不仅仅要引入seata依赖，还要引入nacos依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次在nacos上添加一个共享的seata配置，命名为<code>shared.seata.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure><ul><li>一个服务的获取途径：命名空间-分组-服务名称-集群-具体的实例</li><li>注意登录密码修改为nacos（如果之前对nacos登录密码有过修改）</li></ul><p>然后，改造<code>trade-service</code>模块，添加<code>bootstrap.yaml</code>，修改<code>appplication.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">trade-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared.jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared.log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared.swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared.seata.yaml</span> <span class="comment"># 共享seata配置</span></span><br></pre></td></tr></table></figure><p>最后，对涉及到分布式服务的购物车和商品服务进行修改</p><p>注意jdk其他版本（非11）如果报错就在服务配置上<code>--add-opens=java.base/java.lang=ALL-UNNAMED</code></p><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>分布式事务解决方案有很多例如：<strong>XA</strong>、<strong>TCC</strong>、<strong>AT</strong>、<strong>SAGA</strong>等，Seata也对这4种方案支持，这里黑马主要讲解XA、AT模式</p><p><code>XA</code> 规范 是<code> X/Open</code> 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范描述了全局的<code>TM</code>与局部的<code>RM</code>之间的接口，几乎所有主流的关系型数据库都对 XA 规范提供了支持</p><p>XA是规范，目前主流数据库都实现了这种规范，实现的原理都是基于<strong>两阶段提交</strong></p><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/CMKzw8ZJk1UrHb6.png" alt="image"></p><ul><li><code>RM</code>一阶段的工作<ol><li>注册分支事务到<code>TC</code></li><li>执行分支业务sql但不提交</li><li>报告执行状态到<code>TC</code></li></ol></li><li><code>TC</code>二阶段的工作<ol><li><code>TC</code>检测各分支事务执行状态</li><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ol></li><li><code>RM</code>二阶段的工作<ol><li>接收<code>TC</code>指令，提交或回滚事务</li></ol></li></ul><p><code>XA</code>模式的优点：</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p><code>XA</code>模式的缺点：</p><ul><li>因为一阶段需要锁定数据库资源（排他锁，一致等待其他分支事务执行完毕，才能提交），等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><p><strong>实现XA模式</strong></p><p>因为导入了seata的stater的依赖，所以实现非常简单</p><ul><li><p>首先，在配置文件中指定要采用的分布式事务模式，在Nacos中的共享shared-seata.yaml配置文件中设置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mde:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure></li><li><p>其次，将<code>@GlobalTransactional</code>标记分布式事务的入口方法</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/JKPdAfDRe9lFCVL.png" alt="image"></p></li></ul><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p>Seata主推的是AT模式，AT模式同样是分阶段提交的事务模型，不过却弥补了XA模型中资源锁定周期过长的缺陷</p><p>Seata的AT模式基本架构如图</p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/7rXms39chTb4zVM.png" alt="img"></p></li><li><p>阶段一<code>RM</code>的工作</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul></li><li><p>阶段二提交时<code>RM</code>的工作：删除undo-log即可</p></li><li><p>阶段二回滚时<code>RM</code>的工作：根据undo-log恢复数据到更新前</p></li></ul><p><code>AT</code>模式与<code>XA</code>模式最大的区别：</p><ul><li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源（优点是性能好，缺点是数据一致性问题）</li><li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚</li><li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li></ul><p><strong>AT模式的实现</strong></p><ol><li>去掉nacos配置文件中的XA模式即可（默认是AT）</li><li>将黑马资料中sql文件<code>undo_log</code>表导入到几个分支服务对应的数据库中</li></ol><p>问题：当还未恢复快照时，别人也修改了数据，是否会造成并发问题？、</p><ul><li>在提交数据快照前会向TC（事务协调器）注册分支，申请一个主键等于目标数据主键值的<strong>全局锁</strong></li><li>Seata通过全局锁实现了写隔离，确保其他事务在当前事务未释放全局锁时无法修改同一数值。这意味着，如果别的线程或者进程在全局事务结束前尝试修改相应的数据，将会被阻塞，直到全局锁释放。因此，不会发生脏写问题，从而避免了并发问题</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 黑马学习课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tools</title>
      <link href="/Tools/"/>
      <url>/Tools/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一些小工具的介绍与使用，感谢这些博主！</p></blockquote><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><h2 id="个人博客网站搭建"><a href="#个人博客网站搭建" class="headerlink" title="个人博客网站搭建"></a>个人博客网站搭建</h2><ol><li>这个博主的教程非常详细，且配有文字+视频讲解<code>https://ihcll.cn/83/</code></li><li>Github和Gitee其实都差不多，看个人喜欢</li></ol><h2 id="个人博客网站配置"><a href="#个人博客网站配置" class="headerlink" title="个人博客网站配置"></a>个人博客网站配置</h2><ol><li><code>ButterFly</code> 主题配置&amp;美化<ol><li>官网<code>https://github.com/jerryc127/hexo-theme-butterfly</code></li><li><code>https://www.cnblogs.com/MoYu-zc/p/14395965.html</code></li></ol></li><li>PicGo + Typora + Smms获取图片超链以及上传<ol><li>Smms图床网站官网<code>https://smms.app/</code></li><li><code>https://blog.csdn.net/dante1987/article/details/127706832</code></li></ol></li><li>免费图片压缩<ol><li><code>https://saerasoft.com/caesium/</code></li></ol></li><li>其他免费图床（如果Smms不可用的话可以更换）<ol><li><code>https://www.picgo.net/</code> </li><li><code>https://imgse.com/</code></li><li><code>https://www.imgbed.link/</code></li><li><code>https://www.imgurl.org/</code></li><li><code>https://img.z4a.net/</code></li></ol></li></ol><h2 id="各种文件的格式转换"><a href="#各种文件的格式转换" class="headerlink" title="各种文件的格式转换"></a>各种文件的格式转换</h2><ol><li>格式化工厂<ol><li>官网<code>http://www.pcgeshi.com/index.html</code>下载</li></ol></li></ol><h2 id="文字扫描、识别工具"><a href="#文字扫描、识别工具" class="headerlink" title="文字扫描、识别工具"></a>文字扫描、识别工具</h2><ol><li>Umi-OCR<ol><li>官网<code>https://github.com/hiroi-sora/Umi-OCR</code></li></ol></li></ol><p>VPS</p><ol><li>彩虹云<ol><li>官网:<code>https://host.cccyun.cc/</code></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis实战篇学习笔记</title>
      <link href="/%E9%BB%91%E9%A9%ACRedis/"/>
      <url>/%E9%BB%91%E9%A9%ACRedis/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 在此特别感谢黑马程序员Redis课程</p><p> <a href="https://www.bilibili.com/video/BV1cr4y1671t?p=70&vd_source=7341c7fca3b496e9108bb1fd49c634ef">黑马程序员的Redis课程</a></p></blockquote><h1 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h1><ul><li><p><em><strong>短信登录</strong></em></p><ul><li>通过Redis共享Session实现</li><li>在苍穹外卖项目中通过Json Web Token实现登录；黑马点评通过Redis共享session实现短-  -信验证登录。</li></ul></li><li><p><em><strong>添加缓存</strong></em></p><ul><li>基于Redis实现给商户添加缓存，设置更新策略，满足读写一致</li><li>解决缓存中存在3大问题，缓存穿透、缓存雪崩、缓存击穿</li><li>对锁的理解和线程池的创建&amp;使用（开启独立线程）</li></ul></li><li><p><em><strong>优惠卷秒杀</strong></em></p><ul><li>基本优惠卷和秒杀优惠卷以及优惠卷订单的添加</li><li>通过加乐观锁&amp;悲观锁的方式解决库存超卖问题</li><li>通过加锁实现对单机状态下一人一单的细粒度控制</li><li>集群环境下的并发问题分析</li></ul></li><li><p><em><strong>分布式锁</strong></em></p><ul><li>分布式锁的实现，以及误删问题、获取、判断、删除锁的原子性问题</li><li>线程标识解决误删问题、</li><li>lua脚本解决原子性问题</li><li><strong>分布式锁-Redisson</strong><ul><li>Redisson实现可重入、可重试、超时续约</li><li>实现的原理以及Watch Dog机制</li><li>Redisson通过联锁实现主从一致性</li></ul></li></ul></li><li><p><em><strong>秒杀优化</strong></em></p><ul><li>异步”秒杀”的思路分析</li><li>基于lua脚本完成订单业务的判断</li><li>通过阻塞对垒与独立线程处理订单异步任务完成下单</li></ul></li><li><p><em><strong>Redis消息队列</strong></em></p><ul><li>认识什么是消息队列，市面上常用的消息中间件</li><li>基于Redis的List、PubSub、Stream结构实现消息队列</li><li>三种结构对实现消息队列的优缺点</li><li>基于Stream结构的消费者组模式下实现多消费秒杀下单</li></ul></li><li><p><em><strong>达人探店</strong></em></p><ul><li>如何基于云存储服务实现照片上传</li><li>基于Redis的Set集合实现用户是否对某博文进行过点赞</li><li>基于Redis的SortedSet集合实现用户是否对某博文进行过点赞，以及点赞用户通过时间先后排序</li><li>了解MySQL的查询结果机制，实现给定顺序上传</li></ul></li><li><p><em><strong>好友关注</strong></em></p><ul><li>多对多型表结构关系的建立</li><li>基于SortedSet实现”交集”查询</li><li>什么时Feed流，Feed流的实现方式</li><li>SortedSet的ZREVRANGEBYSCORE命令，实现滚动分</li></ul></li><li><p><em><strong>附近商铺</strong></em></p><ul><li>了解Redis中GEO这种数据结构的使用</li><li>通过GEO来实现附近商铺的位置搜索</li></ul></li><li><p><em><strong>用户签到</strong></em></p><ul><li>了解Redis中BitMap这种数据结构的使用</li><li>通过BitMap实现签到功能和连续签到次数</li></ul></li><li><p><em><strong>UV统计</strong></em></p><ul><li>了解LogLog概率统计算法</li><li>了解Redis中HyperLogLog这种数据结构应用</li></ul></li></ul><hr><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><ul><li>前后端分离开发</li><li>前端通过Nginx服务器启动。<ul><li>在“苍穹外卖”项目中同样是采用Nginx这种轻量的反向代理服务器。</li><li>通过nignx的负载均衡能显著降低Tomcat服务器的压力。</li></ul></li><li>该项目中对mysql的并发需求也会非常大，除了通过mysql集群外，也通过部署Redis集群来减轻对mysql的并发压力。</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/aN8L7DiBSnEY3jF.png" alt="url"></li></ul><h2 id="导入前端工程"><a href="#导入前端工程" class="headerlink" title="导入前端工程"></a>导入前端工程</h2><ol><li><p>在黑马提供的资料中，找到<strong>Nginx包</strong>，把包放到我们的workspace中。</p><ol><li>该workspace不能包含中文路径，不然nginx启动失败</li></ol></li><li><p>启动<code>start nginx</code>，一闪而过说明启动成功；或者查看任务进程有无nginx</p><ol><li>访问<code>http://localhost:8080/</code>即可看到</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/3QyCqIgpf8KPv4X.webp" alt="url" style="zoom:50%;" /></li></ol></li></ol><h2 id="导入后端工程"><a href="#导入后端工程" class="headerlink" title="导入后端工程"></a>导入后端工程</h2><ol><li>在黑马提供的资料中，找到<code>hm-dianping</code>项目导入</li><li>启动项目，在浏览器中访问<code>http://localhost:8081/shop-type/list</code>,如果出现json数据，代表成功。</li><li>示例</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/zxsLiRaClJ2bd43.webp" alt="url" style="zoom: 33%;" /></li></ol><h2 id="数据库搭建"><a href="#数据库搭建" class="headerlink" title="数据库搭建"></a>数据库搭建</h2><h3 id="表结构说明"><a href="#表结构说明" class="headerlink" title="表结构说明"></a>表结构说明</h3><ul><li>导入黑马资料中的sql文件完成数据库的建表</li></ul><table><thead><tr><th align="center">表</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">tb_user</td><td align="center">用户表</td></tr><tr><td align="center">tb_user_info</td><td align="center">用户详情表</td></tr><tr><td align="center">tb_shop</td><td align="center">商户信息表</td></tr><tr><td align="center">tb_shop_type</td><td align="center">商户类型表</td></tr><tr><td align="center">tb_blog</td><td align="center">用户日记表（达人探店日记）</td></tr><tr><td align="center">tb_follow</td><td align="center">用户关注表</td></tr><tr><td align="center">tb_voucher</td><td align="center">优惠券表</td></tr><tr><td align="center">tb_voucher_order</td><td align="center">优惠券的订单表</td></tr></tbody></table><h3 id="字符集-排序字符集"><a href="#字符集-排序字符集" class="headerlink" title="字符集&amp;排序字符集"></a>字符集&amp;排序字符集</h3><ul><li>字符集是<code>utf8mb4</code></li><li><ul><li>在MySQL中保留四字节长度的<code>utf-8</code>编码的字符，兼容性更好（与utf-8相比），空间占用比utf-8稍大，mysql官方建议使用varchar代替char使用</li><li>详细请看<code>https://blog.csdn.net/munangs/article/details/126617226</code></li></ul></li><li>排序字符集是<code>utf8mb4_general_ci</code><ul><li>推荐使用 <code>utf8mb4_0900_ai_ci</code> 作为默认排序字符集；<code>utf8mb4_general_ci</code>在比较和排序的性能上都还行， 但是没有实现 <strong>Unicode</strong> 排序规则，在遇到某些特殊语言或者字符集，排序结果可能不一致</li></ul></li></ul><h2 id="Redis搭建"><a href="#Redis搭建" class="headerlink" title="Redis搭建"></a>Redis搭建</h2><ol><li>配置信息</li></ol> <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ==redis==</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">lettuce:</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure><ol start="2"><li>选择<ol><li>由于是个人操作，直接使用<strong>Windows</strong>系统下的<strong>Redis</strong></li><li>在”苍穹外卖“中使用的是RedisTemplate，然后配置<strong>字符串序列化器</strong>；而这里的StringRedisTemplate继承RedisTemplate且默认序列化器就是<strong>字符串序列化器</strong>，因此之后直接装配StringRedisTemplate使用即可</li><li>RedisTemplate 和 StringRedisTemplate区别<ol><li>详情看<code>https://blog.csdn.net/zhanyu1/article/details/90760226</code></li></ol></li></ol></li></ol><hr><h1 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h1><h2 id="基于Session的登录流程"><a href="#基于Session的登录流程" class="headerlink" title="基于Session的登录流程"></a>基于Session的登录流程</h2><ol><li>通过接收到的手机号发送验证码</li><li>短信验证码登录、注册</li><li>校验登录状态</li></ol><h3 id="发送验证码实现"><a href="#发送验证码实现" class="headerlink" title="发送验证码实现"></a>发送验证码实现</h3><ol><li><p>查看前后端请求接口和传输对象</p><ol><li>Post请求，路径为<code>/user/code</code></li><li>请求参数为<code>String phone, HttpSession session</code></li></ol></li><li><p>电话号码规范校验</p><ol><li>这里通过工具类<code>RegexUtils</code>和<code>RegexPatterns</code>常量类做正则判断</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手机号正则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PHONE_REGEX</span> <span class="operator">=</span> </span><br><span class="line">    <span class="string">&quot;^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d&#123;8&#125;$&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是无效手机格式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> phone 要校验的手机号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true:符合，false：不符合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPhoneInvalid</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mismatch(phone, RegexPatterns.PHONE_REGEX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>生成验证码<ol><li>黑马使用的是一个随机数工具类，生成6位的数字随机数。</li><li><code>RandomUtil</code>工具类</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>保存验证码到session中</p></li><li><p>发送验证码</p></li><li><p>具体service层代码实现</p><ol><li>代码逻辑</li><li>手机号校验</li></ol><ul><li>错误，返回错误信息</li><li>正确，生成6位数字验证码<ul><li>没有短信服务接口，直接输出到控制台查看</li><li>保存到<code>session</code>域中</li></ul></li></ul></li></ol> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送验证码</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(phone);</span><br><span class="line">    <span class="keyword">if</span> (isInvalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.PHONE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">yzm</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,yzm);</span><br><span class="line">    log.info(<span class="string">&quot;yzm:&#123;&#125;&quot;</span>,yzm);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="短信登录实现"><a href="#短信登录实现" class="headerlink" title="短信登录实现"></a>短信登录实现</h3><ol><li><p>查看前后端请求接口和传输对象</p></li><li><p>Post请求路径为<code>/user/login</code></p><ol><li>请求参数为<code>LoginFormDTO loginForm, HttpSession session</code></li></ol></li><li><p>查看<code>LoginFormDTO </code>的组成结构</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFormDTO</span> &#123;</span><br><span class="line">    <span class="comment">//电话</span></span><br><span class="line">    <span class="keyword">private</span> String phone; </span><br><span class="line">    <span class="comment">//输入的验证码</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>实现逻辑</p><ol><li><p>校验手机号是否有效</p><ol><li>无效，返回错误信息</li><li>有效，判断手机号是否一致<ol><li>不一致，返回错误信息</li><li>一致，通过获取<code>session</code>域中yzm进行校验<ol><li>错误，返回错误信息</li><li>正确，根据手机号在数据库中查询用户<ol><li>用户存在，保存用户到session</li><li>用户不存在，创建新用户，保存数据库中</li></ol></li></ol></li></ol></li></ol><p>2.创建新用户</p><ol><li>对User实体类创建一个实现方法</li><li>根据电话号码和<code>IdGenerator</code>构建一个<code>User</code>实体</li><li>保存数据库</li><li>保存到<code>session</code></li></ol></li></ol></li><li><p>具体service层代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(loginForm.getPhone());</span><br><span class="line">    <span class="keyword">if</span> (isInvalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.PHONE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>).toString();    </span><br><span class="line">    <span class="keyword">if</span> (!loginForm.getCode().equals(yzm))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.CODE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getByPhone(loginForm.getPhone());</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>)&#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> createUserWithPhone(loginForm.getPhone());</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> userMapper.insert(newUser);</span><br><span class="line">    <span class="keyword">if</span> (row != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_USER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,newUser);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过电话号码创建用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> phone</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> User <span class="title function_">createUserWithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setPhone(phone);</span><br><span class="line">    user.setId(YitIdHelper.nextId());</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    <span class="comment">//名称采用的是RandomUtil的随机字符串</span></span><br><span class="line">    user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里的主键生成策略采用<strong>雪花算法id</strong>生成</p><ul><li><p>配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.yitter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yitter-idgenerator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>配置详情见官网</p><ul><li><code>https://github.com/yitter/idgenerator/tree/master/Java</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGeneratorUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局 初始化（应用程序启动时执行一次）</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 IdGeneratorOptions 对象，可在构造函数中输入 WorkerId(默认为0)</span></span><br><span class="line">        <span class="type">IdGeneratorOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGeneratorOptions</span>();</span><br><span class="line">        <span class="comment">// 保存参数（务必调用，否则参数设置不生效）：</span></span><br><span class="line">        YitIdHelper.setIdGenerator(options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>流程图</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/ib7vXEtZzQGeTNY.webp" alt="img"></p></li></ol><p></p><h2 id="登录拦截"><a href="#登录拦截" class="headerlink" title="登录拦截"></a>登录拦截</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li><p>为什么需要登录拦截器？</p><ul><li>一般来说，只有静态、登录和注册页面是用户可以直接<code>url</code>访问的。其他一切的<code>url</code>都需要被拦截，进行判断</li><li>简单来说，就是防止用户不登录就访问系统资源</li></ul></li><li><p>登录拦截器的业务实现原理？</p><ul><li>在被拦截的请求中查看session域里是否有用户的登录数据（基于Session实现）</li><li>在”苍穹外卖“中是通过请求头获取登录令牌来判断用户是否登录。</li></ul></li></ul><h3 id="黑马提供的Tomcat的运行原理"><a href="#黑马提供的Tomcat的运行原理" class="headerlink" title="黑马提供的Tomcat的运行原理"></a>黑马提供的Tomcat的运行原理</h3><ol><li><p>运行原理图</p></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/qRTaSxXzjNgB6H8.webp" alt="img" style="zoom: 50%;" /></li><li><p>示例</p><ol><li>当用户发起请求时，会访问我们向<code>tomcat</code>注册的<strong>端口</strong>，任何程序想要运行，都需要有一个线程对当前端口号进行<strong>监听</strong>，<code>tomcat</code>也不例外</li><li>当监听线程知道用户想要和<code>tomcat</code>连接时，会由监听线程创建<code>socket</code>连接</li><li><code>socket</code>都是成对出现的，用户通过<code>socket</code>互相传递数据，当<code>tomcat</code>端的<code>socket</code>接受到数据后，此时监听线程会从<code>tomcat</code>的线程池中取出一个线程执行用户请求</li><li>在我们的服务部署到<code>tomcat</code>后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的<code>controller</code>，<code>service</code>，<code>dao</code>中，并且访问对应的<code>DataBase</code></li><li>在用户执行完请求后，再统一返回，再找到<code>tomcat</code>端的<code>socket</code>，再将数据写回到用户端的<code>socket</code>，完成请求和响应</li></ol></li><li><p>通过以上讲解，可以得知 <strong>每个用户其实都是去tomcat线程池中找的一个线程来完成工作</strong>， 使用完成后再进行回收，既然每个请求都是独立(每一个线程都不一致)的，所以在每个用户去访问我们的工程时，我们可以使用<code>threadlocal</code>来做到<strong>线程隔离</strong>，即每个线程只操作自己的一份数据</p></li></ol><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ol><li>通过<code>threadLocal</code>的源码，会发现在<code>threadLocal</code>中，无论是他的<code>put()</code>方法和他的<code>get()</code>方法，都是先获得当前用户的线程，然后从线程中取出线程的成员变量<code>map</code>，只要线程不一样，<code>map</code>就不一样，所以可以通过这种方式来做到<strong>线程隔离</strong></li><li>源码</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/f5vKJtoRbkAz4Ey.webp" alt="img" style="zoom:50%;" /></li></ol><h3 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题"></a>Session共享问题</h3><ul><li><p>核心思路分析</p><ul><li><p>每个<code>tomcat</code>中都有一份属于自己的<code>session</code>,假设用户第一次访问第一台<code>tomcat</code>，并且把自己的信息存放到第一台服务器的<code>session</code>中</p></li><li><p>但是第二次，这个用户访问到了第二台<code>tomcat</code>，那么在第二台服务器上，肯定没有第一台服务器存放的<code>session</code></p></li><li><p>所以此时整个登录拦截功能就会出现问题</p></li></ul></li><li><p>如何解决这个问题呢？</p><ul><li>早期的方案是<strong>session拷贝</strong>，就是说虽然每个<code>tomcat</code>上都有不同的<code>session</code>，但是每当任意一台服务器的<code>session</code>修改时，都会<strong>同步</strong>给其他的Tomcat服务器的<code>session</code>，这样的话，就可以实现session的共享</li></ul></li><li><p>但是这种方案具有两个大问题</p><ol><li>每台服务器中都需要完整的一份session数据，服务器压力过大。</li><li>session拷贝数据时，可能会出现延迟</li><li>所以这里采用的方案是基于<strong>Redis</strong>来完成，Redis数据本身就是共享的，这样就可以避免session共享的问题</li></ol></li><li><p>这样的实现就需要对登录&amp;注册功能代码，进行一定修改，把用户数据User直接缓存到redis中</p></li><li><p>在session中保存用户数据，如果浏览器信息被截取的话，会存在重要信息泄露问题</p><ul><li>因此黑马会有<code>UserDTO</code>类来对用户数据进行隐藏</li><li>不过在<strong>Redis</strong>中不会存在这些问题，但为了安全，还是需要对缓存的用户数据进行隐藏</li></ul></li></ul><h3 id="Redis的设计"><a href="#Redis的设计" class="headerlink" title="Redis的设计"></a>Redis的设计</h3><ol><li><p>使用Redis，不可避免的需要考虑key和value的设计。</p></li><li><p>KEY需要满足</p><ol><li>唯一性</li><li>非敏感性</li></ol></li><li><p>Value则需要考虑使用何种数据结构缓存<code>User</code>实体数据</p><ol><li>直接字符串，以Json形式存储</li><li>Hash结构，key-field-value形式</li></ol></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/uiY4Lnp8svU2GDb.webp" alt="img" style="zoom: 33%;" /></li><li><p>选择</p><ol><li>KEY通过<code>IdGeneratorUtill</code>工具类随机生成token即可，前端携带这个token访问</li><li>因为<code>User</code>数据已经被隐藏，以及不会通过Redis对其中的个别数据查看，因此选择String类型以Json形式存储</li></ol></li></ol><h3 id="基于Redis实现登录"><a href="#基于Redis实现登录" class="headerlink" title="基于Redis实现登录"></a>基于Redis实现登录</h3><ol><li><p>通过token做登录令牌，30分钟的有效期</p></li><li><p>将<code>UserDto</code>转为Json字符串</p></li><li><p>返回token</p></li><li><p>由于只是对<code>session</code>的功能修改，其他不做太大改变，因此直接贴代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送验证码</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(phone);</span><br><span class="line">    <span class="keyword">if</span> (isInvalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.PHONE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">yzm</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    stringRedisTemplate.opsForValue()</span><br><span class="line">        .set(RedisConstants.LOGIN_CODE_KEY+phone,yzm,<span class="number">1</span>,TimeUnit.MINUTES);</span><br><span class="line">    log.info(<span class="string">&quot;yzm:&#123;&#125;&quot;</span>,yzm);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//登录</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(loginForm.getPhone());</span><br><span class="line">       <span class="keyword">if</span> (isInvalid)&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(MessageConstants.PHONE_ERROR);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">yzm</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">           .get(RedisConstants.LOGIN_CODE_KEY + loginForm.getPhone());</span><br><span class="line">       <span class="keyword">if</span> (!loginForm.getCode().equals(yzm))&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(MessageConstants.CODE_ERROR);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getByPhone(loginForm.getPhone());</span><br><span class="line">       <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">       <span class="keyword">if</span> (user != <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">token</span> <span class="operator">=</span> YitIdHelper.nextId();</span><br><span class="line">       BeanUtils.copyProperties(user,userDTO);</span><br><span class="line">       <span class="type">String</span> <span class="variable">userDtoStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(userDTO);</span><br><span class="line">       stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_USER_KEY+token,</span><br><span class="line">                userDtoStr,RedisConstants.LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//注册</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> createUserWithPhone(loginForm.getPhone());</span><br><span class="line">       <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> userMapper.insert(newUser);</span><br><span class="line">       <span class="keyword">if</span> (row != <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(MessageConstants.NEW_USER_ERROR);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> <span class="variable">token</span> <span class="operator">=</span> YitIdHelper.nextId();</span><br><span class="line">   BeanUtils.copyProperties(newUser,userDTO);</span><br><span class="line">   <span class="type">String</span> <span class="variable">userDtoStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(userDTO);</span><br><span class="line">   stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_USER_KEY+token,userDtoStr</span><br><span class="line">       ,RedisConstants.LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> ![img](https:<span class="comment">//s2.loli.net/2024/07/02/xngTCto7pmvbcaB.webp)</span></span><br><span class="line"></span><br><span class="line">### 实现登录拦截器</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 代码逻辑</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> 从请求头中获取`token`</span><br><span class="line">   <span class="number">1.</span> 根据`token`从**Redis**中获取用户数据</span><br><span class="line">      <span class="number">1.</span> 失败，设置响应状态码<span class="number">401</span>（拦截）</span><br><span class="line">      <span class="number">1.</span> 成功，保存用户到threadlocal中</span><br><span class="line">         <span class="number">1.</span> 刷新`token`的缓存时间</span><br><span class="line">         <span class="number">1.</span> 放行</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 具体代码</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   <span class="comment">//登录拦截器</span></span><br><span class="line">   <span class="meta">@Component</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">       <span class="meta">@Resource</span></span><br><span class="line">       <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">       </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">           Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">userDtoStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">               .get(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">           <span class="keyword">if</span> (userDtoStr == <span class="literal">null</span> )&#123;</span><br><span class="line">               response.setStatus(<span class="number">401</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> JSONUtil.toBean(userDtoStr,UserDTO.class);</span><br><span class="line">           <span class="keyword">if</span> (userDTO == <span class="literal">null</span>)&#123;</span><br><span class="line">               response.setStatus(<span class="number">401</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">          UserHolder.saveUser(userDTO);</span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,</span><br><span class="line">                                  RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>添加拦截器</p><ul><li><p>设置拦截路径和放行路径；这里直接粘贴黑马的代码即可</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;LoginInterceptor拦截器.....&quot;</span>);</span><br><span class="line">        registry.addInterceptor(loginInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="实现状态登录刷新"><a href="#实现状态登录刷新" class="headerlink" title="实现状态登录刷新"></a>实现状态登录刷新</h3><ol><li><p>问题</p><ul><li>登录拦截器只是拦截了需要拦截的路径（url）；如果用户访问不被拦截的<code>url</code>超过30min以上<code>token</code>还是会过期</li></ul></li><li><p>解决</p><ul><li>我们需要一个拦截器专门用来处理令牌刷新问题，至于是否<strong>Redis</strong>缓存用户数据则放行至下一个拦截器处理</li><li>令牌刷新拦截器需要对所有请求进行拦截</li></ul></li><li><p>实现逻辑</p><ol><li><p>第一个拦截器</p></li><li><p>从请求头中获取<code>token</code></p><ol><li>不存在，放行（可能是登录）</li><li>存在，从Redis中获取用户数据<ol><li>不存在，放行（toke过期）</li><li>存在，保存用户数据到<code>threadlocal</code>中<ol><li>刷新token有效期</li><li>放行</li></ol></li></ol></li><li>在请求完成后移除用户<ol><li><code>afterCompletion</code>方法中调用<code>UserHolder.removeUser();</code></li></ol></li></ol></li><li><p>第二个拦截器</p><ol><li><p>直接判断<code>threadlocal</code>中是否存在用户数据</p><ol><li>不存在，响应401，拦截</li><li>存在，放行</li></ol></li><li><p>在请求完成后移除用户</p><ol><li>在<code>afterCompletion</code>方法中<code>UserHolder.removeUser();</code></li></ol></li></ol></li></ol></li><li><p>我们重启服务器，登录，然后去Redis的图形化界面查看<code>token</code>的<code>ttl</code>，如果每次切换界面之后，<code>ttl</code>都会重置，说明代码没有问题  </p></li><li><p>实现代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//令牌刷新拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenRefeshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,HttpServletResponse response,</span></span><br><span class="line"><span class="params">       Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userDtoStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .get(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="keyword">if</span> (userDtoStr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> JSONUtil.toBean(userDtoStr, UserDTO.class);</span><br><span class="line">        <span class="keyword">if</span> (userDTO == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,</span><br><span class="line">                                   RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TokenRefeshInterceptor tokenRefeshInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Interceptor拦截器.....&quot;</span>);</span><br><span class="line">        registry.addInterceptor(tokenRefeshInterceptor)</span><br><span class="line">                        .addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">        registry.addInterceptor(loginInterceptor)</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>流程图<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/AQhWkJPjN1po6sa.webp" alt="img"></p></li><li><p>拦截器实现原理图（回忆知识）</p><ol><li>参考别人博客<code>https://cyborg2077.github.io/2022/09/10/SSMIntegration/</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/XKz4xigFZQ5oBEj.webp" alt="img"></li></ol></li><li><p>实现流程</p><ol><li><p>浏览器发送一个请求，会先到<code>Tomcat</code>服务器的web服务器</p></li><li><p><code>Tomcat</code>服务器接收到请求后，会先去判断请求的是静态资源还是动态资源</p></li><li><p>如果是静态资源，会直接到<code>Tomcat</code>的项目部署目录下直接访问</p></li><li><p>如果是动态资源，就需要交给项目的后台代码进行处理</p></li><li><p>在找到具体的方法之前，我们可以去配置<strong>过滤器</strong>（可以配置多个），按照顺序进行执行（在这里就可以进行权限校验）</p></li><li><p>然后进入到中央处理器（SpringMVC中的内容），SpringMVC会根据配置的规则进行拦截</p></li><li><p>如果满足规则，则进行处理，找到其对应的<code>Controller</code>类中的方法进行，完成后返回结果</p></li><li><p>如果不满足规则，则不进行处理</p></li><li><p>这个时候，如果我们需要在每个<code>Controller</code>方法执行的前后添加业务，具体该如何来实现？ </p><ul><li><p>这个就是拦截器要做的事</p></li><li><p>拦截器（Interceptor）是一种动态拦截方法调用的机制，在<strong>SpringMVC</strong>中动态拦截控制器方法的执行</p><ul><li><p>在指定的方法调用前后执行预先设定的代码</p></li><li><p>阻止原始方法的执行</p></li></ul></li><li><p>总结</p><ul><li>拦截器就是用来作增强</li><li>但是这个拦截器同之前学的过滤器很像，不管是从作用上来看还是从执行顺序上来看</li><li>那么拦截器和过滤器之间的区别是什么呢？ <ul><li>归属不同：<code>Filter</code>属于<strong>Servlet</strong>技术，而<code>Interceptor</code>属于<strong>SpringMVC</strong>技术</li><li>拦截内容不同：<code>Filter</code>对所有访问进行增强，<code>Interceptor</code>仅对<strong>SpringMVC</strong>的访问进行增强</li></ul></li></ul></li></ul></li></ol></li></ol><p></p><hr><h1 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h1><h2 id="缓存介绍"><a href="#缓存介绍" class="headerlink" title="缓存介绍"></a>缓存介绍</h2><h3 id="何为缓存？"><a href="#何为缓存？" class="headerlink" title="何为缓存？"></a>何为缓存？</h3><ul><li><p>缓存就像是自行车,越野车的避震器</p></li><li><p>举个例子</p></li><li><ul><li>越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样</li><li>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪</li></ul></li><li><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地，代码(例如:</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本地用于高并发</span></span><br><span class="line">Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">//用于redis等缓存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); </span><br><span class="line"><span class="comment">//本地缓存</span></span><br><span class="line">Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br></pre></td></tr></table></figure><ul><li>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(map)和对象(new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效</li></ul><h3 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h3><ol><li>缓存的作用<ol><li>降低服务器负载</li><li>提高服务读写响应速度</li></ol></li></ol><h3 id="如何使用缓存？"><a href="#如何使用缓存？" class="headerlink" title="如何使用缓存？"></a>如何使用缓存？</h3><ul><li>实际开发中，会构筑<strong>多级缓存</strong>来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</li><li>缓存类别<ul><li><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</li><li><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</li><li><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</li><li><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</li></ul></li><li>如图<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/TF29enWVtdBSNav.png" alt="img"></li></ul></li></ul><h3 id="本项目使用缓存及其存在的问题"><a href="#本项目使用缓存及其存在的问题" class="headerlink" title="本项目使用缓存及其存在的问题"></a>本项目使用缓存及其存在的问题</h3><blockquote><p>详细介绍见“缓存”</p></blockquote><ol><li><p>该黑马点评下项目，主要是使用Redis缓存</p></li><li><p>Redis缓存有着以下问题</p><ol><li><p>缓存穿透</p></li><li><p>缓存雪崩</p></li><li><p>缓存击穿</p></li></ol></li><li><p>Redis缓存的更新策略的选择</p></li><li><p>内存淘汰</p></li><li><p>超时剔除</p></li><li><p>主动更新</p></li></ol><h2 id="商户缓存添加"><a href="#商户缓存添加" class="headerlink" title="商户缓存添加"></a>商户缓存添加</h2><h3 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h3><ul><li><p>操作方式</p></li><li><ul><li>查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</li></ul></li><li><p>流程图</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/SeLHug4r79CMJox.png" alt="img"></li></ul></li></ul><h3 id="商户缓存查询"><a href="#商户缓存查询" class="headerlink" title="商户缓存查询"></a>商户缓存查询</h3><ol><li><p>前后端请求接口和传输对象</p><ol><li><p>GET请求，请求路径为<code>/shop/&#123;id&#125;</code></p></li><li><p>请求参数为<code>Long id</code></p></li></ol></li><li><p>返回数据对象</p><ol><li><code>pojo/entity/Shop</code></li></ol></li><li><p>代码逻辑</p><ol><li>从redis中根据商户id查询缓存<ol><li>有，直接返回数据</li><li>无，根据商户id查询数据库<ol><li>无，返回错误信息</li><li>有，写入Redis，返回数据</li></ol></li></ol></li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.OPERATE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,jsonStr);</span><br><span class="line">    stringRedisTemplate.expire(RedisConstants.CACHE_SHOP_KEY+id,RedisConstants.CACHE_SHOP_TTL,      TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><ul><li><p>在缓存更新策略的选择上，通过“<strong>主动更新</strong>”方式来绝大程度上保障“<strong>数据一致性</strong>”</p></li><li><p>在<strong>主动更新的三大策略中</strong>选择Cache Aside Pattern（由缓存的调用者，在更新数据库的同时更新缓存）方式，在对数据库进行操作时，同时更新缓存</p><ul><li>这样做的对数据一致性解决的更好，但是对性能的要求较高</li></ul></li><li><p><strong>而在对缓存问题的处理上</strong></p><ul><li>先删除缓存</li><li>单体系统–缓存与数据库操作放在一个事务</li><li>先操作数据库，再处理缓存</li></ul></li></ul><h3 id="实现商铺缓存与数据库双写一致"><a href="#实现商铺缓存与数据库双写一致" class="headerlink" title="实现商铺缓存与数据库双写一致"></a>实现商铺缓存与数据库双写一致</h3><ol><li><p>前后端请求接口和传输对象</p><ol><li>Put请求，请求路径为<code>/shop</code></li><li>请求参数为<code>Shop shop</code></li></ol></li><li><p>实现逻辑</p><ol><li><p>确保缓存处理和数据库操作为一个原子性操作</p><ol><li>在更新方法上添加<code>@Transactional</code>注解</li></ol></li><li><p>先对shop数据进行数据库修改</p><ol><li>失败，返回异常信息</li><li>成功，删除该shop对应的缓存信息</li></ol></li><li><p>返回成功信息</p></li></ol></li><li><p>实现代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shop.getId() == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        shopMapper.updateById(shop);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_UPDATE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + shop.getId());</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三大缓存问题"><a href="#三大缓存问题" class="headerlink" title="三大缓存问题"></a>三大缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ul><li><p>缓存穿透指的是大量的请求<strong>避开了对缓存的调用</strong>，而直接将请求打到了数据库</p></li><li><p>举个例子</p><ul><li>在对商户查询是通过<code>id</code>；如果人为修改<code>id=-1</code>进行恶意查询</li><li><code>String shopStr = stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</code>返回的<strong>shopStr</strong>一定为<strong>null</strong>（主键id策略为auto，所以id一定&gt;&#x3D;1），从而大量请求打到数据库中，造成破坏</li><li><code>Shop shop = shopMapper.selectById(id);</code>该对数据的查询结果<strong>shop</strong>也一定为<strong>null；</strong>既不会响应正确数据，也不会缓存数据到redis中，陷入恶性循环</li></ul></li><li><p>解决方法</p><ol><li><strong>缓存null值</strong><ol><li>我们都知道数据库能够承载的并发不如Redis高，如果大量的请求同时过来访问这种<strong>不存在的数据</strong>，这些请求就都会访问到数据库，简单的解决方案就是‘哪怕这个数据在数据库中也不存在’，我们也把这个数据存入到Redis中去，这样，下次用户过来访问这个不存在的数据，那么在Redis中也能找到这个数据就不会打到到数据库了</li></ol></li><li><strong>布隆过滤器</strong><ol><li>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行；这个请求会去访问Redis，哪怕Redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到Redis中；假设布隆过滤器判断这个数据不存在，则直接返回。</li><li>布隆过滤器走的是哈希思想，只要是哈希思想，就可能存在哈希冲突</li></ol></li><li>流程图<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/Ki7VfZRHNEMCG9x.webp" alt="img"></li></ol></li><li><strong>增强id的复杂度，避免被猜测id规律</strong><ol><li>对于基础数据表中id的自增策略的修改\</li></ol></li><li><strong>做好数据的基础格式校验</strong><ol><li>对id的特判，例如，对id&lt;&#x3D;0的请求直接返回</li></ol></li><li><strong>加强用户权限校验</strong></li><li><strong>做好热点参数的限流</strong></li></ol></li></ul><h4 id="代码逻辑（缓存null值）"><a href="#代码逻辑（缓存null值）" class="headerlink" title="代码逻辑（缓存null值）"></a>代码逻辑（缓存null值）</h4><ul><li>对id判断是否&lt;&#x3D;0以及是否为null<ul><li>是，返回错误信息</li><li>否，通过id查询缓存</li><li>空值，返回错误信息<ul><li>有，返回数据信息</li><li>无，查询数据库<ul><li>有，写入redis，返回数据</li><li>无，将null值也写入redis，返回错误</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="literal">null</span> || id &lt; SystemConstants.ONE )&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(shopStr, <span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().</span><br><span class="line">                set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key,jsonStr);</span><br><span class="line">    stringRedisTemplate.expire(key,RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/6u2dBt5fG9ObhLl.png" alt="img"></p><h4 id="代码逻辑（布隆过滤器）"><a href="#代码逻辑（布隆过滤器）" class="headerlink" title="代码逻辑（布隆过滤器）"></a>代码逻辑（布隆过滤器）</h4><ul><li><p>实现原理<code>https://www.cnblogs.com/z941030/p/9218356.html</code></p><ul><li><p>布隆过滤器实现较为复杂，这里通过封装了布隆过滤器的Java工具类库（<code>https://www.hutool.cn/docs/#/</code>）实现。</p></li><li><p>导入<code>hutool</code>的依赖即可</p></li></ul></li><li><p>根据<code>hutool</code>的布隆过滤器实现自定义一个工具类，方便使用</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleBloomFilterUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前过滤器预先开辟的最大包含记录,通常要比预计存入的记录多一倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CURRENT_BIT</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前过滤器预计所要包含的记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash函数个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_NUMBER</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BitMap的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BitSetBloomFilter BIT_SET_BLOOM_FILTER;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BitMapBloomFilter BIT_MAP_BLOOM_FILTER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化配置</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">        BIT_SET_BLOOM_FILTER = BloomFilterUtil.createBitSet(CURRENT_BIT, N, HASH_NUMBER);</span><br><span class="line">        BIT_MAP_BLOOM_FILTER = BloomFilterUtil.createBitMap(M);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实现逻辑</p><ul><li><p>添加商户数据</p><ul><li>失败，返回错误信息</li><li>成功，添加对应字符串（KEY）到布隆过滤器，返回成功信息。</li></ul></li><li><p>查询商户数据</p><ul><li>查看请求中的商户id生成的KEY是否在布隆过滤器中<ul><li>不存在，返回错误信息</li><li>存在，放行到Redis中查询</li><li>后续逻辑一致</li></ul></li></ul></li></ul></li><li><p>实现代码</p><ol><li>前后端请求接口和传输对象<ol><li>Post请求 <code>/shop</code></li><li>请求参数为<code>Shop shop</code></li></ol></li></ol></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加商户数据</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveShop</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        shopMapper.insert(shop);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY+id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">add</span> <span class="operator">=</span> SingleBloomFilterUtil.BIT_MAP_BLOOM_FILTER.add(key);</span><br><span class="line">    <span class="keyword">if</span> (!add)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;添加布隆过滤器错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="literal">null</span> || id &lt; SystemConstants.ONE )&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> SingleBloomFilterUtil.BIT_MAP_BLOOM_FILTER.contains(key);</span><br><span class="line">    <span class="keyword">if</span> (!contains)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key,jsonStr);</span><br><span class="line">    stringRedisTemplate.expire(key,RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul><li><p>缓存雪崩是指在<strong>同一时段大量的缓存key同时失效</strong>或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力</p></li><li><p>形象地说就是Redis不工作了，许多客户地请求都转向了数据库，导致数据库压力过大</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/wHomaTDXNALB5ht.webp" alt="img"></li></ul></li><li><p>这里地解决对象主要分为2种</p><ol><li><p><strong>针对数据同时过期处理方案</strong></p><ol><li>给不同的Key的TTL添加随机值；确保大量地key不会同一时间失效</li><li>设置多级缓存<ol><li>浏览器访问静态资源时，优先读取浏览器本地缓存</li><li>访问非静态资源（ajax查询数据）时，访问服务端，请求到达Nginx后，优先读取Nginx本地缓存</li><li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li><li>如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库</li></ol></li></ol></li><li><p><strong>Redis服务宕机方案（</strong>集群、降级限流涉及微服务架构，这里了解即可<strong>）</strong></p><ol><li>利用Redis集群提高服务的可用性</li><li>服务熔断或请求限流机制</li></ol></li></ol></li><li><p><strong>代码实现</strong></p></li><li><p>前后端请求接口和传输对象</p><ul><li>GET请求，请求路径为<code>/shop/&#123;id&#125;</code></li><li>请求参数为<code>Long id</code></li></ul></li><li><p>代码逻辑</p><ul><li>对Redis缓存的TTL做修改即可</li><li>新建一个缓存工具类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheUtil</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cache</span><span class="params">(String key,String value, <span class="type">long</span> ttl, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,value,ttl,unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;缓存失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>把随机数加基本缓存时间作为整体TTL</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0-9的随机数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">randomTime</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//自动拆/装</span></span><br><span class="line"><span class="type">long</span> <span class="variable">keyTtl</span> <span class="operator">=</span> Long.parseLong(randomTime) + RedisConstants.CACHE_SHOP_TTL;</span><br><span class="line"><span class="comment">//自定义的工具类使用</span></span><br><span class="line">cacheUtil.cache(key,jsonStr,keyTtl,TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><ul><li><p>实现成功标识</p><ul><li><p>点击<code>美食-&gt;102茶餐厅</code></p></li><li><p>查看缓存信息，TTL是一个固定值加上随机值</p></li><li><p>再次刷新浏览器，若没有进行数据库查询，则成功</p></li></ul></li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul><li><p>缓存击穿问题也叫<strong>热点Key</strong>问题，就是一个被<strong>高并发访问</strong>并且缓存<strong>重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的<strong>冲击</strong></p></li><li><p>形象来说，就是有一个商家被非常多的人光顾（请求）；但是有一天🔑坏了，并且修复这把钥匙花费的时间较长，这时就有非常多的客人被拒之门外无法查看（无法获取该高并发的缓存），它们只好一股脑地去找老板开门（对数据库请求），但由于数量太多、修复时间长，老板的家炸了（数据库无法承受这些压力）</p></li><li><p>区分</p><ul><li>缓存穿透是没有数据而绕过Redis查询，且数据库也无法获取数据</li><li>缓存击穿是Redis中的数据失效了，但是数据库中有数据，只不过访问量过于庞大</li></ul></li><li><p>缓存击穿问题分析</p><ul><li>假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/8NcgrRnM7VPFt5u.png" alt="img"></li></ul></li><li><p>解决方案有两种</p><ol><li><strong>互斥锁</strong></li><li><strong>逻辑过期</strong></li></ol></li></ul><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><ol><li><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从<strong>并行变成了串行</strong>，我们可以采用<strong>tryLock方法 + double check</strong>来解决这样的问题。</p></li><li><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了</p></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/fJsEceWOzwG637q.png" alt="img" style="zoom:50%;" /></li><li><p>前置知识</p><ol><li>利用Redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在<code>stringRedisTemplate</code>调用的方法中返回true， 如果有这个key则插入失败，则返回0，在<code>stringRedisTemplate</code>调用的方法中返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程</li></ol></li><li><p>流程图</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/ARcgeuNtTh1sviL.png" alt="img"></li></ol></li><li><p>代码逻辑</p><ol><li>根据id查询缓存<ol><li>命中，直接返回</li><li>未命中，尝试获取锁<ol><li>获取失败，休眠、双重检查（判断）、重新查找（递归）</li><li>成功，根据id查询数据库<ol><li>无，返回错误信息</li><li>有，写入Redis并返回数据</li><li>释放锁</li></ol></li></ol></li></ol></li></ol></li><li><p>具体代码</p><ol><li>RedisUtil</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key,String value)</span>&#123;</span><br><span class="line">    <span class="comment">//设置超时时间防止死锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> stringRedisTemplate</span><br><span class="line">            .opsForValue()</span><br><span class="line">            .setIfAbsent(key, value,RedisConstants.LOCK_SHOP_TTL,</span><br><span class="line">                    TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>queryWithMutex</code>实现</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="literal">null</span> || id &lt; SystemConstants.ONE )&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//锁的key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//锁的是id对应的商户查询线程</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockValue</span> <span class="operator">=</span> RandomUtil.randomString(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//申明shop</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> redisUtil.tryLock(lockKey, lockValue);</span><br><span class="line">            <span class="comment">//获取失败</span></span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                Thread.sleep(RedisConstants.TTL * <span class="number">10</span>);</span><br><span class="line">                <span class="comment">//双重检查</span></span><br><span class="line">                shopStr = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">                <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">                    shop = JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">                    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//再次尝试</span></span><br><span class="line">                queryWithMutex(id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取成功</span></span><br><span class="line">            shop = shopMapper.selectById(id);</span><br><span class="line">            <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//写入redis</span></span><br><span class="line">            shopStr = JSONUtil.toJsonStr(shop);</span><br><span class="line">          stringRedisTemplate.opsForValue().</span><br><span class="line">              set(key,shopStr,RedisConstants.CACHE_SHOP_TTL,TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            redisUtil.unlock(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Jmeter进行测试 </p><ol><li>首先将Redis中的热点商品数据删除，模拟TTL到期，然后用Jmeter进行压力测试，开100个线程来访问这个没有缓存的热点数据</li><li>如果后台日志<strong>只输出了一条SQL语句</strong>，则说明我们的互斥锁是生效的，没有造成大量用户都去查询数据库，执行SQL语句。</li></ol></li></ol><h4 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><ol><li><p>逻辑过期是指不给<strong>热点KEY</strong>设置过期时间，而是手动给<strong>热点KEY</strong>设置<strong>逻辑过期值</strong>，这样除了Redis集群宕机，否则的话都可以获取到热点数据（热点key不会失效）；不过在对数据的精确上需要根据逻辑过期值来判断</p></li><li><p>逻辑分析</p><ol><li>当用户开始查询Redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回Redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁</li></ol></li><li><p>流程图</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/x4sVjAmkf2RtXeJ.png" alt="img"></li></ol></li><li><p>设计逻辑过期值</p><ol><li>数据缓存时，对<code>shop</code>数据多一个<code>expiredTime</code>字段值<ol><li>对<code>Shop</code>类新增字段<code>expiredTime</code>（侵入性且对实体类做了修改）</li><li>新建RedisData属性类，含逻辑过期字段，继承<code>Shop</code>（可以）</li><li>新建RedisData属性类，含逻辑过期字段和<code>Object data</code>-&gt;<code>Shop</code>（最好）</li></ol></li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="comment">//过期时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="comment">//商户数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>代码逻辑</p><ol><li>对需要缓存的数据预处理<ol><li>将逻辑过期值在添加商户的时候就进行缓存</li></ol></li><li>根据id查询缓存<ol><li>未命中，返回错误信息</li><li>命中，查看逻辑过期值是否过期<ol><li>未过期，直接返回数据</li><li>过期，尝试获取锁<ol><li>失败，返回旧的商户信息(不精确) + 消息提示说明</li><li>成功，<strong>开启独立线程</strong>（缓存重建）<ol><li>查询数据库（独立线程）<ol><li>失败，返回错误信息(没有特殊情况都是一定有)</li><li>成功，写入Redis，设置逻辑过期时间</li><li>返回数据</li></ol></li></ol></li></ol></li><li>释放锁</li></ol></li></ol></li></ol></li><li><p>缓存预处理代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存预热</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShopWithRedisData</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE)&#123;</span><br><span class="line">        log.error(MessageConstants.ID_ERROR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        log.info(MessageConstants.CACHE_PRE_SAVE_SUCCESS);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逻辑过期值2分钟</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span>  <span class="operator">=</span> LocalDateTime.now().plusSeconds(RedisConstants.CACHE_NULL_TTL);</span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> RedisData.builder()</span><br><span class="line">            .expireTime(expireTime)</span><br><span class="line">            .data(shop).build();</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisDataStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(redisData);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key,redisDataStr);</span><br><span class="line">    log.info(MessageConstants.CACHE_PRE_SAVE_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>缓存重建代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓存重建任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getCacheRunnable2</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//建立一个任务</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="comment">//查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//逻辑过期值2分钟</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span>  <span class="operator">=</span> LocalDateTime.now().plusSeconds(RedisConstants.CACHE_SHOP_TTL);</span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> RedisData.builder()</span><br><span class="line">                .expireTime(expireTime)</span><br><span class="line">                .data(shop).build();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisDataStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(redisData);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,redisDataStr);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>线程池创建<ol><li>创建线程池（手动，黑马通过<code>Executors</code>工具自动生成线程池{<strong>不推荐</strong>）</li><li>原因可看，<a href="https://blog.csdn.net/weixin_43702295/article/details/135354378?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-135354378-blog-132420498.235%5Ev43%5Epc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.1&utm_relevant_index=3">ThreadPoolExecutor手动创建线程池</a></li><li>具体参数说明<code>https://blog.csdn.net/c85736722/article/details/135738604</code></li><li>增强，轻量级的动态可控线程池&#96;<a href="https://dynamictp.cn/%60%60%60">https://dynamictp.cn/```</a></li><li>&#96;&#96;&#96;excute&amp;submit<code>方法的使用区别</code><a href="https://www.cnblogs.com/jxxblogs/p/11882381.html%60">https://www.cnblogs.com/jxxblogs/p/11882381.html`</a></li><li>流程图<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/sMIaeoTgH6WnB4u.webp" alt="img"></li></ol></li><li>线程池工具类</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_CORE_POOL</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_MAX_POOL</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存活时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ALIVE_TIME</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放任务的阻塞队列(使用有界队列可以避免资源耗尽的问题)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的拒绝策略，AbortPolicy() 抛异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">DEFAULT_HANDLER</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动创建线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(SIZE_CORE_POOL,</span><br><span class="line">                    SIZE_MAX_POOL,</span><br><span class="line">                    ALIVE_TIME,</span><br><span class="line">                    TimeUnit.MILLISECONDS,</span><br><span class="line">                    queue,</span><br><span class="line">                    ThreadPoolUtil.myDefaultThreadFactory(),</span><br><span class="line">                    DEFAULT_HANDLER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预启动所有核心线程</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        pool.prestartAllCoreThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程池</span></span><br><span class="line"><span class="comment">     * ‘<span class="doctag">@Data</span>’注解对static变量无效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">getPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">myDefaultThreadFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyDefaultThreadFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义线程工厂</span></span><br><span class="line"><span class="comment">     * 用于创建具有特定命名规则和默认属性的新线程,方便出错时回溯</span></span><br><span class="line"><span class="comment">     * 这里和源码一致-Executors.defaultThreadFactory()的源码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyDefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">        <span class="comment">//一个原子整数，用于生成线程池编号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">POOL_NUMBER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//线程组，用于指定新线程所属的线程组</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="comment">//一个原子整数，用于生成线程编号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//线程名称前缀，用于标识线程所属的线程池和线程编号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 告诉编译器忽略与&quot;removal&quot;相关的警告,用于处理即将被移除或已过时的API时</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;removal&quot;)</span></span><br><span class="line">        MyDefaultThreadFactory() &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                    Thread.currentThread().getThreadGroup();</span><br><span class="line">            <span class="comment">//设置线程名称前缀</span></span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                    POOL_NUMBER.getAndIncrement() +</span><br><span class="line">                    <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(<span class="meta">@NonNull</span> Runnable r)</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个新线程，传入线程组、任务（Runnable对象）、线程名称和栈大小</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                    namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                    <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//设置线程是否为守护线程</span></span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon()) &#123;</span><br><span class="line">                t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置线程优先级，默认为正常优先级（NORM_PRIORITY）</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY) &#123;</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>具体代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisDataStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(redisDataStr, RedisData.class);</span><br><span class="line">    <span class="keyword">if</span> (redisDataStr == <span class="literal">null</span> || redisData == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取逻辑过期值</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">//商户数据,这里的转换很重要</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="comment">//当前时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (expireTime.isAfter(now))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">//获取线程池</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> threadPoolUtil.getPool();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> redisUtil.tryLock(lockKey, RedisConstants.KEY_VALUE);</span><br><span class="line">        <span class="comment">//获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//获取任务</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">cacheRunnable</span> <span class="operator">=</span> getCacheRunnable2(id);</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            pool.execute(cacheRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        redisUtil.unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回旧数据</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li><p>使用Jmeter进行测试 </p><ul><li><p>先来复现一遍场景，当某个用户去Redis中访问缓存的数据时，发现该数据已经过期了，于是新开一个线程去重构缓存数据，但在重构完成之前，用户得到的数据都是旧数据，重构完成之后，才是新数据</p></li><li><p>我把逻辑过期方法作为一个新的请求<code>/cache/&#123;id&#125;</code>,所以先发送一个该请求完成<strong>缓存预热</strong>，过期时间为2分钟，使其快速过期；再使用基于逻辑过期的请求方法查询商户信息</p></li><li><p>之后去数据库把这个数据修改一下，这样逻辑过期前和逻辑过期后的数据就不一致，当用户来访问数据的时候，需要花时间来进行重构缓存数据，但是在重构完成之前，都只能获得脏数据（也就是我们修改前的数据），只有当重构完毕之后，才能获得新数据（我们修改后的数据）  </p></li><li><p>注意：测试线程数不能过大，否则线程池会爆掉</p></li><li><p>结果</p><ul><li>前两分钟逻辑过期值存在，控制台不会输出sql查询；结束后，通过jmeter测试，逻辑缓存时间变为为30分钟，且缓存数据得到修改</li></ul></li></ul></li><li><p>缓存效果图</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/dgj3bwH1LocX7uz.png" alt="img"></p></li><li><p>互斥锁与逻辑过期比较图</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/dgj3bwH1LocX7uz.png" alt="img"></p></li></ol><h3 id="缓存工具类"><a href="#缓存工具类" class="headerlink" title="缓存工具类"></a>缓存工具类</h3><ul><li>对于缓存问题的解决，都是特定情况特定使用，因此会去构建一个缓存工具类来使用</li><li>这里直接贴黑吗代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息w</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="优惠卷秒杀"><a href="#优惠卷秒杀" class="headerlink" title="优惠卷秒杀"></a>优惠卷秒杀</h1><h2 id="Redis实现全局唯一ID"><a href="#Redis实现全局唯一ID" class="headerlink" title="Redis实现全局唯一ID"></a>Redis实现全局唯一ID</h2><h3 id="何为全局唯一ID"><a href="#何为全局唯一ID" class="headerlink" title="何为全局唯一ID"></a>何为全局唯一ID</h3><ul><li>查看文档 “何为全局唯一ID”</li></ul><h3 id="优惠卷介绍"><a href="#优惠卷介绍" class="headerlink" title="优惠卷介绍"></a>优惠卷介绍</h3><ol><li><p>每个店铺都可以发布优惠券</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/8r2BmCj1dcEUbuM.webp" alt="img"></li></ol></li><li><p>当用户抢购时，就会生成订单并保存到<code>tb_voucher_order</code>这张表中，而订单表如果使用数据库自增ID就存在一些问题</p><ol><li>id的规律性太明显</li><li>受单表数据量的限制</li></ol></li><li><p>场景分析</p><ol><li>如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适</li><li>随着我们商城规模越来越大，<strong>mysql</strong>的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性</li></ol></li><li><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具</p></li></ol><h3 id="基于Redis实现全局唯一ID"><a href="#基于Redis实现全局唯一ID" class="headerlink" title="基于Redis实现全局唯一ID"></a>基于Redis实现全局唯一ID</h3><ol><li><p>前提</p></li><li><p>redis的<code>incr命令</code></p><ol><li>Redis的<code>INCR</code>命令是一个用于对存储在Redis键中的整数值进行自增操作的命令；如果目标键不存在，则首先将其初始化为0，然后执行自增操作；此命令返回自增后的值<ol start="2"><li>对于<code>INCR</code>命令，其核心作用是实现对<strong>数字字符串的自增操作</strong>；由于Redis没有专用的整数类型，键对应的字符串在执行<code>INCR</code>命令时会被解释为十进制（64位有符号整数）<ol start="3"><li><code>INCR</code>命令具有<strong>原子性特征</strong>，这意味着在多线程或并发环境下，多个客户端可以同时对同一个键执行INCR命令，而不会出现竞态条件或数据不一致的问题</li></ol></li></ol></li></ol></li><li><p>RedisUtil</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line">    <span class="comment">//原始时间戳BASE_TIME</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1704067200L</span>;</span><br><span class="line">    <span class="comment">//移动的位数bit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">//1生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowEpochSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="comment">//时间差</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowEpochSecond - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2生成序列号</span></span><br><span class="line">        <span class="comment">//2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        <span class="comment">//3拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BIT | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch-信号枪"><a href="#CountDownLatch-信号枪" class="headerlink" title="CountDownLatch 信号枪"></a>CountDownLatch 信号枪</h3><blockquote><p>补充知识，了解即可</p></blockquote><ol><li>主要的作用是同步协调在多线程的等待于唤醒问题</li><li>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</li><li>CountDownLatch 中有两个最重要的方法<ol><li>countDown</li><li>await<ol><li>await方法是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞</li><li>那么什么时候main线程不再阻塞呢？当CountDownLatch 内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch 维护的变量变为0 呢?</li><li>我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间</li></ol></li></ol></li></ol><h2 id="优惠卷"><a href="#优惠卷" class="headerlink" title="优惠卷"></a>优惠卷</h2><h3 id="优惠卷简介"><a href="#优惠卷简介" class="headerlink" title="优惠卷简介"></a>优惠卷简介</h3><ol><li><p>每个店铺都可以发布优惠券，分为平价券和<strong>特价券</strong>。平价券可以任意购买，而特价券需要秒杀抢购</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/L8cAIHxgqzKe9hW.webp" alt="img"></li></ol></li><li><p>优惠卷的表结构信息</p></li><li><ol><li><code>tb_voucher</code> 优惠卷表，主要包含优惠的商家id、优惠卷类型、是否上架、优惠价格、开始、结束时间</li><li><code>tb_seckill_voucher</code>秒杀卷表，主要包含关联的优惠卷id、库存、抢购、结束时间</li></ol></li></ol><h3 id="添加优惠卷"><a href="#添加优惠卷" class="headerlink" title="添加优惠卷"></a>添加优惠卷</h3><h4 id="新增普通优惠卷"><a href="#新增普通优惠卷" class="headerlink" title="新增普通优惠卷"></a>新增普通优惠卷</h4><ol><li><p>前后端请求接口和传输对象</p></li><li><ol><li>Post请求<code>/vocher</code></li><li>传输参数<code>Voucher voucher</code></li></ol></li><li><p>代码实现</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherMapper.insert(voucher);</span><br><span class="line">    <span class="keyword">if</span> (row != SystemConstants.ONE)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新增秒杀优惠卷"><a href="#新增秒杀优惠卷" class="headerlink" title="新增秒杀优惠卷"></a>新增秒杀优惠卷</h4><ol><li><p>前后端请求接口和传输对象</p><ol><li>Post请求<code>/vocher/seckill</code></li><li>传输参数<code>Voucher voucher</code></li><li>存储对象实体<code>SeckillVoucher</code></li></ol></li><li><p>代码逻辑</p><ol><li><p>判断<code>voucher</code>是否为空</p><ol><li><p>是，返回错误信息</p></li><li><p>不是，存入数据库中</p><ol><li>得到优惠卷id，new<code>SeckillVoucher</code>对象保存秒杀卷信息</li><li>存储数据库</li></ol></li><li><p>由于涉及两张表之间的操作</p><ol><li>开启事务注解<code>@Transactional(rollbackFor = Exception.class)</code></li></ol></li></ol></li></ol></li><li><p>具体实现</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (voucher == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    voucherMapper.insert(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherMapper.insert(seckillVoucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>测试<ol><li>由于这里并没有后台管理页面，所以用apifox&#x2F;postman等模拟发送请求来新增秒杀券</li><li>请求路径<code>http://localhost:8081/voucher/seckill</code>， 请求方式POST</li><li>JSON数据如下，注意优惠券的截止日期设置，若优惠券过期，则不会在页面上显示。</li></ol></li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;shopId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;100元代金券&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subTitle&quot;</span><span class="punctuation">:</span><span class="string">&quot;周一至周五可用&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span><span class="string">&quot;全场通用\\n无需预约\\n可无限叠加&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;payValue&quot;</span><span class="punctuation">:</span><span class="number">8000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;actualValue&quot;</span><span class="punctuation">:</span><span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;beginTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2024-06-21T00:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;endTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2024-06-30T23:59:59&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="优惠卷查询"><a href="#优惠卷查询" class="headerlink" title="优惠卷查询"></a>优惠卷查询</h3><ol><li><p>前后端请求接口和传输对象</p><ol><li>GET请求<code>/vocher/list/&#123;shopId&#125;</code></li><li>传输参数<code>Long shopId</code></li></ol></li><li><p>代码实现</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryVoucherOfShop</span><span class="params">(Long shopId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shopId == <span class="literal">null</span> || shopId &lt; SystemConstants.ONE)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据shopId查询优惠卷集合</span></span><br><span class="line">    List&lt;Voucher&gt; vouchers = voucherMapper.queryVoucherOfShop(shopId);</span><br><span class="line">    <span class="keyword">if</span> (vouchers == <span class="literal">null</span> || vouchers.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(vouchers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="秒杀下单"><a href="#秒杀下单" class="headerlink" title="秒杀下单"></a>秒杀下单</h2><h3 id="何为秒杀下单"><a href="#何为秒杀下单" class="headerlink" title="何为秒杀下单"></a>何为秒杀下单</h3><ol><li><p>下单核心思路：当我们点击抢购时，会触发抢购请求</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/F8UDYuExPikIjVv.webp" alt="img"></li></ol></li><li><p>秒杀下单需要考虑的问题</p><ul><li><p>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</p></li><li><p>库存是否充足，不足则无法下单</p></li></ul></li><li><p>下单核心逻辑分析</p></li><li><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息</p></li><li><p>判断是否满足秒杀条件</p></li><li><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束</p></li></ol><h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><ol><li><p>前后端请求接口和传输对象</p><ol><li>Post请求<code>/vocher-order/seckill/&#123;id&#125;</code></li><li>传输参数<code>Long id</code></li></ol></li><li><p>代码逻辑</p><ol><li>优惠卷id判断<ol><li>不可用，返回错误信息</li><li>可用，查询优惠卷信息<ol><li>判断时间状态是否满足<ol><li>不满足，返回错误信息</li><li>满足，判断库存是否足够<ol><li>不足，返回错误信息</li><li>足够，库存-1，并创建优惠卷订单保存到数据库中<ol><li>优惠劵订单id采用<code>RedisUtil</code>的全局唯一id</li><li>返回订单id</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li><p>实际代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">getOrder</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">    <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    stock = stock - <span class="number">1</span>;</span><br><span class="line">    seckillVoucher.setStock(stock);</span><br><span class="line">    seckillVoucherMapper.updateById(seckillVoucher);</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(id);</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(voucherOrder);</span><br><span class="line">    <span class="keyword">if</span> (row != SystemConstants.ONE)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="库存超卖"><a href="#库存超卖" class="headerlink" title="库存超卖"></a>库存超卖</h2><h3 id="库存超卖问题分析"><a href="#库存超卖问题分析" class="headerlink" title="库存超卖问题分析"></a>库存超卖问题分析</h3><ol><li>库存判断代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line"><span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">&#125;</span><br><span class="line">stock = stock - <span class="number">1</span>;</span><br><span class="line">seckillVoucher.setStock(stock);</span><br><span class="line">seckillVoucherMapper.updateById(seckillVoucher);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>分析</p><ol><li><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题</p></li><li><p>分析图<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/mOqj71hNkaIl9BS.webp" alt="img"></p></li></ol></li><li><p>我们之前的代码其实是有问题的，当遇到高并发场景时，会出现超卖现象</p><ol><li>我们可以用<code>Jmeter</code>开200个线程来模拟抢优惠券的场景，URL ：<code>localhost:8081/voucher-order/seckill/13</code>，POST请求</li><li>结果图异常率应在50%左右<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/I5JjWySKV8m9YQr.webp" alt="img"></li><li>秒杀卷库存应为0<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/25zIhH9RDJsBja6.webp" alt="img"></li><li>Redis序列号值应为100</li><li>订单数据应在100</li></ol></li></ol><h3 id="超卖问题解决"><a href="#超卖问题解决" class="headerlink" title="超卖问题解决"></a>超卖问题解决</h3><ol><li><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁；而对于加锁，通常有两种解决方案：</p><ol><li><p>悲观锁</p><ol><li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行</li><li>例如synchronized、Lock都属于悲观锁</li></ol></li><li><p>乐观锁</p><ol><li>认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时丢判断有没有其它线程对数据做了修改</li><li>如果没有修改则认为是安全的，自己才更新数据</li><li>如果已经被其线程修改说明发生了安全问题，此时可以重试或异常</li></ol></li></ol></li><li><p>悲观锁实现</p><ol><li><p>通过<code>Synchronized</code>关键字实现</p><ol><li>直接对抢购方法加锁</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">getOrder</span><span class="params">(Long id)</span> &#123;....&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过synchronized(资源)加锁，更为精确</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">    <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    stock = stock - <span class="number">1</span>;</span><br><span class="line">    seckillVoucher.setStock(stock);</span><br><span class="line">    seckillVoucherMapper.updateById(seckillVoucher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>乐观锁实现</p><ol><li><p>版本号法</p><ol><li>逻辑：每一数据会有一个<strong>版本号</strong>，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过</li><li>黑马课程中并没有对数据表新增一个字段version来进行判断，因为库存stock本身也可用来进行判断是否被修改过；再直接，就是判断库存是否&gt;0即可</li><li>代码逻辑<ol><li>再对库存进行-1时，判断库存是否大于0<ol><li>有，抢购失败</li><li>无，抢购成功</li></ol></li></ol></li><li>实际代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getOrderWithPositive</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键sql</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> seckillVoucherMapper.updateByIdAndStock(seckillVoucher);</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(id);</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(voucherOrder);</span><br><span class="line">    <span class="keyword">if</span> (row != SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.乐观锁实现</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> id<span class="operator">=</span>&quot;updateByIdAndStock&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">update</span> hmdp.tb_seckill_voucher </span><br><span class="line">        <span class="comment">-- 不是用查询到的#&#123;stock&#125;-1,而是本来的stock - 1</span></span><br><span class="line">        <span class="keyword">set</span> stock <span class="operator">=</span> tb_seckill_voucher.stock <span class="operator">-</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="comment">-- 如果判断stock = #&#123;stock&#125;，那么当100个线程判断时只有1个可以完成错误率较高</span></span><br><span class="line">        voucher_id <span class="operator">=</span> #&#123;voucherId&#125; <span class="keyword">and</span> stock <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>时间戳法</p><ol><li>时间戳法实现乐观锁是<strong>在数据表中增加一个时间戳字段，当数据被读取时记录下当前的时间戳，当数据被更新时，检查当前时间戳是否与读取时的时间戳一致</strong>，如果不一致，则说明数据已被其他事务修改，当前事务执行失败</li><li>和版本号法原理一致</li></ol></li><li><p>CAS( Compare And Swap  )自旋法</p></li><li><p>Jmeter测试</p><ol><li>测试结果符合应符合200人100订单，库存为0</li></ol></li></ol><h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><ol><li><p>需求 : 修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p></li><li><p>现在的问题：</p><ol><li>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一单，而不是让一个用户下多单</li><li>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</li><li>流程图<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/6UVt8aApBmqLJoc.webp" alt="img"></li></ol></li></ol></li><li><p>代码逻辑</p><ol><li>Id非空判断</li><li>根据ID查询秒杀卷信息<ol><li>无，返回错误信息</li><li>有，判断开始和结束时间<ol><li>不在范围，返回错误信息</li><li>在范围，判断库存是否满足<ol><li><p>不满足，返回错误信息</p></li><li><p>满足，根据优惠卷id和用户id查询</p><ol><li>已购，返回错误信息</li><li>未购，库存-1，且新增订单</li></ol></li><li><p>返回订单Id</p></li></ol></li></ol></li></ol></li></ol></li><li><p>具体代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">getOrderOnly</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">        <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> voucherOrderMapper.selectByUserIdAndVoucherId(userId,id);</span><br><span class="line">        <span class="keyword">if</span> (voucherOrder != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.ORDER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//库存修改</span></span><br><span class="line">        seckillVoucherMapper.updateByIdAndStock(seckillVoucher);</span><br><span class="line">        <span class="comment">//创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        order.setId(orderId);</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line">        order.setVoucherId(id);</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(order);</span><br><span class="line">        <span class="keyword">if</span> (row != SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>存在问题</strong></p><ol><li><p>高并发时，查询数据库都不存在订单的情况</p></li><li><p>所以我们还是需要加锁，但是<strong>乐观锁比较适合更新数据</strong>，而现在是插入数据，所以我们需要使用悲观锁操作</p></li><li><p>在对悲观锁操作时，需要考虑细粒度问题</p><ol><li>如果直接对整个方法加锁，固然可以实现一人一单</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">getOrderOnly</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">    <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> voucherOrderMapper.selectByUserIdAndVoucherId(userId, id);</span><br><span class="line">    <span class="keyword">if</span> (voucherOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ORDER_ERROR);</span><br><span class="line">    </span><br><span class="line">    seckillVoucherMapper.updateByIdAndStock(seckillVoucher);</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    order.setVoucherId(id);</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(order);</span><br><span class="line">    <span class="keyword">if</span> (row != SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong>是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  Result <span class="title function_">getOrderOnly</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">        <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//只需要对同一个用户的进程进行锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> voucherOrderMapper.</span><br><span class="line">                selectByUserIdAndVoucherId(userId, id);</span><br><span class="line">            <span class="keyword">if</span> (voucherOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(MessageConstants.ORDER_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            seckillVoucherMapper.updateByIdAndStock(seckillVoucher);</span><br><span class="line">            <span class="comment">//创建订单</span></span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">            <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            order.setId(orderId);</span><br><span class="line">            order.setUserId(userId);</span><br><span class="line">            order.setVoucherId(id);</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(order);</span><br><span class="line">            <span class="keyword">if</span> (row != SystemConstants.ONE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>分析</p><ol><li><p>因为一人一单只是防止同一个用户多次获取秒杀卷，所以在对进程加锁时，只需要对同一用户的不同进程加锁</p></li><li><p>他们有着共同的锁资源就是他们的用户ID</p></li><li><p>又因为<code>userId.toString()</code>的对象是new出来的，不能保障共同锁资源，所以资源对象为<code>userId.toString().intern()</code>，这是从字符串常量池中获取用户Id，确保了唯一性</p></li><li><p>源码分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stringSize(i);</span><br><span class="line">    <span class="keyword">if</span> (COMPACT_STRINGS) &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, LATIN1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size * <span class="number">2</span>];</span><br><span class="line">        StringUTF16.getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, UTF16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/DzYkTI5KfyUhQ8B.webp" alt="img"></p></li></ol></li></ol></li></ol></li></ol><h2 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h2><blockquote><p>来源：黑马资料</p></blockquote><h3 id="集群环境模拟"><a href="#集群环境模拟" class="headerlink" title="集群环境模拟"></a>集群环境模拟</h3><ul><li><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了</p></li><li><p>我们将服务启动两份，端口分别为8081和8082：</p><ol><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/dayKHhn1wQkilqY.webp" alt="img"></p></li><li><p>然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/TXO42QwxqrF7ZMP.webp" alt="img"></li></ol></li></ol></li><li><p>后续具体操作，观看黑马视频</p></li></ul><h3 id="有关锁失效原因分析"><a href="#有关锁失效原因分析" class="headerlink" title="有关锁失效原因分析"></a>有关锁失效原因分析</h3><ul><li>由于现在我们部署了多个tomcat，每个tomcat都有一个<strong>属于自己的jvm</strong>，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的</li><li>但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥</li><li>这就是集群环境下，synchronized锁失效的原因(基于JVM内存实现)，在这种情况下，我们就需要使用<strong>分布式锁</strong>来解决这个问题</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/GVv4HNpIJlWXyDj.webp" alt="img"></li></ul><hr><h1 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h1><h2 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h2><blockquote><p>在黑马的“苍穹外卖中”通过百度地图的api调用来完成对地理位置的判断</p><p>MongoDB、Elasticsearch等技术均可实现GEO</p><p>三者的比较<code>https://blog.csdn.net/u014401141/article/details/134646577</code></p></blockquote><ol><li><code>GEO</code>就是Geolocation的简写，代表地理坐标</li><li>Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据</li><li>常见的命令有<ul><li><code>GEOADD</code>添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li><code>GEODIST</code>计算指定的两个点之间的距离并返回</li><li><code>GEOHASH</code>将指定<code>member</code>的坐标转为hash字符串形式并返回</li><li><code>GEOPOS</code>返回指定member的坐标</li><li><code>GEORADIUS</code>指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回；6.2版本以后已废弃</li><li><code>GEOSEARCH</code>在指定范围内搜索<code>member</code>，并按照与指定点之间的距离排序后返回；范围可以是圆形或矩；6.2.新功能</li><li><code>GEOSEARCHSTORE</code>与<code>GEOSEARCH</code>功能一致，不过可以把结果存储到一个指定的key；6.2.新功能</li></ul></li></ol><h2 id="导入店铺数据到GEO"><a href="#导入店铺数据到GEO" class="headerlink" title="导入店铺数据到GEO"></a>导入店铺数据到GEO</h2><ol><li>需求<ol><li>将数据库表中的数据导入到Redis中的GEO去</li><li>GEO在Redis中就一个menber和一个经纬度，我们把x和y轴传入到Redis做的经纬度位置，但不能把所有的数据都放入到member</li><li>Redis作为一个内存级数据库，如果存海量数据，Redis还是力不从心，所以在这个地方存储他的商家id即可</li><li>还有一个问题，就是在Redis中并没有存储type，无法根据type来对数据进行筛选；所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以<code>typeId</code>为key存入同一个GEO集合中即可</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/ThWJZilfkvMeLyD.png" alt="img" style="zoom:50%;" /></li></ol></li><li>代码编写<ol><li>在<code>HmDianPingApplicationTests</code>测试类完成对商户数据的导入</li><li>Stream流的使用根据商户类型id分组，得到特定的<code>List&lt;Shop&gt;</code>集合</li><li>具体代码如下</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()),    shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>成功示例<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/BCQlSUaI91NHFyX.png" alt="img"></li></ol></li></ol><h2 id="实现附近商户搜索功能"><a href="#实现附近商户搜索功能" class="headerlink" title="实现附近商户搜索功能"></a>实现附近商户搜索功能</h2><ol><li><p>版本修改</p><ul><li>SpringDataRedis的 2.3.9 版本并不支持Redis 6.2 提供的<code>GEOSEARCH</code>命令，需要修改版本</li><li>修改pom文件如下</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-data-redis&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lettuce-core&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>具体场景说明</p><ul><li>当点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式</li><li>此时关注的是距离，这个地方就需要使用到GEO，向后台传入当前app收集的地址(此处前端是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的商户数据再返回</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/K1btmcF8uJPN7Dp.png" alt="img" style="zoom:50%;" /></li></ul></li><li><p>依照上图修改<code>ShopController代码</code></p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据商铺类型分页查询商铺信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> current 当前页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeId 类型Id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y 纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 商铺列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据类型分页查询</span></span><br><span class="line">    <span class="keyword">return</span> shopService.typeOfPage(typeId,current,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>业务代码实现，由于涉及到许多不常用api的调用，这里直接导入黑马代码再做修改<ol><li>查询到的是<code>&lt;ShopId,distance&gt;</code>，对其解析和封装</li><li>逻辑分页的实现，<code>Map</code>、<code>List</code>集合的使用</li><li>需要返回的是包含<code>distance</code>信息的商户集合</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">typeOfPage</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要根据坐标查询</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">        PageHelper.startPage(current, SystemConstants.MAX_PAGE_SIZE);</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>().setTypeId(Long.valueOf(typeId));</span><br><span class="line">        Page&lt;Shop&gt; page = shopMapper.pageQuery(shop);</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.PAGE_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Shop&gt; pageResult = page.getResult();</span><br><span class="line">        <span class="keyword">if</span> (pageResult.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(pageResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算分页参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">    <span class="comment">// 查询redis、按照距离排序、分页；结果：shopId、distance</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.SHOP_GEO_KEY + typeId;</span><br><span class="line">    <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 5 WITHDISTANCE</span></span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo()</span><br><span class="line">            .radius(</span><br><span class="line">            key,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Circle</span>(x, y, <span class="number">10000</span>),</span><br><span class="line">            <span class="comment">//从一开始返回end个数据</span></span><br><span class="line">            RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().limit(end)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 解析出id</span></span><br><span class="line">    <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是返回Zset中的数据</span></span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">    <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">        <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 截取 from ~ end的部分</span></span><br><span class="line">    <span class="comment">//查询到的商户id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">    <span class="comment">//每一个商户ID对应的距离map</span></span><br><span class="line">    Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">    <span class="comment">//将前from个数据跳过</span></span><br><span class="line">    list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取店铺id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">        ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">        <span class="comment">// 获取距离</span></span><br><span class="line">        distanceMap.put(shopIdStr, result.getDistance());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 根据id查询Shop</span></span><br><span class="line">    List&lt;Shop&gt; shops = shopMapper.selectByIds(ids);</span><br><span class="line">    <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">        <span class="comment">//根据id获取对应距离</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> shop.getId().toString();</span><br><span class="line">        shop.setDistance(distanceMap.get(idStr).getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>示例<ol><li>由于Redis版本为5.x，无法使用GEOSEARCH，无法显示距离值</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/s6VtWB15UfQNk4p.png" alt="img"></li></ol></li></ol><hr><h1 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h1><h2 id="Redis-BitMap-位图-功能"><a href="#Redis-BitMap-位图-功能" class="headerlink" title="Redis-BitMap(位图)功能"></a>Redis-BitMap(位图)功能</h2><h3 id="为何使用BitMap"><a href="#为何使用BitMap" class="headerlink" title="为何使用BitMap"></a>为何使用BitMap</h3><ul><li><p>针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/ZvRdbJB3MPfT5oC.png" alt="img"></li><li>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</li><li>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</li></ul></li><li><p><strong>如何解决这个问题？</strong></p><ul><li><p>其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看你在当天是否有打勾</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/bkmguLt5KiyxdVX.png" alt="img" style="zoom:50%;" /></li><li><p>可以采用类似这样的方案来实现我们的签到需求，而Redis的BitMap恰好可以实现按月来统计用户签到信息，签到记录为1，未签到则记录为0</p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/gSw9XfQOMN1ZAmq.png" alt="img"></p></li><li><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）这样就用极小的空间，来实现了大量数据的表示</p></li></ul></li></ul></li></ul></li><li><p>Redis中是利用String类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位</p></li></ul><h3 id="BitMap的操作命令"><a href="#BitMap的操作命令" class="headerlink" title="BitMap的操作命令"></a>BitMap的操作命令</h3><ul><li><code>SETBIT</code>：向指定位置（offset）存入一个0或1</li><li><code>GETBIT </code>：获取指定位置（offset）的bit值</li><li><code>BITCOUNT</code> ：统计BitMap中值为1的bit位的数量</li><li><code>BITFIELD</code> ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值（一般都用作查询）</li><li><code>BITFIELD_RO</code> ：获取BitMap中bit数组，并以十进制形式返回</li><li><code>BITOP</code> ：将多个BitMap的结果做位运算（与 、或、异或）</li><li><code>BITPOS</code>：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h2 id="实现用户签到功能"><a href="#实现用户签到功能" class="headerlink" title="实现用户签到功能"></a>实现用户签到功能</h2><ol><li>需求<ul><li>实现签到接口，将当前用户当天签到信息保存到Redis中</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/6wkTK9svhFqYouW.png" alt="img" style="zoom:50%;" /></li></ul></li><li>思路<ul><li>我们可以把年和月作为<code>bitMap</code>的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到</li><li>通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改<code>bitMap</code></li></ul></li><li>代码如下</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户数据</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">if</span> (userDTO == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.LOGIN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> userDTO.getId();</span><br><span class="line">    <span class="comment">//当天日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyy-MM&quot;</span>).format(now);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">//当天在该月第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h2><ol><li><p>什么叫做连续签到天数？</p><ul><li>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数</li></ul></li><li><p>Java逻辑代码</p><ul><li>获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</li></ul></li><li><p>如何得到本月到今天为止的所有签到数据？</p><ul><li>命令<code>  BITFIELD key GET u[dayOfMonth] 0</code></li><li>假设今天是10号，那么从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位；去拿这段时间的数据，就能拿到所有的数据了</li></ul></li><li><p>那么这10天里边签到了多少次呢？</p><ul><li>统计有多少个1即可</li></ul></li><li><p>如何从后向前遍历每个bit位？</p><ul><li><code>bitMap</code>返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做<strong>与运算</strong>就可以了</li><li>因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行<strong>与</strong>操作，每与一次，就把签到结果<strong>向右移</strong>动一位，依次内推，就能完成逐个遍历的效果了</li></ul></li><li><p>需求</p><ol><li>实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/Azuv8UpeX3DYrJB.png" alt="img" style="zoom:50%;" /></li></ol></li><li><p>代码逻辑</p><ol><li>与签到功能一样得到用户id、key、dateOfMonth<ol><li>根据key获取bitMap数据<ol><li>通过&amp;和&gt;得到连续签到次数count</li><li>返回count</li></ol></li></ol></li></ol></li><li><p>具体代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户数据</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">if</span> (userDTO == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.LOGIN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> userDTO.getId();</span><br><span class="line">    <span class="comment">//当天日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyy-MM&quot;</span>).format(now);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">//当天在该月第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">//获取bitMap数据</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue()</span><br><span class="line">        .bitField(key, BitFieldSubCommands.create()                                           .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sign</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sign &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        sign = sign &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用bitmap来解决缓存穿透的方案"><a href="#使用bitmap来解决缓存穿透的方案" class="headerlink" title="使用bitmap来解决缓存穿透的方案"></a>使用bitmap来解决缓存穿透的方案</h2><blockquote><p>值得一提的是布隆过滤器底层就是基于BitMap</p></blockquote><ol><li><p>回顾<strong>缓存穿透</strong></p><ol><li>客户端发起了一个数据库不存在，Redis里边也不存在的数据</li><li>通常你可以把这种行为看成一个攻击</li></ol></li><li><p>解决方案</p><ol><li>判断id&lt;0</li><li>缓存空数据</li></ol></li><li><p>问题</p><ul><li>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</li><li>第二种解决方案：如果是不同的id那下次过来依然直击数据</li></ul></li><li><p>如何解决呢？</p><ul><li>将数据库中的ID写入List集合中</li><li>每一次查询判断id是否在集合中<ul><li>不在，直接返回</li><li>在，放行</li></ul></li></ul></li><li><p>新的问题是这个主键很长，占用内存</p><ol><li>所以如果采用以上方案，这个List也会很大，所以我们可以使用<code>bitmap</code>来减少List的存储空间</li></ol></li><li><p>内存问题的解决</p><ol><li>可以把list数据抽象成一个非常大的<code>bitmap</code>，不再使用list，而是将db中的id数据利用哈希思想</li><li>例如<ol><li>id % <code>bitmap.size</code>  &#x3D; xx 算出当前这个id应该落在<code>bitmap</code>的哪个索引上，然后将这个值从0变成1</li><li>然后当用户来查询数据时，此时已经没有了List，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在<code>bitmap</code>的哪一位</li><li>然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在</li><li>采用这种方式来处理，需要重点考虑一个事情，就是误差率（指当发生哈希冲突的时候，产生的误差）</li><li>是不是很熟悉，就是布隆过滤器的原理</li></ol></li></ol></li></ol><hr><h1 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h1><h2 id="HyperLogLog概率统计算法"><a href="#HyperLogLog概率统计算法" class="headerlink" title="HyperLogLog概率统计算法"></a>HyperLogLog概率统计算法</h2><blockquote><p>这里主要理解何为HyperLogLog和LogLog统计算法以及有何应用</p><p><code>https://juejin.cn/post/6844903785744056333#heading-0</code>很好的解释</p></blockquote><ol><li><p>首先搞懂两个概念</p><ol><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量</li></ol></li><li><p>通常来说UV会比PV大很多，所以衡量一个网站的访问量，需要综合考虑很多因素；所以我们只是单纯的把这两个值作为一个参考值</p></li><li><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p></li><li><p><strong>Hyperloglog(HLL)<strong>是从</strong>Loglog</strong>算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理可以参考</p><ol><li><code>https://juejin.cn/post/6844903785744056333#heading-0</code>写的很好</li></ol></li><li><p>Redis中的HLL是基于String结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 黑马学习课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Remove-generated-files-and-cache"><a href="#Remove-generated-files-and-cache" class="headerlink" title="Remove generated files and cache"></a>Remove generated files and cache</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
