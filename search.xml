<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用操作</title>
      <link href="/cn/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/cn/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul><li>解压下载的<code>.tar.gz</code>格式的文件</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf filename.tar.gz -C 文件保存目录(默认保存在当前目录)</span><br></pre></td></tr></table></figure><ul><li>文件&#x2F;文件夹处理</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件</span></span><br><span class="line">touch 文件名(默认当前工作目录)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件夹</span></span><br><span class="line">mkdir 文件夹名(默认当前工作目录)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> 移动文件</span></span><br><span class="line">mv 文件/目录 放置目录</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制文件</span></span><br><span class="line">cp 原始文件 复制的文件放置路径</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除文件</span></span><br><span class="line">rm -f 文件路径</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除文件夹</span></span><br><span class="line">rm -rf 文件夹路径</span><br></pre></td></tr></table></figure><ul><li>端口占用处理</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看占用该端口的进程</span></span><br><span class="line">lsof -i :端口号</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制终止进程</span></span><br><span class="line">kill -9 PID</span><br></pre></td></tr></table></figure><h2 id="Linux常用操作"><a href="#Linux常用操作" class="headerlink" title="Linux常用操作"></a>Linux常用操作</h2><h3 id="jdk环境、项目部署"><a href="#jdk环境、项目部署" class="headerlink" title="jdk环境、项目部署"></a>jdk环境、项目部署</h3><ul><li>配置JDK环境变量<ol><li>确保JDK的安装路径：<code>/home/ubuntu/application/jdk</code></li><li>打开配置文件<ol><li><code>vim /etc/profile</code> </li><li>修改系统配置，需要管理员（root）权限</li><li>对所用用户生效</li></ol></li><li>添加配置<ol><li><code>export JAVA_HOME=/home/ubuntu/application/jdk/具体jdk解压后的目录名</code></li><li><code>export PATH=$JAVA_HOME/bin:$PATH</code></li></ol></li><li>配置生效<ol><li><code>source /etc/profile</code></li></ol></li><li>验证<ol><li><code>java --version</code></li></ol></li></ol></li></ul><hr><ul><li>简单部署SpringBoot项目<ol><li>获取项目<code>.jar</code>包，上传至工作目录</li><li>运行：<code>java -jar /home/ubuntu/workpace/my_project.jar</code></li></ol></li></ul><hr><ul><li>docker容器化部署SpringBoot项目<ol><li>上传<code>docker-demo.jar</code>至工作目录</li><li>在该目录下创建dockerfile：<code>touch Dockerfile</code></li><li>对Dockerfile文件配置<ol><li><code>vim Dockerfile</code> </li><li>配置如下：</li></ol></li></ol></li></ul><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><pre><code>4. 构建镜像：`docker build -t docker-demo:1.0.0 dockerfile所在目录`5. 查看镜像列表`docker images`6.创建并运行容器</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name docker-demo -p 8080:8080 -d docker-demo:1.0.0</span><br></pre></td></tr></table></figure><pre><code>7.查看容器：`docker ps -a`</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>媒体资源管理</title>
      <link href="/cn/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86/"/>
      <url>/cn/%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要是实现服务端如何完成资源的上传以及后续管理</p></blockquote><h1 id="媒资管理"><a href="#媒资管理" class="headerlink" title="媒资管理"></a>媒资管理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>何为媒资：</p><ul><li>媒体资源管理(Media Asset Management，MAM)系统是建立在多媒体、网络、数据库和数字存储等先进技术基础上的一个对各种媒体及内容(如视&#x2F;音频资料、文本文件、图表等)进行数字化存储、管理以及应用的总体解决方案，包括数字媒体的采集、编目、管理、传输和编码转换等所有环节</li><li>其主要是满足媒体资源拥有者收集、保存、查找、编辑、发布各种信息的要求，为媒体资源的使用者提供访问内容的便捷方法，实现对媒体资源的高效管理，大幅度提高媒体资源的价值</li></ul><p>媒资管理的主要管理对象：</p><ul><li>视频、图片、文档、音乐等</li></ul><p>媒资的主要的几个功能如下：</p><ul><li>媒资查询：查询自己所拥有的的媒资信息</li><li>文件上传：包括上传图片、上传文档、上传视频（重要）</li><li>视频处理：视频上传成功，系统自动对视频进行编码处理（重要）</li><li>文件删除：删除自己上传的媒资文件</li></ul><p>很重要的一个问题是媒资到底上传到哪里去？用户如何快速访问？这些可以通过分布式文件系统解决。</p><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><h3 id="什么是分布式文件系统"><a href="#什么是分布式文件系统" class="headerlink" title="什么是分布式文件系统"></a>什么是分布式文件系统</h3><blockquote><p>可以简单理解其功能就是上传媒体资源，进行存储</p></blockquote><p>文件系统的定义：</p><ul><li>操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统</li><li>操作系统通过文件系统提供的接口去存取文件，用户通过操作系统访问磁盘上的文件</li><li>常见的文件系统：FAT16&#x2F;FAT32、NTFS、HFS、UFS、APFS、XFS、Ext4等</li></ul><p>一些短视频平台(bilibili)拥有大量的视频、图片，这些视频文件、图片文件该如何存储呢？如何存储可以满足互联网上海量用户的浏览呢？</p><ul><li>即答：<strong>分布式文件系统</strong>就是海量用户访问海量文件的方案</li></ul><p>分布式文件系统：可以简单的理解为，一个计算机无法存储海量的文件，通过网络将若干计算机组织起来共同去存储海量的文件，去接收海量用户的请求，这些组织起来的计算机通过计算机网络通信</p><ul><li>这样做的好处<ol><li>一台计算机的文件系统处理能力扩充到多台计算机同时处理</li><li>一台计算机挂了， 还有另外副本计算机提供数据</li><li>每台计算机可以放在不同的地域，用户可以就近访问，提高访问速度</li></ol></li></ul><h3 id="分布式文件系统的产品"><a href="#分布式文件系统的产品" class="headerlink" title="分布式文件系统的产品"></a>分布式文件系统的产品</h3><ol><li>NFS</li><li>GFS</li><li>HDFS</li><li>云计算厂家<ul><li>阿里云对象存储服务（Object Storage Service，简称 OSS）<ul><li><a href="https://www.aliyun.com/product/oss">官方网站</a></li></ul></li><li>百度对象存储BOS<ul><li><a href="https://cloud.baidu.com/product/bos.html">官方网站</a></li></ul></li></ul></li></ol><h3 id="MinIO"><a href="#MinIO" class="headerlink" title="MinIO"></a>MinIO</h3><p>MinIO是一个轻量的服务，可以用来构建分布式文件系统。其兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等，提供了Java、Python、GO等多版本SDK支持。</p><ul><li><a href="https://min.io/%EF%BC%8C">官网</a></li><li><a href="https://www.minio.org.cn/">官网-中文</a></li></ul><p> MinIO采用去中心化共享架构，每个节点是对等关系，通过Nginx可对MinIO进行负载均衡访问</p><ul><li>去中心化有什么好处？<ul><li>在大数据领域，通常的设计理念都是无中心和分布式。MinIO分布式模式可以帮助你搭建一个高可用的对象存储服务，你可以使用这些存储设备，而不用考虑其真实物理位置</li></ul></li></ul><p>MinIO将分布在不同服务器上的多块硬盘组成一个对象存储服务。由于硬盘分布在不同的节点上，分布式MinIO避免了单点故障</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/06/8h2TK47lb3YBLDU.png" alt="MinIO存储服务"></p><ul><li>MinIO使用<em><strong>纠删码技术</strong></em>来保护数据，它是一种恢复丢失和损坏数据的数学算法。上图由8块硬盘组成一个集合，当上传一个文件时，会通过纠删码算法计算对文件进行<em><strong>分块存储</strong></em>，除了将文件本身分成4个数据块，还会生成4个校验块，数据块和校验开会分散的存储在这8块硬盘上</li><li>即便丢失一半数量(N&#x2F;2)的硬盘，仍可以恢复数据。例如上面集合中有4个以内的硬盘损害，仍可保证数据恢复，不影响上传和下载</li></ul><h4 id="搭建MinIO"><a href="#搭建MinIO" class="headerlink" title="搭建MinIO"></a>搭建MinIO</h4><p>不用想复杂，其实就是搭建一个类似于阿里云OSS的云存储服务，不过多了一步部署MinIO。甚至使用基本都是一致，部署MinIO–创建Bucket–上传资源到Bucket–生成URL。而其中的API调用通过查看官网的使用文档即可。</p><ol><li>首先，下载MinIO<ol><li><code>https://dl.min.io/server/minio/release/</code></li></ol></li><li>然后，通过多个节点构建一个分布式的服务<ol><li>部署完成后，访问<code>ip:9000</code>进行登录</li><li>默认账号密码均为<code>minioadmin</code></li></ol></li><li>在其提供UI界面中，可以创建bucket，完成资源的上传、预览、删除等</li><li>最后，就是JAVA SDK的使用<ol><li><a href="https://docs.min.io/docs/java-client-quickstart-guide.html">文档链接</a></li></ol></li></ol><p>具体操作：</p><ul><li>在工程中添加依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>在官方文档中需要三个参数才能连接到minio服务</li></ul><table><thead><tr><th align="center">Parameters</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">Endpoint</td><td align="center">S3 服务的 URL</td></tr><tr><td align="center">Access Key</td><td align="center">服务中账户的访问密钥（也称为用户 ID）</td></tr><tr><td align="center">Secret Key</td><td align="center">服务中账户的密钥（又名密码）<br></td></tr></tbody></table><ul><li>官方给出的基本文档<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> &#123;  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  </span><br><span class="line">      <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, InvalidKeyException &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;   </span><br><span class="line">      <span class="comment">// 创建MinIO客户端，连接参数就是上述表格中的三个参数，ip:9000、minioadmin、minioadmin  </span></span><br><span class="line">      <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span>  </span><br><span class="line">          MinioClient.builder()  </span><br><span class="line">              .endpoint(<span class="string">&quot;https://play.min.io&quot;</span>)  </span><br><span class="line">              .credentials(<span class="string">&quot;Q3AM3UQ867SPQQA43P2F&quot;</span>, <span class="string">&quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;</span>)  </span><br><span class="line">              .build();  </span><br><span class="line">      <span class="comment">// 判断Bucket存不存在</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span>  minioClient.bucketExists(BucketExistsArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());</span><br><span class="line">      <span class="keyword">if</span> (!found) &#123;  </span><br><span class="line">        <span class="comment">//创建一个Bucket asiatrip</span></span><br><span class="line">  minioClient.makeBucket(MakeBucketArgs.builder().bucket(<span class="string">&quot;asiatrip&quot;</span>).build());  </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 将 &#x27;/home/user/Photos/asiaphotos.zip&#x27; 文件命名为 &#x27;asiaphotos-2015.zip&#x27;  </span></span><br><span class="line">      <span class="comment">// 并上传到 &#x27;asiatrip&#x27; 里（示例代码创建的bucket）  </span></span><br><span class="line">      minioClient.uploadObject(  </span><br><span class="line">          UploadObjectArgs.builder()  </span><br><span class="line">              .bucket(<span class="string">&quot;asiatrip&quot;</span>)  </span><br><span class="line">              .object(<span class="string">&quot;asiaphotos-2015.zip&quot;</span>)  </span><br><span class="line">              .filename(<span class="string">&quot;/home/user/Photos/asiaphotos.zip&quot;</span>)  </span><br><span class="line">              .build());  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (MinioException e) &#123;  </span><br><span class="line">      System.out.println(<span class="string">&quot;Error occurred: &quot;</span> + e);  </span><br><span class="line">      System.out.println(<span class="string">&quot;HTTP trace: &quot;</span> + e.httpTrace());  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在给出的文档中，我们在service调用后，拿到访问链接，再保存到数据库中</li></ul><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><blockquote><p>之前的苍穹外卖项目都是图片的上传，但是大文件、视频的话，该如何上传确保服务呢？</p></blockquote><h3 id="什么是断点续传"><a href="#什么是断点续传" class="headerlink" title="什么是断点续传"></a>什么是断点续传</h3><ul><li>通常视频文件都比较大，所以对于媒资系统要满足大文件的上传需求。HTTP协议本身对上传文件大小没有限制，但是客户的网络环境之类、电脑硬件环境等参差不齐，如果一个大文件快上传完了，但是突然断网了，没有上传完成，需要客户重新上传，那么用户体验就非常差。所以对于大文件上传的最基本要求就是<strong>断点续传</strong>。</li><li>简单理解：把较大的文件按“块”（小文件）的大小进行分块，最后合成大文件</li><li>思路如下：<ol><li>前端上传前先把文件分成块</li><li>一块一块的上传，上传中断后重新上传。已上传的分块则不用再上传</li><li>各分块上传完成后，在服务端合并文件</li></ol></li><li>文件分块的流程：<ol><li>获取源文件长度</li><li>根据设定的分块文件大小，计算出块数（向上取整，例如33.4M的文件，块大小为1M，则需要34块）</li><li>从源文件读取数据，并依次向每一个块文件写数据</li></ol></li><li>文件合并的流程：<ol><li>找到要合并的文件并按文件分块的先后顺序排序</li><li>创建合并文件</li><li>依次从分块文件中读取数据，再向合并文件写入数据</li></ol></li><li>补充，文件的md5：<ul><li>一种哈希算法，‌用于对文件进行验证和完整性检查</li></ul></li></ul><h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><blockquote><p>在以前图片上传之后无需过多处理，拿到图片链接使用即可，可是视频该办呢？</p></blockquote><h3 id="讲讲视频编码"><a href="#讲讲视频编码" class="headerlink" title="讲讲视频编码"></a>讲讲视频编码</h3><ul><li>视频上传成功后，需要对视频进行<strong>转码</strong>处理</li><li>什么是视频编码？定义如下：<ul><li>所谓视频编码方式就是指通过压缩技术，将原始视频格式的文件转换成另一种视频格式文件的方式。视频流传输中最为重要的编解码标准有国际电联的H.261、H.263、H.264，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，此外在互联网上被广泛应用的还有Real-Networks的RealVideo、微软公司的WMV以及Apple公司的QuickTime等。</li></ul></li><li>首先我们要分清文件格式和编码格式<ul><li><code>文件格式</code>是指：<code>.mp4</code>、<code>.avi</code>、<code>.rmvb</code>等这些不同扩展名的视频文件的文件格式。视频文件的内容主要包括视频、音频，其文件格式是按照一定的编码格式去编码，并且按照该文件所规定的封装格式，将视频、音频、字幕等信息封装到一起，播放器会根据他们的封装格式去提取出编码，然后由播放器解码，最终播放音视频</li><li><code>编码格式</code>是指：通过音视频的压缩技术，将视频格式转换成另一种视频格式，通过视频编码实现流媒体的传输。比如一个.avi的视频文件原来的编码是a，通过编码后编码格式变为b</li></ul></li><li>音视频编码格式种类繁多，主要由以下几类<ul><li><code>MPEG系列</code>（由ISO下属的MPEG开发）<ul><li>视频编码方面主要是Mpeg1（VCD）、Mpeg2（DVD）、Mpeg4（divx，xvid）、Mpeg4 AVC</li><li>音频编码方面主要是MPEG Audio Layer 1&#x2F;2、MPEG Audio Layer 3（MP3）、MPEG-2 AAC 、MPEG-4 AAC</li></ul></li><li><code>H.26X系列</code>（由ITU主导，侧重网络传输，注意：只是视频编码）<ul><li>包括H.261、H.262、H.263、H.263+、H.263++、H.264</li></ul></li></ul></li><li>目前最常用的编码标准是<ul><li>视频：H.264</li><li>音频：AAC</li></ul></li></ul><h3 id="基于FFmpeg实现转码"><a href="#基于FFmpeg实现转码" class="headerlink" title="基于FFmpeg实现转码"></a>基于FFmpeg实现转码</h3><ul><li>什么是FFmpeg？<ul><li>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序</li><li>提供录制、转换以及流式传输音视频的完整解决方案</li><li>它包含了非常先进的音频&#x2F;视频编解码库libavcodec</li><li>支持多环境，其编码库可以使用GPU加速</li></ul></li><li>下载<ul><li><a href="https://www.ffmpeg.org/download.html#build-windows">FFmpeg</a>，并将其bin目录加入环境变量</li></ul></li><li>测试是否正常：<code>ffmpeg -version</code></li><li>安装成功后，做一下简单测试，将.mp4文件转为.avi，再将.avi转为.gif等<ul><li><code>ffmpeg -i xx.mp4 xx.avi</code></li><li><code>ffmpeg -i xx.avi xx.gif</code></li></ul></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/06/glepT1EqDvSY7w5.jpg" alt="转换结果"></li><li>在项目中一般基于FFmpeg创建工具类，来完成对视频的转码，然后上传</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JSR-303规范</title>
      <link href="/cn/JSR303/"/>
      <url>/cn/JSR303/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据校验的好处母庸置疑，因为黑马的《学成在线》项目用到了参数校验的规范-<code>JSR-303</code>，所以这里记录一下<br>官网 : <code>https://beanvalidation.org/</code></p></blockquote><h3 id="一、何为JSR-303规范"><a href="#一、何为JSR-303规范" class="headerlink" title="一、何为JSR-303规范"></a>一、何为JSR-303规范</h3><p>JSR-303是一套在Java EE和Java SE中用于JavaBean验证的Java API规范。这项工作的技术目标是为Java应用程序开发人员提供类级约束声明和验证工具，以及约束元数据存储库和查询API。<br>人话就是：JSR-303提供了一套通过注解的方式实现对JavaBean的属性进行验证</p><p>截止到目前为止，bean validation规范已经更新到了1.1(JSR-349), 2.0(JSR-380)，3.0 等版本，不过升级后的版本，仅仅是添加了若干注解而已，核心内容都未变动<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/05/3Y8f7sZpAxBuRDg.png" alt="版本对比图"></p><h3 id="二、实现JSR-303规范"><a href="#二、实现JSR-303规范" class="headerlink" title="二、实现JSR-303规范"></a>二、实现JSR-303规范</h3><p><code>SpringBoot</code>提供了<code>JSR-303</code>的支持，它就是<code>spring-boot-stater-validation</code>，它的底层使用<code>Hibernate Validation</code>，<code>Hibernate Validation</code>是<code>Bean Validation</code>的参考实现。</p><blockquote><p>Hibernate Validation是一种用于Java对象验证的框架，‌它允许开发者在对象的属性上<strong>添加注解</strong>，‌以定义验证规则，‌确保对象的状态满足特定的业务规则</p></blockquote><p>首先，引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，对添加课程信息接口进行校验</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;新增课程基础信息接口&quot;)</span>  </span><br><span class="line"><span class="meta">@PostMapping(&quot;/course&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> CourseBaseInfoDto <span class="title function_">createCourseBase</span><span class="params">(<span class="meta">@RequestBody</span> AddCourseDto addCourseDto)</span> &#123;  </span><br><span class="line">    <span class="comment">// 机构id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">companyId</span> <span class="operator">=</span> <span class="number">22L</span>;  </span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.createCourseBase(companyId, addCourseDto);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该接口中，通过AddCourseDto接收参数，于是对该bean属性添加校验规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="meta">@ApiModel(value = &quot;AddCourseDto&quot;, description = &quot;新增课程基本信息&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddCourseDto</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;课程名称不能为空&quot;)</span>  </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程名称&quot;, required = true)</span>  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;适用人群不能为空&quot;)</span>  </span><br><span class="line">    <span class="meta">@Size(min = 10, message = &quot;适用人群内容过少，至少10个字符&quot;)</span>  </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;适用人群&quot;, required = true)</span>  </span><br><span class="line">    <span class="keyword">private</span> String users;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程介绍&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String description;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;课程图片&quot;, required = true)</span>  </span><br><span class="line">    <span class="keyword">private</span> String pic;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;收费规则不能为空&quot;)</span>  </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;收费规则，对应数据字典&quot;, required = true)</span>  </span><br><span class="line">    <span class="keyword">private</span> String charge;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;原价&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> Float originalPrice;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>其中用到了<code>@NotEmpty</code>和<code>@Size</code>两个注解，<code>@NotEmpty</code>表示属性不能为空，<code>@Size</code>表示限制属性内容的长度，其中的message是异常返回的信息</p></li><li><p>还有很多其他注解，比如说：</p><ul><li><code>@NULL</code>，要求属性为空</li><li><code>@NotNull</code>，要求属性不为空</li><li><code>@NotBlank</code>，要求字符串不为空，在比较时会去除字符串的空格</li><li>……</li></ul></li><li><p>如果注解报错，检查Spring Boot的版本</p></li></ul><p>最后，定义好了校验规则还需要在Controller方法中添加<code>@Validated</code>注解开启校验，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;新增课程基础信息接口&quot;)</span>  </span><br><span class="line"><span class="meta">@PostMapping(&quot;/course&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> CourseBaseInfoDto <span class="title function_">createCourseBase</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> AddCourseDto addCourseDto)</span> &#123;  </span><br><span class="line">    <span class="comment">// 机构id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">companyId</span> <span class="operator">=</span> <span class="number">22L</span>;  </span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.createCourseBase(companyId, addCourseDto);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果校验出错，Spring会抛出<code>MethodArgumentNotValidException</code>异常，我们在全局异常处理器中捕获异常，解析出异常即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span>  </span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">doMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException exception)</span> &#123;  </span><br><span class="line">    <span class="comment">// 由于用户输入的内容可能存在多处错误，所以我们要将所有错误信息都提示给用户  </span></span><br><span class="line">    <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> exception.getBindingResult();  </span><br><span class="line">    <span class="comment">// 获取错误集合  </span></span><br><span class="line">    List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors();  </span><br><span class="line">    <span class="comment">// 拼接字符串  </span></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">    fieldErrors.forEach(fieldError -&gt; stringBuffer.append(fieldError.getDefaultMessage()).append(<span class="string">&quot;,&quot;</span>));  </span><br><span class="line">    <span class="comment">// 记录日志  </span></span><br><span class="line">    log.error(stringBuffer.toString());  </span><br><span class="line">    <span class="comment">// 响应给用户  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(stringBuffer.toString());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，将必填项设置为空，适用人群设置小于10个字，响应结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST http<span class="punctuation">:</span><span class="comment">//localhost:53040/content/course  </span></span><br><span class="line">  </span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">500</span>   </span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json  </span><br><span class="line">Transfer-Encoding<span class="punctuation">:</span> chunked  </span><br><span class="line">Date<span class="punctuation">:</span> Fri<span class="punctuation">,</span> <span class="number">03</span> Feb <span class="number">2023</span> <span class="number">04</span><span class="punctuation">:</span><span class="number">52</span><span class="punctuation">:</span><span class="number">30</span> GMT  </span><br><span class="line">Connection<span class="punctuation">:</span> close  </span><br><span class="line">  </span><br><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;errMessage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;课程名称不能为空,适用人群内容过少，至少10个字符,&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="三、分组校验"><a href="#三、分组校验" class="headerlink" title="三、分组校验"></a>三、分组校验</h3><p>有一个问题：订单标号是由系统生成，所以在添加订单时，要求订单编号为空；但是在更新订单时，要求订单编号不能为空。于是，在同一个属性上设置一个校验规则不能满足要求。</p><p>此时就需要用到<em>分组校验</em>，在同一个属性定义多个校验规则属于不同的分组</p><ul><li>添加订单定义<code>@NULL</code>规则属于<code>insert</code>分组，更新订单定义<code>@NotEmpty</code>属于<code>update</code>分组，<code>insert</code>和<code>update</code>是分组的名称，可以自定义</li></ul><h4 id="实现分组"><a href="#实现分组" class="headerlink" title="实现分组"></a>实现分组</h4><ol><li>定义不同的接口类型（空接口）表示不同的分组<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 校验分组  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationGroups</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Insert</span>&#123;&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Update</span>&#123;&#125;; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delete</span>&#123;&#125;;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>用class类型来表示不同的分组</li></ul><ol start="2"><li><p>在定义校验规则时指定分组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotEmpty(message = &quot;添加课程名称不能为空&quot;, groups = ValidationGroups.Insert.class)</span>  </span><br><span class="line"><span class="meta">@NotEmpty(message = &quot;修改课程名称不能为空&quot;, groups = ValidationGroups.Update.class)</span>  </span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;课程名称&quot;, required = true)</span>  </span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li><li><p>在Controller方法中启动校验规则时指定要使用的分组名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;新增课程基础信息接口&quot;)</span>  </span><br><span class="line"><span class="meta">@PostMapping(&quot;/course&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> CourseBaseInfoDto <span class="title function_">createCourseBase</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(ValidationGroups.Insert.class)</span> AddCourseDto addCourseDto)</span> &#123;  </span><br><span class="line">    <span class="type">Long</span> <span class="variable">companyId</span> <span class="operator">=</span> <span class="number">22L</span>;  </span><br><span class="line">    <span class="keyword">return</span> courseBaseInfoService.createCourseBase(companyId, addCourseDto);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果<code>javax.validation.constraints</code>包下的校验规则满足不了需求，我们可以手写校验代码和自定义校验规则注解。</p><h3 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h3><p>@NotEmpty、@NotBlank、@NotNull三者的区别：</p><ol><li><strong>@NotNull</strong><ul><li>适用于基本数据类型(Integer，Long，Double等等)，当<code>@NotNull</code>注解被使用在String类型的数据上，则表示该数据不能为 Null（但是可以为 Empty）</li></ul></li><li><strong>@NotBlank</strong> <ul><li>适用于String类型的数据上，参数不能为Null且去掉字符串的空格之后$size &gt; 0$，必须有实际字符</li></ul></li><li><strong>@NotEmpty</strong><ul><li>适用于 String、Collection集合、Map、数组等等，参数不能为Null或者长度为 0</li></ul></li></ol><p>前端请求后端接口传输参数，为什么<code>Controller</code>中和<code>Service</code>中都需要校验？</p><ol><li><code>Controller</code>中校验请求参数的合法性，包括：必填项校验、数据格式校验，比如：参数是否符合一定的日期格式等</li><li><code>Service</code>中要校验的是业务规则相关的内容，比如：课程已经审核通过，所以提交失败等</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 数据校验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动更新博客内容</title>
      <link href="/cn/%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC/"/>
      <url>/cn/%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>苦于每天手动更新博客内容，做一个每日零点的自动更新脚本</p></blockquote><h2 id="脚本创建"><a href="#脚本创建" class="headerlink" title="脚本创建"></a>脚本创建</h2><p>首先创建一个存放脚本文件的目录，新建一个以<code>.bat</code>结尾的文件</p><p>解析</p><ul><li><code>.bat</code>：bat文件是windows下的批处理文件，也被称为批处理程序或脚本</li><li>批处理文件：无格式的文本文件，它包含一条或多条命令，它的文件扩展名为 <code>.bat</code> 或 <code>.cmd</code></li><li>使用：在命令行窗口下输入批处理文件的名称，或者双击该批处理文件，系统就会调用<code>cmd.exe</code>按照该文件中各个命令出现的顺序来逐个运行</li><li>作用：简化日常或重复性的任务</li></ul><p>目的： 每天定时更新博客内容的脚本</p><ol><li>更新博客内容</li><li>记录日志，日志文件存放于脚本文件所在目录，日志主要包含博客是否更新成功、更新时间</li><li>定时任务，让更新博客脚本每天8点自动执行</li><li>防止日志文件过大，定期清理文件内容（可直接删除，间隔为1周）</li></ol><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>通过vscode打开创建的<code>updateBlog.bat</code>文件，进行编辑：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">@REM <span class="built_in">log</span> file</span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;logFile=%~dp0\updateblog_log.txt&quot;</span></span><br><span class="line">@REM directory judge</span><br><span class="line"><span class="keyword">if</span> not exist <span class="string">&quot;D:\Blog\zybolg&quot;</span> (</span><br><span class="line">    <span class="built_in">echo</span> Directory D:\Blog\zybolg does not exist. &gt;&gt; <span class="string">&quot;%logFile%&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> /b</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">@REM record <span class="built_in">log</span> and run</span><br><span class="line"><span class="built_in">echo</span> Runing hexo deploy... &gt;&gt; <span class="string">&quot;%logFile%&quot;</span></span><br><span class="line">call cmd /c <span class="string">&quot;cd /d D:\Blog\zybolg &amp;&amp; hexo cl &amp;&amp; (echo hexo cl Command succeeded... &gt;&gt; &quot;</span>%logFile%<span class="string">&quot;) || (echo hexo cl Command failed! &gt;&gt; &quot;</span>%logFile%<span class="string">&quot;)&quot;</span></span><br><span class="line">call cmd /c <span class="string">&quot;cd /d D:\Blog\zybolg &amp;&amp; hexo g &amp;&amp; (echo hexo g Command succeeded... &gt;&gt; &quot;</span>%logFile%<span class="string">&quot;) || (echo hexo g Command failed! &gt;&gt; &quot;</span>%logFile%<span class="string">&quot;)&quot;</span></span><br><span class="line">call cmd /c <span class="string">&quot;cd /d D:\Blog\zybolg &amp;&amp; hexo d &amp;&amp; (echo hexo d Command succeeded... &gt;&gt; &quot;</span>%logFile%<span class="string">&quot;) || (echo hexo d Command failed! &gt;&gt; &quot;</span>%logFile%<span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line">@REM get current <span class="built_in">date</span></span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;currentDate=%date% %time%&quot;</span></span><br><span class="line"><span class="built_in">echo</span> The Blog Update on %currentDate% &gt;&gt; <span class="string">&quot;%logFile%&quot;</span></span><br><span class="line"><span class="built_in">echo</span> ----------------------------------------------------- &gt;&gt; <span class="string">&quot;%logFile%&quot;</span></span><br><span class="line">@REM <span class="built_in">exit</span> System</span><br><span class="line"><span class="built_in">exit</span> /b</span><br></pre></td></tr></table></figure><p>定期清理日志文件（同一目录下）脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br><span class="line"></span><br><span class="line">@REM del script file</span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;del_logfile=%~dp0\*.txt&quot;</span></span><br><span class="line"><span class="keyword">if</span> exist <span class="string">&quot;%del_logfile%&quot;</span> (</span><br><span class="line">    del <span class="string">&quot;%del_logfile%&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">exit</span> /b</span><br></pre></td></tr></table></figure><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>命令解析：</p><ul><li><code>chcp 65001</code>：设置代码页编码为UTF-8</li><li><code>@echo off</code>：关闭命令回显，人话就是即执行命令时不在屏幕上显示命令本身，只显示命令的执行结果 <ul><li><code>echo my love china</code></li><li>cmd窗口只会显示my love china</li></ul></li><li>添加注释<ul><li><code>@REM</code>和<code>::</code></li><li>同理，<code>@REM</code>不会回显命令</li></ul></li><li>命令的连接<ul><li><code>&amp;</code>符号将多个命令连接起来在一行中执行</li></ul></li><li>定义和使用变量<ul><li><code>set &quot;var=value&quot;</code></li><li>后续用<code>&quot;%var%&quot;</code>来引用该变量</li></ul></li><li>环境变量的获取<ul><li><code>&quot;%环境变量名%&quot;</code>来获取系统已有的环境变量的值</li><li>比如<code>&quot;%PATH%&quot;</code></li></ul></li><li>IF语句<ul><li><code>if 条件 (执行语句)</code></li><li><code>if 条件 1 (执行语句 1) else if 条件 2 (执行语句 2) else (执行语句 3)</code></li></ul></li><li><code>start</code>命令<ul><li>异步，并行执行</li></ul></li><li><code>call</code>命令<ul><li>同步，串行执行</li></ul></li><li>For循环的<ul><li>遍历文件：<code>for %%i in (*.txt) do (执行语句)</code></li><li>遍历文件夹：<code>for /r 文件夹 %%i in (*) do (命令)</code></li><li>按数字范围循环：<code>for /l %%i in (1,1,10) do (执行语句)</code></li></ul></li><li><code>%~dp0</code>：变量，当前脚本所在的目录路径</li><li><code>exit /b</code>: 使用<code>exit</code>命令退出脚本<ul><li><code>/b</code>参数表示立即退出，不执行后续的命令</li></ul></li><li>目录切换<ul><li><code>cd 目录路径</code>  | <code>cd /d 目录路径</code></li><li><code>/d</code>：windows环境不能直接cd切换目录，需要加上该参数</li></ul></li><li>重定向<ul><li><code>&gt; 输出文件路径</code> | <code>&gt;&gt; 输出文件路径</code></li><li>分别是覆盖和追加</li><li>文件不存在时，自动创建</li></ul></li><li>暂停控制台的运行<ul><li><code>pause</code> 命令</li></ul></li><li>复制、移动、删除（文件&#x2F;文件夹）等语句</li><li>……</li></ul><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>开启定时任务：</p><ul><li>在程序搜索栏，输入：任务计划程序<ul><li>如图所示：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/04/VbSMIrT8iAd3v4o.webp" alt="任务计划程序"></li></ul></li><li>创建基本任务，按照流程完成<ul><li>如下图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/04/MYU4GdqkK9aJc6F.png" alt="任务计划表"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式框架Dubbo</title>
      <link href="/cn/Dubbo/"/>
      <url>/cn/Dubbo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 黑马学习课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx学习</title>
      <link href="/cn/nginx/"/>
      <url>/cn/nginx/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为是后端开发，所以我对nginx学习主要在于部署项目以及一些基本配置</p></blockquote><h1 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h1><blockquote><p>官网: <code>https://nginx.org/</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异常处理</title>
      <link href="/cn/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/cn/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><ol><li>前端和后端需要做一些约定<ul><li>错误信息统一以Json格式返回给前端</li><li>以HTTP状态码决定当前是否出错，非<code>200</code>状态码为操作异常</li><li>对不同的异常设置不同的<code>code</code>码返回，前端根据<code>code</code>码响应给用户具体的异常信息</li></ul></li><li>规范异常信息<ul><li>代码中统一抛出项目的<em>自定义异常类型</em>，这样可以统一去捕获这一类或几类的异常</li><li>规范了异常类型，就可以去获取到该异常信息</li><li>如果捕获了非项目自定义的异常类型，则统一向用户提示<code>执行过程异常，请重试</code>的错误信息</li></ul></li></ol><ul><li>捕获异常<ul><li>代码统一使用try&#x2F;catch方式去捕获代码比较臃肿，可以通过SpringMVC提供的控制器增强类统一去完成异常的捕获</li></ul></li></ul><p>首先引入一些相关的依赖，比如说<code>log4j2</code>去记录日志，<code>spring-web</code>去使用<code>@ControllerAdvice</code>注解，通过<code>lombok</code>去使用一些简化开发的注解</p><p>然后可以定义一个枚举类或常量类，枚举一些通用的异常信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 通用错误信息  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ErrorCommon</span> &#123;  </span><br><span class="line">    UNKOWN_ERROR(<span class="string">&quot;执行过程异常，请重试&quot;</span>),  </span><br><span class="line">    PARAS_ERROR(<span class="string">&quot;非法参数&quot;</span>),  </span><br><span class="line">    OBJECT_NULL(<span class="string">&quot;对象为空&quot;</span>),  </span><br><span class="line">    QUERY_NULL(<span class="string">&quot;查询结果为空&quot;</span>),  </span><br><span class="line">    REQUEST_NULL(<span class="string">&quot;请求参数为空&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String errMessage;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrMessage</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> errMessage;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    ErrorCommon(String errMessage) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.errMessage = errMessage;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们可以自定义异常类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 项目业务异常类  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String errMessage;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrMessage</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> errMessage;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceException</span><span class="params">(String errMessage)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(errMessage);  </span><br><span class="line">        <span class="built_in">this</span>.errMessage = errMessage;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">castError</span><span class="params">(ErrorCommon errorCommon)</span> &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(commonError.getErrMessage());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">castError</span><span class="params">(String errMessage)</span> &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(errMessage);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以定义一个异常响应处理类，一般后端会有一个统一的结果响应类<code>Result</code>，用来响应异常信息和异常<code>code</code>码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 后端统一返回结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Integer code; <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//错误信息  </span></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//数据  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">()</span> &#123;...&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T object)</span> &#123;...&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">error</span><span class="params">(String msg)</span> &#123;...&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构建全局异常处理器"><a href="#构建全局异常处理器" class="headerlink" title="构建全局异常处理器"></a>构建全局异常处理器</h1><p>首先，在业务中为了捕获异常、对异常进行统一处理、让异常能够友好的响应给用户和记录，我们都会自建一个<em>全局异常处理器</em>。<br>其次，JSR303规范的<code>Validator</code>参数校验器，抛出的异常无法使用try-catch语句直接捕获。</p><p>从<code>Spring 3.0</code> - <code>Spring 3.2</code>版本之间，对Spring架构和SpringMVC的Controller的异常捕获提供了相应的异常处理</p><ul><li><code>@ExceptionHandler</code><ul><li><code>Spring3.0</code>提供的标识在方法或类上的注解</li><li>表明方法处理的异常类型</li></ul></li><li><code>@ControllerAdvice</code><ul><li><code>Spring3.2</code>提供的标识在类上的注解</li><li>增强SpringMVC中的Controller，通常与<code>@ExceptionHandler</code>结合使用，来处理SpringMVC的异常信息</li><li>可以指定拦截哪些类型的控制器</li></ul></li><li><code>@RestControllerAdvice</code><ul><li>该注解是一个组合注解：<code>@ControllerAdvice</code>+<code>@ResponseBody</code>效果</li><li>和<code>@RestController</code>注解差不多概念</li></ul></li><li><code>@ResponseStatus</code><ul><li><code>Spring3.0</code>提供的标识在方法或类上的注解</li><li>设置响应状态码</li></ul></li></ul><p>通过上面的注解基本实现项目的全局异常处理，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 全局异常处理器  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//处理自定义异常类型信息</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ServiceException.class)</span>  </span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span> <span class="comment">// 该异常枚举错误码为500，  </span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">exceptionHandler</span><span class="params">(ServiceException exception)</span> &#123; </span><br><span class="line">        log.error(<span class="string">&quot;异常信息：&#123;&#125;&quot;</span>, exception.getErrMessage());  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>.error(exception.getErrMessage());  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对sql异常处理针对性处理   </span></span><br><span class="line"><span class="meta">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">exceptionHandler</span> <span class="params">(SQLIntegrityConstraintViolationException ex)</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//插入的某一字段值（唯一索引）已存在</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> ex.getMessage();  </span><br><span class="line">    <span class="comment">//字段属性重复的异常处理</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理项目中没有被记录的异常类型</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span>  </span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">exceptionHandler</span><span class="params">(Exception exception)</span> &#123;  </span><br><span class="line">        log.error(<span class="string">&quot;异常信息：&#123;&#125;&quot;</span>, exception.getMessage());  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>.error(exception.getMessage());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们在编写代码时，可以根据校验结果，主动抛出自定义的异常类对象，抛出异常时指定详细的异常信息，异常处理器捕获异常信息记录、异常日志，并响应给用户</p><ul><li>可以在comon包中自定义异常类对象，然后继承<code>ServiceException</code>类即可，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 账号不存在异常  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">ServiceException</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountNotFoundException</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountNotFoundException</span><span class="params">(String msg)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(msg);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对于未知异常：在接口执行过程中的一些运行时异常也会被异常处理器统一捕获，记录异常日志，统一响应给用户500错误，在异常处理其中还可以对某个异常类型进行单独处理（例如示例中的sql异常）</p><p>响应结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">500</span>   </span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json  </span><br><span class="line">Transfer-Encoding<span class="punctuation">:</span> chunked  </span><br><span class="line">Date<span class="punctuation">:</span> Fri<span class="punctuation">,</span> <span class="number">03</span> Feb <span class="number">2023</span> <span class="number">04</span><span class="punctuation">:</span><span class="number">52</span><span class="punctuation">:</span><span class="number">30</span> GMT  </span><br><span class="line">Connection<span class="punctuation">:</span> close  </span><br><span class="line">  </span><br><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;500&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;异常信息&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>...<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Nginx搭建下载页</title>
      <link href="/cn/%E6%90%AD%E5%BB%BANginx%E4%B8%8B%E8%BD%BD%E9%A1%B5/"/>
      <url>/cn/%E6%90%AD%E5%BB%BANginx%E4%B8%8B%E8%BD%BD%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx文件下载服务器"><a href="#Nginx文件下载服务器" class="headerlink" title="Nginx文件下载服务器"></a>Nginx文件下载服务器</h1><blockquote><p><em>Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务</em></p></blockquote><h2 id="第一步：安装Nginx"><a href="#第一步：安装Nginx" class="headerlink" title="第一步：安装Nginx"></a>第一步：安装Nginx</h2><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian系统 </span></span><br><span class="line">sudo apt-get install nginx </span><br><span class="line"><span class="comment">#或 sudo apt install nginx （看ubuntu版本）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS/RHEL系统</span></span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure><ul><li>也可以通过Docker一键部署Nginx服务</li></ul><p>安装完成后，输入<code>nginx -v</code> 查看安装版本以及是否安装成功</p><p>nginx的常用命令：</p><ul><li><code>start nginx</code> 开启</li><li><code>nginx -s stop</code> 停止</li><li><code>nginx -s</code> reload 重新加载配置文件</li><li><code>nginx -t</code> nginx的配置检查</li></ul><p>启动nginx服务：<code>sudo systemctl start nginx.service</code>，访问：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/01/KvBhmJNVSwAF4gf.png" alt="nginx服务"></p><p>如果访问结果如上图那么启动nginx服务成功，如果<code>systemctl start nginx.service</code>服务状态为active，但无法访问页面，可能是因为80端口拦截所导致。</p><blockquote><p>注意：Nginx服务器启动成功后默认的端口号是80</p></blockquote><p>解决的方法：</p><ul><li>开放指定端口：<code> firewall-cmd --zone=public --add-port=80/tcp --permanent</code></li><li>配置生效：<code>firewall-cmd --reload</code></li></ul><p> </p><h2 id="第二步：配置Nginx服务"><a href="#第二步：配置Nginx服务" class="headerlink" title="第二步：配置Nginx服务"></a>第二步：配置Nginx服务</h2><p>修改Nginx的配置文件，使其支持文件下载</p><ul><li>默认配置文件通常位于<code>/etc/nginx/nginx.conf</code>或<code>/etc/nginx/sites-available/default</code></li><li>使用文件编辑器打开（或<code>vim 文件名</code>）配置文件，进行修改<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">server</span> &#123;</span><br><span class="line">     <span class="string">listen</span>    <span class="number">80</span><span class="string">;</span> </span><br><span class="line">     <span class="string">server_name</span>  <span class="string">ip;</span></span><br><span class="line"> </span><br><span class="line">     <span class="string">location</span> <span class="string">/download/</span> &#123;</span><br><span class="line">        <span class="string">alias</span> <span class="string">文件的存储目录;</span></span><br><span class="line"> </span><br><span class="line">        <span class="string">if</span> <span class="string">($request_filename</span> <span class="string">~*</span> <span class="string">^.*?\.(html|doc|pdf|zip|docx|txt)$)</span> &#123;</span><br><span class="line">            <span class="string">add_header</span> <span class="string">Content-Disposition</span> <span class="string">attachment;</span></span><br><span class="line">            <span class="string">add_header</span> <span class="string">Content-Type</span> <span class="string">application/octet-stream;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">charset</span> <span class="string">utf-8</span>,<span class="string">gbk;</span>  <span class="comment"># 避免中文乱码</span></span><br><span class="line">        <span class="string">sendfile</span> <span class="string">on;</span>   <span class="comment"># 开启高效文件传输模式</span></span><br><span class="line">        <span class="string">sendfile_max_chunk</span> <span class="string">1m;</span> <span class="comment"># 每个sendfile调用的最大传输量为1MB</span></span><br><span class="line">        <span class="string">tcp_nopush</span> <span class="string">on;</span> <span class="comment"># 最小传输限制功能</span></span><br><span class="line">        <span class="string">aio</span> <span class="string">on;</span> <span class="comment"># 启用异步传输</span></span><br><span class="line">        <span class="string">directio</span> <span class="string">5m;</span> <span class="comment">#当文件大于5MB时以直接读取磁盘的方式读取文件</span></span><br><span class="line">        <span class="string">output</span> <span class="string">buffers</span> <span class="number">4</span> <span class="string">32k;</span> <span class="comment"># 文件输出的缓冲区大小为128KB</span></span><br><span class="line">        <span class="string">limit</span> <span class="string">rate</span> <span class="string">1m;</span>　<span class="comment"># 限制下载速度为1MB</span></span><br><span class="line">        <span class="string">limit</span> <span class="string">rate</span> <span class="string">after</span> <span class="string">4m;</span> <span class="comment">#当客户端下载速度达到4MB时进入限速模式</span></span><br><span class="line">        <span class="string">chunked_transfer_encoding</span> <span class="string">on;</span> <span class="comment">#启用分块传输</span></span><br><span class="line">        <span class="string">autoindex</span> <span class="string">on;</span>  <span class="comment"># 开启目录文件列表</span></span><br><span class="line">        <span class="string">autoindex-format</span> <span class="string">html;</span>  <span class="comment"># 首页格式为HTML</span></span><br><span class="line">        <span class="string">autoindex_exact_size</span> <span class="string">on;</span>  <span class="comment"># 显示出文件的确切大小，单位是bytes</span></span><br><span class="line">        <span class="string">autoindex_localtime</span> <span class="string">on;</span>  <span class="comment"># 显示的文件时间为文件的服务器时间</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>配置解析：</p><ul><li>server_name：服务名，也就是机器的ip；我这里是<code>142.171.157.xxx</code></li><li>&#x2F;download&#x2F;；拦截包含download的请求</li><li>alias：待下载文件的存储目录</li><li>if语句：判断文件的后缀，以及提供下载功能</li><li>访问<code>http://ip:端口/download/</code>，如果成功就会去<code>alias</code>目录下获取可下载的文件</li></ul><h2 id="第三步：配置用户读取权限"><a href="#第三步：配置用户读取权限" class="headerlink" title="第三步：配置用户读取权限"></a>第三步：配置用户读取权限</h2><blockquote><p>如果因为权限问题被拦截，可以再做这一步</p></blockquote><p>确保Nginx用户（通常是<code>www-data</code>或<code>nginx</code>）对文件存放目录有读取权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R www-data:www-data 待下载文件的存储目录 <span class="comment">#将Nginx进程的用户设置为www-data</span></span><br><span class="line">sudo <span class="built_in">chmod</span> -R 755 待下载文件的存储目录 <span class="comment">#所有者拥有可读、可写、可执行权限</span></span><br></pre></td></tr></table></figure><h2 id="第四步：重启Nginx服务"><a href="#第四步：重启Nginx服务" class="headerlink" title="第四步：重启Nginx服务"></a>第四步：重启Nginx服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>重新加载配置文件：<code>nginx -s reload</code> </p><p>再次查看服务状态，确保服务成功启动：<code>sudo systemctl status nginx</code></p><p>测试：</p><ul><li>在配置<code>alias</code>下创建测试文件：<code>mkdir 下载文件的存储目录</code>，<code>touch 下载文件的存储目录/test.txt </code></li><li>输入<code>http:ip:port/download/test.txt</code>，进行下载</li></ul><p>如果出现错误，查看nginx运行日志：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看访问日志</span></span><br><span class="line"><span class="built_in">tail</span> -f nginx的access日志文件地址</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看错误日志</span></span><br><span class="line"><span class="built_in">tail</span> -f nginx的error日志文件地址</span><br></pre></td></tr></table></figure><p>在配置文件中查看nginx的日志存放目录：<code>vim /etc/nginx/nginx.conf</code></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/01/bkgJ58LGdnf9uay.png" alt="日志目录"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/cn/RabbitMQ/"/>
      <url>/cn/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.bilibili.com/video/BV1S142197x7?vd_source=7341c7fca3b496e9108bb1fd49c634ef">配合黑马的微服务课程使用</a><br><a href="https://b11et3un53m.feishu.cn/wiki/FYNkwb1i6i0qwCk7lF2caEq5nRe">黑马文档</a></p></blockquote><h1 id="前景提要？"><a href="#前景提要？" class="headerlink" title="前景提要？"></a>前景提要？</h1><blockquote><p>RabbitMQ是一款高性能的异步通讯组件（消息队列），官网：<code>https://www.rabbitmq.com/</code></p></blockquote><p>同步通讯</p><ul><li>就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话</li></ul><p>异步通讯</p><ul><li>就同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应，因此你可以多线操作，同时跟多人聊天</li></ul><p>两种方式各有优劣，如果你需要实时通信那么使用同步调用（OpenFeign就是同步调用），如果你追求高效率和多人通讯不需要实时响应，那么就使用异步调用</p><h1 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h1><h2 id="同步调用优缺点"><a href="#同步调用优缺点" class="headerlink" title="同步调用优缺点"></a>同步调用优缺点</h2><p>以黑马商城的用户余额支付为例：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/TJf872VqjElgHBS.png" alt="用户余额支付"></p><ul><li>从支付服务到用户服务是一个等待过程，我们必须先支付才能修改支付状态，所以这是一个同步调用</li><li>可是后续的交易、短信、积分服务和支付之间不需要等待过程，如果还是同步调用会造成一些问题：<ul><li>扩展性差</li><li>性能下降，同步调用都是需要等待上一个服务完成</li><li>级联性问题，交易服务失败对支付服务和其他服务的影响</li></ul></li></ul><p>同步调用的优势是时效性强，等待到结果后才返回</p><h2 id="异步调用优缺点"><a href="#异步调用优缺点" class="headerlink" title="异步调用优缺点"></a>异步调用优缺点</h2><p>同步调用主要有2个角色;</p><ul><li>服务调用者</li><li>服务提供者</li></ul><p>异步调用主要有三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的服务调用者</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供者</li><li>消息代理：管理、暂存、转发消息，你可以把它理解成微信服务器</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/HE4CoJBw3AmOQ71.png" alt="异步调用"></p><p>举个例子：外卖员，外卖柜，客人分别对应上面三个角色；如果是同步，外卖员需要把外卖交给客人之后才能继续送下一单外卖，如果客户临时有事无法去拿外卖，那么外卖员就会一直等待客户；可有了外卖柜，外卖员可以把该用户的外卖放到外卖柜里，然后给客人发一个开柜码就可以继续送下一单外卖</p><p>同样黑马商城的用户余额支付为例：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/3HuQlFkwLr2i8DG.png" alt="用户余额支付"></p><ul><li>支付服务不再同步调用业务关联度低的服务，而是发送消息通知到Broker(消息代理)，其他服务监听broker即可，这样具备下列优势：<ul><li>解除支付服务与短信等服务耦合，拓展性强</li><li>无需等待，支付服务在修改完订单状态后直接返回信息给用户，性能好</li><li>故障隔离，下游服务故障不影响上游业务</li><li>缓存消息，流量削峰填谷<ul><li>当QPS较高时，可以通过消息组件来平衡</li></ul></li></ul></li><li>不过异步调用也存在一些问题<ul><li>不能立即得到调用结果，时效性差</li><li>不确定下游业务执行是否成功</li><li>业务安全依赖于Broker的可靠性</li></ul></li></ul><h2 id="MQ技术选型"><a href="#MQ技术选型" class="headerlink" title="MQ技术选型"></a>MQ技术选型</h2><p>MQ（MessageQueue），中文是消息队列，字面来看就是存放消息的队列。也就是异步调用中的Broker</p><p>市面上常见的几款消息队列：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/Gz3Aetn24mkhpcy.png" alt="对比图"></p><h1 id="RabbitMQ入门"><a href="#RabbitMQ入门" class="headerlink" title="RabbitMQ入门"></a>RabbitMQ入门</h1><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>基于docker安装部署</p><ul><li>拉取镜像： rabbitmq:3.8-management</li><li>部署</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network heima \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li><li>访问:<code>虚拟机IP:15672</code>即可看到管理控制台</li></ul><p>RabbitMO对应的架构如图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/BroGIjtT8xdvE2s.png" alt="MQ架构图"></p><p>其中包含几个概念：</p><ul><li><code>publisher</code>：生产者，也就是发送消息的一方</li><li><code>consumer</code>：消费者，也就是消费消息的一方</li><li><code>queue</code>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><code>exchange</code>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><code>virtual host</code>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue，互不影响；不同的业务、项目可以使用不同的虚拟主机</li></ul><h2 id="新建队列、绑定交换机"><a href="#新建队列、绑定交换机" class="headerlink" title="新建队列、绑定交换机"></a>新建队列、绑定交换机</h2><p>需求：在RabbitMQ的控制台完成下列操作</p><ul><li>新建队列hello.queue1和hello.queue2<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/JckXmN9d2zae3Tn.png" alt="添加队列"></li></ul></li><li>向默认的amp.fanout交换机发送一条消息<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/PCAhdBkWyIK5JnF.png" alt="发消息"></li></ul></li><li>查看消息是否到达hello.queue1和hello.queue2<ul><li>没有任何消息到达2个队列中</li></ul></li></ul><p>分析原因</p><ul><li>首先，交换机，负责消息路由，没有存储功能</li><li>其次，这里也没有设置交换机和队列之间路由，交换机需要绑定队列</li></ul><p>添加绑定关系</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/27/9CNUVK68fLo4zub.png" alt="Bindings"></p><h2 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h2><p>需求：在RabbitMQ的控制台完成下列操作</p><ul><li>新建一个用户hmall<ul><li>在<code>admin</code>模块对应处，添加用户hmall</li></ul></li><li>为hmall用户创建一个virtual host<ul><li>退出，使用hmall用户登录，在<code>admin</code>模块的<code>virtual host</code>功能中常见虚拟主机&#x2F;hmall</li></ul></li><li>测试不同virtual host之间的数据隔离现象<ul><li>不同的虚拟主机，无法访问其对应的队列</li></ul></li></ul><h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2><h3 id="何为SpringAMQP"><a href="#何为SpringAMQP" class="headerlink" title="何为SpringAMQP?"></a>何为SpringAMQP?</h3><p>由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端</p><p>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套&#x3D;&#x3D;消息收发的模板工具&#x3D;&#x3D;：SpringAMQP。并且还基于SpringBoot对其实现了自动装配</p><ul><li>SpringAMQP官方文档：<code>https://spring.io/projects/spring-amqp</code></li></ul><p>SpringAMQP提供了三个功能:</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h3 id="导入Demo工程"><a href="#导入Demo工程" class="headerlink" title="导入Demo工程"></a>导入Demo工程</h3><p>导入黑马资料的Demo工程</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/30/BGfse9xiHQKpzrW.png" alt="demo"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>AMQP依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>首先在RabbitMQ控制台新建一个队列：simple.queue</p><p>其次在<code>publisher</code>服务的<code>application.yml</code>中添加配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">rabbitmq:</span>  </span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span> <span class="comment"># 你的虚拟机IP  </span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口  </span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机  </span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itheima</span> <span class="comment"># 用户名  </span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>最后，编写一段测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RabbitTemplate rabbitTemplate;</code>这就是MQ的消息发送工具</li></ul><p>打开控制台，查看消息是否成功发送</p><h3 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h3><p>首先在<code>consumer</code>服务的<code>application.yml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itheima</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在<code>consumer</code>服务的<code>com.itheima.consumer.listener</code>包中新建一个类<code>SpringRabbitListener</code>消息监听器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span>  </span><br><span class="line">InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。通过查看consumer服务的控制台，检验消息是否输出；</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/30/jKfspnTitZmlY78.png" alt="消息"></p><h3 id="WorkQueues模型"><a href="#WorkQueues模型" class="headerlink" title="WorkQueues模型"></a>WorkQueues模型</h3><p>Work queues，任务模型。简单来说就是<em><strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong></em></p><p>为什么需要使用work queues？</p><ul><li>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度</li></ul><p>使用work queues的好处</p><ul><li>多个消费者共同处理消息，消息处理的速度就能大大提高</li></ul><p><strong>场景模拟：</strong></p><p>首先，在控制台创建一个新的队列，命名为<code>work.queue</code></p><p>其次，在publisher服务中的SpringAmqpTest类中添加一个测试方法，模拟大量消息堆积现象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;work.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在consumer服务的SpringRabbitListener中添加2个新的方法，模拟模拟多个消费者绑定同一个队列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模拟任务耗时：<ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul></li></ul><p>最后，启动ConsumerApplication后，执行publisher服务编写的发送测试方法<code>testWorkQueue()</code></p><p>结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">18</span>:<span class="number">34</span>:<span class="number">58.998</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.010</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.045</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.101</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.163</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_3】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.222</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.224</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.284</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.346</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.408</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_5】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.435</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.466</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.529</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_20】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.589</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_7】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.647</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.649</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.711</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.773</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.835</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_9】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.849</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.897</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">18</span>:<span class="number">34</span>:<span class="number">59.957</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.020</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.063</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.079</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.141</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.203</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.263</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_13】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.277</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.322</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.383</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_48】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.445</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_15】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.489</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_17】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.704</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_19】<span class="number">18</span>:<span class="number">35</span>:<span class="number">00.915</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_21】<span class="number">18</span>:<span class="number">35</span>:<span class="number">01.129</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_23】<span class="number">18</span>:<span class="number">35</span>:<span class="number">01.342</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_25】<span class="number">18</span>:<span class="number">35</span>:<span class="number">01.554</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_27】<span class="number">18</span>:<span class="number">35</span>:<span class="number">01.769</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">18</span>:<span class="number">35</span>:<span class="number">01.981</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_31】<span class="number">18</span>:<span class="number">35</span>:<span class="number">02.196</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_33】<span class="number">18</span>:<span class="number">35</span>:<span class="number">02.411</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_35】<span class="number">18</span>:<span class="number">35</span>:<span class="number">02.624</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_37】<span class="number">18</span>:<span class="number">35</span>:<span class="number">02.837</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">18</span>:<span class="number">35</span>:<span class="number">03.038</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_41】<span class="number">18</span>:<span class="number">35</span>:<span class="number">03.252</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_43】<span class="number">18</span>:<span class="number">35</span>:<span class="number">03.467</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_45】<span class="number">18</span>:<span class="number">35</span>:<span class="number">03.681</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_47】<span class="number">18</span>:<span class="number">35</span>:<span class="number">03.891</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_49】<span class="number">18</span>:<span class="number">35</span>:<span class="number">04.105</span></span><br></pre></td></tr></table></figure><ul><li>从结果可以看出来，两个消费者各处理了25条消息</li><li>因为<code>Sleep</code>的原因，消费者1比消费者2先处理完</li></ul><p>也就是说消息是<em><strong>平均分配</strong></em>给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了1秒</p><h4 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h4><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息,处理完成才能获取下一个消息,所以处理能力越强，处理的消息越多</span></span><br></pre></td></tr></table></figure><p>再次测试，结果为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">19</span>:<span class="number">42</span>:<span class="number">46.801</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">19</span>:<span class="number">42</span>:<span class="number">46.815</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">19</span>:<span class="number">42</span>:<span class="number">46.844</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_3】<span class="number">19</span>:<span class="number">42</span>:<span class="number">46.875</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">19</span>:<span class="number">42</span>:<span class="number">46.905</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_5】<span class="number">19</span>:<span class="number">42</span>:<span class="number">46.936</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">19</span>:<span class="number">42</span>:<span class="number">46.966</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_7】<span class="number">19</span>:<span class="number">42</span>:<span class="number">46.997</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.028</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_9】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.058</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.088</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_11】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.119</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.150</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_13】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.181</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.210</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_15】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.241</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.272</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_17】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.302</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.333</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_19】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.364</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_20】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.393</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_21】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.423</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.451</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_23】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.484</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.515</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_25】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.546</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.576</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_27】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.607</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.637</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_29】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.669</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.699</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_31】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.729</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.760</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_33】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.791</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.820</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_35】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.850</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.880</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_37】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.913</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.942</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_39】<span class="number">19</span>:<span class="number">42</span>:<span class="number">47.973</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.005</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_41】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.036</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.065</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_43】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.096</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.126</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_45】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.157</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.187</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_47】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.218</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_48】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.248</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_49】<span class="number">19</span>:<span class="number">42</span>:<span class="number">48.279</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了7条消息。而最终总的执行耗时也在1秒左右，大大提升</li><li>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>WorkQueue模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量，最大化利用消费者的处理能力我，防止消息挤压</li></ul><h3 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h3><p>在上面的两个测试案例中，都没有交换机参与，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/30/cX2zpfqt6duT7el.png" alt="交换机"></li></ul><p>在订阅模型中，多了一个Exchange角色，而且过程略有变化：</p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p><em><strong>交换机的类型</strong></em>有四种</p><ol><li><strong>Fanout</strong>：广播，将消息交给所有绑定该交换机的队列</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>头匹配，基于MQ的消息头匹配，使用较少</li></ol><h3 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h3><p><strong>介绍：</strong><br>Fanout，英文翻译是扇出，我觉得在MQ中叫广播(公告)更合适</p><p>在广播模式下，消息发送流程是这样的：</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/30/RLlBEJvY4eyIwMX.png" alt="广播模式"></li></ul><ol><li>可以有多个队列</li><li>每个队列都要绑定到Exchange（交换机）</li><li>生产者发送的消息，只能发送到交换机</li><li>交换机把消息发送给绑定过的所有队列</li><li>订阅队列的消费者能拿到消息</li></ol><p><strong>测试：</strong></p><ol><li><p>创建一个名为 <code>hmall.fanout</code>的交换机，类型是<code>Fanout</code></p></li><li><p>创建两个队列<code>fanout.queue1</code>和<code>fanout.queue2</code>，绑定到交换机<code>hmall.fanout</code></p></li><li><p>发送消息</p><ol><li>在publisher服务的SpringAmqpTest类中添加测试方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>接受消息</p><ol><li>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>由结果可知，消费者1、2都收到了同样的消息</p><p><strong>总结：</strong><br>交换机的作用是：</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><h3 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h3><p><strong>介绍：</strong><br>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/30/it3oSIpsCh2mVTY.png" alt="DirectExchange"></li></ul><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>Routing Key</code>（路由key）</li><li>生产者在向Exchange发送消息时，也必须指定消息的 <code>Routing Key</code></li><li>Exchange根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routing key</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>测试：</strong></p><ol><li><p>声明一个名为<code>hmall.direct</code>的交换机</p></li><li><p>声明队列<code>direct.queue1</code>，绑定<code>hmall.direct</code>，<code>binding Key</code>为<code>blud</code>和<code>red</code></p></li><li><p>声明队列<code>direct.queue2</code>，绑定<code>hmall.direct</code>，<code>binding Key</code>为<code>yellow</code>和<code>red</code></p></li><li><p>在<code>consumer</code>服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在publisher中编写测试方法，向<code>hmall.direct</code>发送消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>结果</p><ul><li>当使用路由为red这个key时，两个消费者都收到了消息</li><li>切换为blud，只有消费者1处理了消息</li><li>切换为yeallow，只有消费者2处理了消息</li><li><strong>总结：</strong><br>Direct交换机与Fanout交换机的差异</li><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h3 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h3><p><strong>介绍：</strong><br><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>Routing Key</code>把消息路由到不同的队列，只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Binding Key</code> 的时候使用通配符！</p><p><code>Binding Key</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如： <code>item.insert</code></p><p>通配符规则</p><ul><li><code>#</code>：匹配一个或多个单词</li><li><code>*</code>：仅仅匹配一个单词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code>    </li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/30/xbwQeniSqOudRXU.png" alt="TopicExchange模型"></p><p>此时publisher发送的消息使用的<code>Routing Key</code>共有四种：</p><ul><li><code>china.news</code> 代表有中国的新闻消息</li><li><code>china.weather</code> 代表中国的天气消息</li><li><code>japan.news</code> 则代表日本新闻</li><li><code>japan.weather</code> 代表日本的天气消息</li></ul><p>解释</p><ul><li><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，如：<ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配，如：<ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><p><strong>测试：</strong></p><ul><li>首先，在控制台按照图示例子创建队列、交换机，并利用通配符绑定队列和交换机</li><li>消息发送代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topicExchange</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>消息接收代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结：</strong></p><p>Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息Routing Key必须是多个单词，以 <code>.</code> 分割</li><li>Topic交换机与队列绑定时的binding Key可以指定通配符<ul><li><code>#</code>：代表任意个单词</li><li><code>*</code>：代表1个单词</li></ul></li></ul><h3 id="声明队列和交换机"><a href="#声明队列和交换机" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h3><p>在此之前都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把所有用到的队列和交换机名都写下来，交给运维。在这个过程中是很容易出现错误</p><p>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建相应队列和交换机</p><p>&#x3D;&#x3D;需要用到的基本API&#x3D;&#x3D;</p><ul><li>SpringAMQP提供Queue类、工厂类QueueBuilder用来创建队列</li><li>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/30/E3krgNav4oiyH6F.png" alt="交换机构建"></li></ul></li><li>SpringAMQP还提供了ExchangeBuilder来简化创建队列和交换机的过程<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/30/1rLE3KYgwuJNPAM.png" alt="ExchangeBuilder"></li></ul></li><li>在绑定队列和交换机时，则需要使用BindingBuilder类来创建Binding对象</li></ul><h4 id="fanout交换机示例"><a href="#fanout交换机示例" class="headerlink" title="fanout交换机示例"></a>fanout交换机示例</h4><p>在consumer服务中创建一个类，声明队列和交换机</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;hmall.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般可以在消费者这边声明队列、交换机和绑定关系，因为作为发送方来讲，发送方不需要关心队列，发送发唯一关心的是交换机，向某个交换机发消息就可以了</p><h4 id="direct交换机创建示例"><a href="#direct交换机创建示例" class="headerlink" title="direct交换机创建示例"></a>direct交换机创建示例</h4><p>direct模式由于要绑定多个Routing key，会非常麻烦，每一个Routing key都要编写一个binding</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Direct类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithRed</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithBlue</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithRed</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithYellow</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 交换机创建方式：</p><ul><li><code>ExchangeBuilder.directExchange(&quot;hmall.direct&quot;).build();</code>\</li><li>利用ExchangeBuilderi可以创建各个交换机</li></ul><p>在控制台删除之前创建交换机和队列，然后重启项目，完成自动创建</p><h4 id="基于注解声明"><a href="#基于注解声明" class="headerlink" title="基于注解声明"></a>基于注解声明</h4><p>基于@Bean的方式声明队列和交换机依然麻烦，Spring还提供了基于注解方式来声明</p><p>例如，声明Direct模式的交换机和队列，将变为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明Topic模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>Spring的消息发送代码接收的消息体是一个Object：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/qpMP5jzuYtU8LNE.png" alt="消息发送"></p><p>在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象<br>默认情况下Spring采用的序列化方式是JDK序列化，而JDK序列化存在下列问题</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差<br>补充</li><li><strong>JDK序列化</strong>是Java提供的一种机制，‌允许将Java对象转换为字节流，‌以便在网络上传输或保存到磁盘上，这个过程包括两个主要步骤，序列化和反序列化</li><li>‌JDK序列化机制通过实现<code>java.io.Serializable</code>接口或自定义<code>writeObject</code>和<code>readObject</code>方法来进行对象的序列化和反序列化</li><li>为了确保版本的兼容性，‌通常会在类中定义一个<code>serialVersionUID</code>，‌用于在反序列化时验证序列化对象的版本一致性‌</li><li>优点<ul><li>跨平台性：Java平台提供了统一的序列化机制，‌使得Java对象可以在不同的平台之间进行传输和保存</li><li>简单易用：Java提供了内置的序列化机制，‌无需额外的配置或复杂的编码过程</li></ul></li></ul><h4 id="测试默认的消息转换器"><a href="#测试默认的消息转换器" class="headerlink" title="测试默认的消息转换器"></a>测试默认的消息转换器</h4><p>首先，在consumer服务中声明一个新的配置类MessageConfig，利用@Bean的方式创建一个队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">objectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启consumer服务以后，该队列就会被自动创建出来。<br>其次，在publisher模块的SpringAmqpTest中新增一个消息发送的代码，发送一个Map对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息后查看控制台，可以看到消息格式非常不友好，可读性很差：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/YPqSwpyM85WUDHI.png" alt="MAP消息"></p><h4 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h4><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化<br>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果使用的是 Spring Boot 的 spring-boot-starter-web 或 spring-boot-starter-amqp，它们都会自动包含 Jackson 依赖</li></ul><p><strong>配置消息转换器</strong><br>在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可，不一定放启动类，这里只是方便行事</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息（同序列化ID），也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>^9a12b6</p><p>消息转换器中添加的<code>message Id</code>可以便于我们将来做幂等性判断<br>补充</p><ul><li>幂等性：用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用 ^0100ef</li><li><a href="https://blog.csdn.net/sugelachao/article/details/124410578">场景</a><ul><li>支付场景：用户购买商品使用支付宝支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了。因此需要对于每一笔订单，操作多次，也只能扣一次钱</li><li>一键三连：小破站有一个一键三连的功能，长按可以对up主进行激励，每个人对每个视频只有一个一键三连的机会。就算再喜欢某个视频，多次操作，也只能有一键三连一次<br>到MQ控制台<strong>删除</strong><code>object.queue</code>中的旧的消息，重启服务，然后再次执行刚才的消息发送的代码，到MQ的控制台查看消息结构：</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/7GiRtdf3MqbHplj.png" alt="JSON序列化"></p><ul><li>数据大小、可读性都得到了优化</li></ul><h2 id="业务改造"><a href="#业务改造" class="headerlink" title="业务改造"></a>业务改造</h2><p>案例需求</p><ul><li>改造余额支付功能，将支付成功后基于OpenFeign更新订单的状态接口，改为基于RabbitMQ的异步通知</li><li>如图：<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/b4DdPMxqGpVvUEc.png" alt="服务改动"><br>目前没有通知服务和积分服务，因此我们只关注交易服务，步骤如下：</li></ul></li><li>定义<code>direct</code>类型交换机，命名为<code>pay.direct</code></li><li>定义消息队列，命名为<code>trade.pay.success.queue</code></li><li>将<code>trade.pay.success.queue</code>与<code>pay.direct</code>绑定，<code>Binding Key</code>为<code>pay.success</code></li><li>支付成功时不再调用更新订单状态的接口，而是发送一条消息到<code>pay.direct</code>，发送消息的<code>Routing Key</code>为<code>pay.success</code>，消息内容是订单id</li><li>交易服务监听<code>trade.pay.success.queue</code>队列，接收到消息后更新订单状态为已支付</li></ul><h3 id="配置MQ"><a href="#配置MQ" class="headerlink" title="配置MQ"></a>配置MQ</h3><p>不管是生产者还是消费者，都需要配置MQ的基本信息。分为两步：</p><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息发送、接收--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改配置</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itheima</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>黑马的视频在hm-comon配置了消息转换器，要么在其他服务中都引入<code>spring-boot-starter-amqp&lt;</code>依赖，否则替换掉hm-comon的pom文件中的rabbit、amqp依赖，不然项目启动失败</p><h3 id="消息接收-1"><a href="#消息接收-1" class="headerlink" title="消息接收"></a>消息接收</h3><p>在trade-service服务中定义一个消息监听类<code>PayStatusListener</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayStatusListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;trade.pay.success.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;pay.topic&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;pay.success&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenPaySuccess</span><span class="params">(Long orderId)</span>&#123;</span><br><span class="line">        orderService.markOrderPaySuccess(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h3><p>修改<code>pay-service</code>服务下的<code>PayOrderServiceImpl</code>类中的<code>tryPayOrderByBalance</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPayOrderByBalance</span><span class="params">(PayOrderDTO payOrderDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询支付单</span></span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">po</span> <span class="operator">=</span> getById(payOrderDTO.getId());</span><br><span class="line">    <span class="comment">// 2.判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus()))&#123;</span><br><span class="line">        <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试扣减余额</span></span><br><span class="line">    userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());</span><br><span class="line">    <span class="comment">// 4.修改支付单状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.修改订单状态</span></span><br><span class="line">    <span class="comment">// tradeClient.markOrderPaySuccess(po.getBizOrderNo());</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;pay.direct&quot;</span>, <span class="string">&quot;pay.success&quot;</span>, po.getBizOrderNo());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;支付成功的消息发送失败，支付单id：&#123;&#125;， 交易单id：&#123;&#125;&quot;</span>, po.getId(), po.getBizOrderNo(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，如果订单状态改变为”已支付“，则完成了消息的发送和处理；打开RabbitMq的消息队列，读取了一条消息</p><h1 id="RabbitMQ高级功能"><a href="#RabbitMQ高级功能" class="headerlink" title="RabbitMQ高级功能"></a>RabbitMQ高级功能</h1><p>消息的重要性母庸置疑，在支付服务中如果MQ通知失败，支付流水显示支付成功，而交易服务中的订单状态却显示未支付，导致数据出现了不一致，对用户体验非常不好<br>因此，我们必须尽可能确保MQ消息的可靠性，即：消息应该至少被消费者处理1次</p><p>消息从生产者到消费者的每一步都可能导致消息丢失</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><h2 id="一、生产者的可靠性"><a href="#一、生产者的可靠性" class="headerlink" title="一、生产者的可靠性"></a>一、生产者的可靠性</h2><h3 id="生产者重试机制"><a href="#生产者重试机制" class="headerlink" title="生产者重试机制"></a>生产者重试机制</h3><p>第一种情况，就是生产者发送消息时，出现了网络故障，导致与MQ的连接中断，发送消息失败<br>为了解决这个问题，SpringAMQP提供了消息发送时的&#x3D;&#x3D;重试机制&#x3D;&#x3D;。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试<br>修改<code>publisher</code>模块的<code>application.yaml</code>文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> </span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> </span><br></pre></td></tr></table></figure><p>相关解释</p><ul><li><code>connection-timeout: 1s</code>，如果在1秒内无法连接到 RabbitMQ，系统会超时并停止尝试连接</li><li><code>retry</code> 重试机制<ul><li><code>initial-interval: 1000ms</code>，这是在第一次失败后等待重新尝试的时间间隔</li><li><code>multiplier: 1</code>，这是一个倍数，用于计算下一次重试的等待时间<ul><li>每次失败后，系统会将 <code>initial-interval</code> 乘以这个倍数，以确定下一次等待的时间间隔</li></ul></li><li><code>max-attempts: 3</code>，这是设置的最大重试次数，达到这个限制后，系统将停止尝试发送消息，并且可能需要采取其他措施来处理消息发送失败的情况</li></ul></li></ul><p>测试</p><ul><li>利用命令<code>docker stop mq</code>，停掉RabbitMQ服务</li><li>测试发送一条消息，会发现会每隔1秒重试1次，总共重试了3次<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/8yUMOWeTGdlDi1b.png" alt="测试结果"></li><li>超时重试机制配置成功</li></ul></li></ul><p><strong>注意</strong>：当网络不稳定的时候，利用<em>重试机制</em>可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码</p><h3 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h3><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题<br>不过，在少数情况下，也会出现消息发送到MQ之后又丢失的现象，比如：</p><ul><li>MQ内部处理消息的进程发生了异常</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由<br>针对上述情况，RabbitMQ提供了&#x3D;&#x3D;生产者消息确认机制&#x3D;&#x3D;，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况给<code>Publisher</code>返回不同的<strong>回执</strong></li></ul><p>具体如图所示：</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/CExajFgL1yRbmrl.png" alt="回执返回"></li></ul><p>具体流程：</p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败<br>其中<code>ACk</code>和<code>NACK</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制</li></ul><p>默认两种机制都是关闭状态，需要通过配置文件来开启</p><h3 id="实现生产者确认"><a href="#实现生产者确认" class="headerlink" title="实现生产者确认"></a>实现生产者确认</h3><p>在publisher模块的<code>application.yaml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><p>这里的<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调机制返回回执（推荐使用，优化性能）</li></ul><h4 id="定义ReturnCallback"><a href="#定义ReturnCallback" class="headerlink" title="定义ReturnCallback"></a>定义ReturnCallback</h4><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>（发送失败时，调用回调函数），因此可以在配置类中统一设置</p><ul><li>在punlisher中新建一个人配置类MqConfig</li><li>内容如下：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@PostConstruct</code>注解解释（老生常谈了也是）<ul><li>它主要用于类, 在bean被创建并完成属性注入后，执行一些初始化操作，带有<code>@PostConstruct</code>注解的方法会被自动调用</li><li>bean生命周期的初始化过程与之类似</li><li>Bean注解的initMethod字段，以及实现初始化bean的接口与之类似</li></ul></li><li>Bean的生周期：<ul><li>实例化</li><li>依赖注入</li><li>初始化</li><li>使用</li><li>销毁</li></ul></li><li>也可以采用这种基于接口的方式实现ReturnCallback<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/id6Iy1tfq24WxzC.png" alt="ReturnCallback"></li></ul></li><li>注意：需要去配置日志级别，否则不会有log.debug的输出</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">level:com.itheima:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h4 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h4><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中<code>convertAndSend</code>方法时，多传递一个参数：CorrelationData(相关数据，对比数据)<br>这里的CorrelationData中包含两个要点：</p><ul><li><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的Future对象<br>将来MQ的回执就会通过这个<code>Future</code>来返回，我们可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执：</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/iL1KxXdlyWrwHYF.png" alt="回调函数"></li></ul><p>注意：</p><ul><li>spring boot 3以上的用<code>rabbitTemplate.setConfirmCallback()</code>发送消息不用添加最后的CorrelationData参数</li></ul><p>测试：</p><ul><li>向系统自带的交换机发送消息，并且添加<code>ConfirmCallback</code>，代码如下</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;send message fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/OzsABofn49RmLV6.png" alt="结果图"></li><li>可以看到，由于传递的<code>Routing Key</code>是错误的，路由失败后，触发了<code>return callback</code>，同时也收到了ack</li><li>当修改为正确的<code>Routing Key</code>以后，就不会触发<code>return callback</code>了，只收到ack</li><li>如果交换机都是不存在的，则只会收到nack<br>触发<code>ConfirmCallback</code>的3种情况：</li><li>路由失败：一般是因为Routing Key错误导致</li><li>交换机名称错误</li><li>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了</li></ul><p>总的来说，如果路由错误、交换机不存在就会触发ConfirmCallback；只有当交换机存在，路由错误时会触发ReturnCallBack</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/CExajFgL1yRbmrl.png" alt="CallBack触发"></li></ul><p>注意：开启生产者确认比较消耗MQ性能，一般不建议开启；而且在触发ConfirmCallback时，主要原因是因为开发人员编程错误导致</p><h2 id="二、MQ的可靠性"><a href="#二、MQ的可靠性" class="headerlink" title="二、MQ的可靠性"></a>二、MQ的可靠性</h2><p>消息到达MQ以后，如果MQ不能<em>及时保存</em>，也会导致消息丢失，所以MQ的可靠性也非常重要</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>默认情况下MQ的数据都是在内存存储的临时数据（提升性能），重启后就会消失。为了保证数据的可靠性，必须配置&#x3D;&#x3D;数据持久化&#x3D;&#x3D;，包括：</p><ul><li>交换机持久化<ul><li>在MQ控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数，设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式</li></ul></li><li>队列持久化<ul><li>在MQ控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数</li></ul></li><li>消息持久化<ul><li>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code>，设置Delivery mdoe为Non-persistent就是临时模式，Persisten为持久化模式<br>说明：</li></ul></li><li>在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性</li><li>出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久</li><li>间隔时间一般在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式，否则对MQ的性能影响巨大</li></ul><h3 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h3><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的&#x3D;&#x3D;延迟&#x3D;&#x3D;。但在某些特殊情况下，这会导致<strong>消息积压</strong>，比如：</p><ul><li>当消费者宕机或出现网络故障</li><li>当消息发送量激增，超过了消费者处理速度</li><li>当消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为成为<code>PageOut</code><br><code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞（以上都是消息非持久化时）</p><p>为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues（惰性队列）的模式。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p><em><strong>控制台配置Lazy模式：</strong></em></p><ul><li>在添加队列的时候色设置Arguments时，添加<code>x-queue-mod=lazy</code>参数，即可设置队列为Lazy模式<br><em><strong>代码配置Lazy模式：</strong></em></li><li>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数设置队列为Lazy模式，示例：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里是通过<code>QueueBuilder</code>的<code>lazy()</code>函数配置Lazy模式，底层源码如下<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/symb1nJQviRK5Dw.png" alt="Lazy模式"></li></ul></li><li>也可以基于注解来声明队列并设置为Lazy模式：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新已有队列为lazy模式"><a href="#更新已有队列为lazy模式" class="headerlink" title="更新已有队列为lazy模式"></a>更新已有队列为lazy模式</h4><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现，可以基于命令行设置policy：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues </span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/31/akfY5ndAQl6ScIG.png" alt="修改策略模式"></p><h2 id="三、消费者的可靠性"><a href="#三、消费者的可靠性" class="headerlink" title="三、消费者的可靠性"></a>三、消费者的可靠性</h2><p>当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现了故障，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li><li>其他原因<br>一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败需要重新投递消息，且RabbitMQ需要得知消费者的处理状态</li></ul><h3 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h3><p>为了确认消费者是否成功处理，RabbitMQ提供了消费者确认机制。即，当消费者处理消息结束后，应该向RabbitMQ发送一个&#x3D;&#x3D;回执&#x3D;&#x3D;，告知RabbitMQ消息的处理状态，回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题，因此大多数情况下需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回ack，处理失败时返回nack</p><p>由于消息回执的处理代码比较统一，因此SpringAMQP帮我们实现了消息确认。并允许我们通过&#x3D;&#x3D;配置文件设置ACK处理&#x3D;&#x3D;方式：</p><ul><li><code>none</code>：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除</li><li><code>manual</code>：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵，但更灵活</li><li><code>auto</code>：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强（出现异常时触发），当业务正常执行时则自动返回<code>ack</code>. 当业务出现异常时，再根据异常判断返回何种结果：<ul><li>如果是<strong>业务的异常</strong>，会自动返回<code>nack</code></li><li>如果是<strong>消息处理或消息校验异常</strong>，自动返回<code>reject</code><ul><li>见官网了解返回<code>reject</code>的常见异常</li></ul></li></ul></li></ul><p>配置文件设置SpringAMQP的ACK处理方式的代码如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 不做处理</span></span><br></pre></td></tr></table></figure><p>测试：</p><ul><li>修改consumer服务的SpringRabbitListener类中的方法，模拟消息处理异常的发生：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MessageConversionException</span>(<span class="string">&quot;故意的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;消息处理完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为是ACK处理设置为none，所以当消息处理发生异常时，消息依然被RabbitMQ删除</li><li>把确认机制修改为auto，发送消息测试，由于返回的是消息转换异常，因此Spring会自动返回<code>reject</code>，删除消息</li><li>将异常改为RuntimeException类型，再次发送消息测试，由于抛出的是业务异常，所以Spring返回<code>ack</code>，最终消息恢复至<code>Ready</code>状态，并且没有被RabbitMQ删除，并重新投递到消费者<ul><li>直到消费者返回ack或者reject或者关闭消费者服务</li></ul></li></ul><h3 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h3><p>当消费者出现异常后，消息会不断requeue（重入队），再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止<br>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力</p><p>为了应对上述情况，Spring又提供了消费者失败重试机制：在消费者出现异常时先利用&#x3D;&#x3D;本地重试&#x3D;&#x3D;，而不是无限制的requeue到mq队列</p><ul><li>修改consumer服务的application.yml文件，添加内容：</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><ul><li>重启consumer服务，重复之前的测试，可以发现：<ul><li>消费者在失败后消息没有重新回到MQ进行无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常</li><li>查看RabbitMQ控制台，消息被删除了，说明最后SpringAMQP返回了<code>reject</code></li></ul></li><li>结论<ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue，而是在消费者本地重试</li><li>重试达到设置的最大次数后，Spring会返回reject，消息会被删除</li></ul></li><li>注意：生产者重试机制配置的是template，而消费者是listener</li></ul><h3 id="失败处理策略"><a href="#失败处理策略" class="headerlink" title="失败处理策略"></a>失败处理策略</h3><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，不太合适。可是重复性的requeue不合理。<br>因此Spring允许自定义<em>重试次数耗尽后的消息处理策略</em>，这个策略由<code>MessageRecovery</code>（消息恢复）接口来定义，它有3个不同实现：</p><ol><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息（默认）</li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ol><p>比较好的一种处理方案是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的、专门存放异常消息的队列，可以通过邮件或者短信告知开发者，由开发者人工处理。</p><p><strong>实现：</strong></p><ul><li>在consumer服务中定义处理失败消息的交换机和队列<ul><li>这里使用注解直接定义也可以</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义一个RepublishMessageRecoverer失败处理策略，关联队列和交换机</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以把上述代码放于配置类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h3><blockquote><p>这个在前文有提到：[[#^0100ef]]</p></blockquote><p>数据的更新往往不是幂等的，重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失</li></ul><p>所以，我们要尽可能避免业务被重复执行。<br>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>在用户支付成功后会发送MQ消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。<br>举例：</p><ol><li>假如用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为<strong>已支付</strong>状态</li><li>由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后<strong>重新投递</strong>给交易服务</li><li>但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了<strong>已退款</strong>状态</li><li>退款完成后，新投递的消息才被消费，那么订单状态会被再次改为<strong>已支付</strong>，导致业务异常</li></ol><p>两种方案保证消息处理的幂等性：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h4 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h4><p>实现思路：</p><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者（序列化ID）</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息，放弃处理</li></ol><p>给消息添加唯一ID：</p><ul><li>SpringAMQP的MessageConverter自带了<code>Message ID</code>的功能，我们只要开启这个功能即可</li><li>配置Jackson的消息转换器即可，前文有过配置：[[#^9a12b6]]</li></ul><p>问题：</p><ol><li>会添加一些与原本业务无关的健壮性判断，业务侵入问题</li><li>这些数据库的操作也会影响业务原本的性能</li></ol><h4 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h4><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。</p><p>例如在支付案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。</p><p>两种方案其实本质都是在业务处理时查询数据库判断，不过消息ID的方案需要改造原有的数据库，更推荐使用业务判断的方案。</p><p>修改<code>OrderServiceImpl</code>中的<code>markOrderPaySuccess</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">old</span> <span class="operator">=</span> getById(orderId);</span><br><span class="line">    <span class="comment">// 2.判断订单状态</span></span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">null</span> || old.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 订单不存在或者订单状态不是1，放弃处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试更新订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setStatus(<span class="number">2</span>);</span><br><span class="line">    order.setPayTime(LocalDateTime.now());</span><br><span class="line">    updateById(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码逻辑上符合了幂等判断的需求，但是由于判断和更新是两步动作，因此在极小概率下可能存在线程安全问题<br>合并上述操作：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">2</span>)</span><br><span class="line">            .set(Order::getPayTime, LocalDateTime.now())</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .eq(Order::getStatus, <span class="number">1</span>)</span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码等同于这样的SQL语句：<code>UPDATE </code>order<code> SET status = ? , pay_time = ? WHERE id = ? AND status = 1</code></li><li>在where条件中除了判断id以外，还加上了status必须为1的条件。如果条件不符，则SQL匹配不到数据，根本不会执行(乐观锁，同商品超卖)</li></ul><h3 id="兜底方案"><a href="#兜底方案" class="headerlink" title="兜底方案"></a>兜底方案</h3><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠，所以需要有一个兜底方案来确保消息的可靠性。</p><p>解决思想：</p><ul><li>既然MQ通知不一定发送到交易服务，那么交易服务就必须自己<strong>主动去查询</strong>支付状态</li><li>即便支付服务的MQ通知失败，依然能通过主动查询来保证订单状态的一致</li></ul><p>具体流程图如下：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/01/jEyBJbvifhp3xNH.png" alt="流程图"></p><ul><li>图中黄色线圈起来的部分就是MQ通知失败后的兜底处理方案，由交易服务自己主动去查询支付状态</li></ul><p>这里最大的问题是，交易服务并不知道用户会在什么时候支付，如果查询的时机不正确（比如查询的时候用户正在支付中），可能查询到的支付状态也不正确。</p><p>什么时间主动查询支付状态呢？</p><ul><li>这个时间是无法确定的，因此，通常采取的措施就是利用<strong>定时任务</strong>定期查询，例如每隔20秒就查询一次，并判断支付状态。如果发现订单已经支付，则立刻更新订单状态为已支付即可</li><li>定时任务：例如苍穹外卖中的定时处理订单</li></ul><p>综上，支付服务与交易服务之间的订单状态一致性是如何保证？</p><ul><li>首先，支付服务会正在用户支付成功以后利用<em>MQ消息通知</em>交易服务，完成订单状态同步</li><li>其次，为了保证MQ消息的可靠性，可以采用了<em>生产者确认机制、消费者确认、消费者失败重试</em>等策略，确保消息投递的可靠性</li><li>最后，还可以交易服务设置<em>定时任务</em>，定期查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性</li><li>这样下来，保证消息至少处理一次</li></ul><h2 id="四、延迟消息"><a href="#四、延迟消息" class="headerlink" title="四、延迟消息"></a>四、延迟消息</h2><p>在电商的支付业务中，对于一些&#x3D;&#x3D;库存有限&#x3D;&#x3D;的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。<br>例如：电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>存在一个问题：假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易，最终导致商户利益受损！<br>所以，电商中通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。<br>例如，如果设置订单支付超时时间为30分钟，那么应该在用户下单后的第30分钟检查订单支付状态，如果发现未支付，应该立刻取消订单，释放库存。</p><p>但问题来了，如何才能准确的实现在下单后第30分钟去检查支付状态呢？</p><ol><li>像这种在一段时间以后才执行的任务，我们称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用MQ的延迟消息了</li><li>在RabbitMQ中实现延迟消息有两种方案：<ol><li>死信交换机+TTL</li><li>延迟消息插件</li></ol></li></ol><p>下面分析两种方案的实现和优缺点</p><h3 id="死信交换机和延迟消息"><a href="#死信交换机和延迟消息" class="headerlink" title="死信交换机和延迟消息"></a>死信交换机和延迟消息</h3><h4 id="何为死信交换机"><a href="#何为死信交换机" class="headerlink" title="何为死信交换机"></a>何为死信交换机</h4><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过<code>dead-letter-exchange</code>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为<strong>死信交换机</strong>（Dead Letter Exchange）。如果有队列与死信交换机绑定，那么死信最终就会被投递到这个队列中</p><p>死信交换机的作用</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><h4 id="何为延迟消息"><a href="#何为延迟消息" class="headerlink" title="何为延迟消息"></a>何为延迟消息</h4><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试中的<code>RepublishMessageRecoverer</code>作用类似，都是把一个消息放入指定的队列或交换机中。</p><p>场景呈现：</p><ul><li>如下图，有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>,而队列<code>direct.queue1</code>则与死信交换机绑定，Routing Key是blue<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/01/KOQw4EfJRMimaXp.png" alt="延迟消息场景"></li></ul></li><li>发送一条消息到<code>ttl.fanout</code>，Routing Key为blue，并设置消息的<strong>有效期</strong>为5000毫秒</li><li>消息被投递到<code>ttl.queue</code>之后，由于没有消费者，因此消息无人消费。5秒之后，消息的有效期到期，成为死信</li><li>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的Routing Key，也就是<code>blue</code></li><li>因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定，也就能成功消费消息了。而且也已经5秒钟以后了</li><li>最终<code>publisher</code>发送了一条消息，但是<code>consumer</code>在5秒后才收到消息，实现了所谓的<strong>延迟消息</strong></li></ul><p><strong>注意：</strong></p><ul><li>消息变为死信并投递到死信交换机时，会沿用之前的Routing Key</li><li>RabbitMQ的消息过期是基于<strong>追溯方式</strong>来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于<strong>队首</strong>时才会被处理</li><li>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此设置的TTL时间不一定准确</li></ul><h3 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h3><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果</p><ul><li><a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq">官方文档说明</a></li></ul><p>插件下载地址：<code>https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</code>。<br>由于docker部署的RabbitMQ<code>3.8</code>版本，所以下载插件<code>3.8.17</code>版本最好</p><ul><li><code>rabbitmq_delayed_message_exchange-3.8.17.8f537ac.ez</code></li></ul><p>因为基于Docker部署MQ，所以需要先查看RabbitMQ的插件目录对应的数据卷：<code>docker volume inspect mq-plugins</code>。根据查询结果，将下载好的插件上传到对应的插件目录下。</p><p>然后执行命令，安装插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><h4 id="声明延迟交换机"><a href="#声明延迟交换机" class="headerlink" title="声明延迟交换机"></a>声明延迟交换机</h4><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送延迟消息"><a href="#发送延迟消息" class="headerlink" title="发送延迟消息"></a>发送延迟消息</h4><p>发送消息通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差</li><li>因此，<strong>不建议设置延迟时间过长的延迟消息</strong></li></ul><h3 id="解决超时订单问题"><a href="#解决超时订单问题" class="headerlink" title="解决超时订单问题"></a>解决超时订单问题</h3><p>在交易服务中利用<em>延迟消息</em>实现订单超时取消功能。其大概思路如下：</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/01/GCorfdTbjhkUn8Z.jpg" alt="超时处理"></li></ul><p>理论上应该在下单时发送一条延迟消息，设置延迟时间为30分钟。这样就可以在接收到消息时检验订单支付状态，关闭未支付订单。</p><h4 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h4><p>无论是消息发送还是接收都是在交易服务完成，因此在<code>trade-service</code>中定义一个常量类，用于记录交换机、队列、Routing Key等常量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MQConstants</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;trade.delay.direct&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;trade.delay.order.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.order.query&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置MQ-1"><a href="#配置MQ-1" class="headerlink" title="配置MQ"></a>配置MQ</h4><p>在<code>trade-service</code>模块的<code>pom.xml</code>中引入amqp的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>看看hm-common服务是否引入了amqp的依赖</li></ul><p>在<code>trade-service</code>的<code>application.yaml</code>中添加MQ的配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itheima</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br></pre></td></tr></table></figure><h4 id="改造下单业务，发送延迟消息"><a href="#改造下单业务，发送延迟消息" class="headerlink" title="改造下单业务，发送延迟消息"></a>改造下单业务，发送延迟消息</h4><p>宗旨：在下单完成后，发送延迟消息，查询支付状态</p><ol><li>修改<code>trade-service</code>模块的<code>OrderServiceImpl</code>类的<code>createOrder</code>方法，添加消息发送的代码：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/01/86AwDJbVeIxsBP7.png" alt="消息发送"></li></ol><ul><li>延迟消息的时间设置为15分钟，不过为了测试方便，改成10秒。</li></ul><h4 id="编写查询支付状态接口"><a href="#编写查询支付状态接口" class="headerlink" title="编写查询支付状态接口"></a>编写查询支付状态接口</h4><p>由于MQ消息处理时需要查询支付状态，因此要在<code>pay-service</code>模块定义一个这样的接口，并提供对应的<code>FeignClient</code></p><p>在<code>hm-api</code>模块定义三个类：</p><ul><li>PayOrderDTO：支付单的数据传输实体<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付订单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;支付单数据传输实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayOrderDTO</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;业务订单号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bizOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付单号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long payOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付用户id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bizUserId;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付渠道编码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String payChannelCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付金额，单位分&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;付类型，1：h5,2:小程序，3：公众号，4：扫码，5：余额支付&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer payType;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;付状态，0：待提交，1:待支付，2：支付超时或取消，3：支付成功&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;拓展字段，用于传递不同渠道单独处理的字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String expandJson;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;第三方返回业务码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String resultCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;第三方返回提示信息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String resultMsg;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付成功时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime paySuccessTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付超时时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime payOverTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付二维码链接&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String qrCodeUrl;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;更新时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>PayClient：支付系统的Feign客户端<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;pay-service&quot;, fallbackFactory = PayClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据交易订单id查询支付单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 业务订单id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 支付单信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pay-orders/biz/&#123;id&#125;&quot;)</span></span><br><span class="line">    PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>PayClientFallback：支付系统的fallback逻辑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;PayClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PayClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PayClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>fallbackfactory</code>写完之后，需要在defaultfeignconfig中注入bean，否则无法扫描到该<code>fallbackfactory</code></li><li>最后，在<code>pay-service</code>模块的<code>PayController</code>中实现该接口：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据id查询支付单&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/biz/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> payOrderService.lambdaQuery().eq(PayOrder::getBizOrderNo, id).one();</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.copyBean(payOrder, PayOrderDTO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="监听消息，查询支付状态"><a href="#监听消息，查询支付状态" class="headerlink" title="监听消息，查询支付状态"></a>监听消息，查询支付状态</h4><p>在<code>trader-service</code>编写一个监听器，监听延迟消息，查询订单支付状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDelayMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayClient payClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = MQConstants.DELAY_ORDER_QUEUE_NAME),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = MQConstants.DELAY_EXCHANGE_NAME, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            key = MQConstants.DELAY_ORDER_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenOrderDelayMessage</span><span class="params">(Long orderId)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getById(orderId);</span><br><span class="line">        <span class="comment">// 2.检测订单状态，判断是否已支付</span></span><br><span class="line">        <span class="keyword">if</span>(order == <span class="literal">null</span> || order.getStatus() != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 订单不存在或者已经支付</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.未支付，需要查询支付流水状态</span></span><br><span class="line">        <span class="type">PayOrderDTO</span> <span class="variable">payOrder</span> <span class="operator">=</span> payClient.queryPayOrderByBizOrderNo(orderId);</span><br><span class="line">        <span class="comment">// 4.判断是否支付</span></span><br><span class="line">        <span class="keyword">if</span>(payOrder != <span class="literal">null</span> &amp;&amp; payOrder.getStatus() == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.1.已支付，标记订单状态为已支付</span></span><br><span class="line">            orderService.markOrderPaySuccess(orderId);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 4.2.未支付，取消订单，回复库存</span></span><br><span class="line">            orderService.cancelOrder(orderId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要实现<code>cancelOrder</code>方法：</p><ul><li>在处理超时未支付订单时，如果发现订单确实超时未支付，最终需要关闭该订单</li><li>关闭订单需要完成<ul><li>将订单状态修改为已关闭</li><li>恢复订单中已经扣除的库存</li></ul></li></ul><p>在<code>IOrderService</code>接口中定义<code>cancelOrder</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cancelOrder</span><span class="params">(Long orderId)</span>;</span><br></pre></td></tr></table></figure><p>在<code>OrderServiceImpl</code>中实现该方法，实现过程中还要注意业务幂等性的判断</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelOrder</span><span class="params">(Long orderId)</span> &#123;  </span><br><span class="line">    <span class="comment">//将订单状态修改为已关闭  </span></span><br><span class="line">    orderService.lambdaUpdate()  </span><br><span class="line">            .set(Order::getStatus, <span class="number">5</span>)  </span><br><span class="line">            .eq(Order::getId, orderId)  </span><br><span class="line">            .eq(Order::getStatus, <span class="number">1</span>)  </span><br><span class="line">            .update();  </span><br><span class="line">    <span class="comment">//恢复订单中已经扣除的库存  </span></span><br><span class="line">    List&lt;OrderDetail&gt; list = detailService.lambdaQuery()  </span><br><span class="line">            .eq(OrderDetail::getOrderId, orderId)  </span><br><span class="line">            .list();  </span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty())&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    List&lt;OrderDetailDTO&gt; items = BeanUtils.copyList(list, OrderDetailDTO.class);  </span><br><span class="line">    itemClient.recoveryStock(items);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、抽取MQ工具"><a href="#五、抽取MQ工具" class="headerlink" title="五、抽取MQ工具"></a>五、抽取MQ工具</h2><p>除了收发消息以外，消息可靠性的处理、生产者确认、消费者确认、延迟消息等等编码相对比较复杂。<br>因此，我们将常用的操作封装为工具，方便在项目中使用。如下：</p><ul><li>将RabbitMQ的yaml配置抽取到nacos中，作为共享配置，替换所有微服务中的自定义MQ配置</li><li>在<code>hm-commom</code>模块下编写发送消息的工具类<code>RabbitMqHelper</code></li><li>定义一个自动配置类<code>MqConsumeErrorAutoConfiguration</code>，内容包括：<ul><li>声明一个交换机，名为<code>error.direct</code>，类型为<code>direct</code></li><li>声明一个队列，名为：<code>微服务名 + error.queue</code>，动态获取</li><li>将队列与交换机绑定，绑定时的<code>Routing Key</code>就是<code>微服务名</code></li><li>声明<code>RepublishMessageRecoverer</code>，消费失败消息投递到上述交换机</li><li>给配置类添加条件，当<code>spring.rabbitmq.listener.simple.retry.enabled</code>为<code>true</code>时触发</li></ul></li></ul><p>RabbitMqHelper的结构如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, Object msg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMessage</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> delay)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageWithConfirm</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> maxRetries)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 黑马学习课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm</title>
      <link href="/cn/Algorithm/"/>
      <url>/cn/Algorithm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>算法小白的学习之路~~</p></blockquote><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="何为算法"><a href="#何为算法" class="headerlink" title="何为算法"></a>何为算法</h2><p>以我目前的对此认知水平，算法是一种解决之术，算法思想是解决之道。面对一道算法题，我会在脑海中构建程序的运行，然后通过运用各种各样的算法来让流程实现，从而完成题目的解答。在这里算法是一种解决方法，完成程序的运行，算法有很多，解决问题的方法也会很多。算法是算法思想的一种体现，不同的算法思想对应着不同的算法。一道算法题完美的实现离不开好的算法，好的算法思想</p><h2 id="第一节-排序"><a href="#第一节-排序" class="headerlink" title="第一节 排序"></a>第一节 排序</h2><h3 id="排序算法的理解和思考"><a href="#排序算法的理解和思考" class="headerlink" title="排序算法的理解和思考"></a>排序算法的理解和思考</h3><p>给大家看看王者荣耀的玩家排名图</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/28/cVqAwRTP8veM35J.jpg" alt="排名图"></li></ul><p>认真观察可以知道，这张排名图，包含了玩家、区域、巅峰积分这几个关键排名要素；这里排位规则很明显是“同区，巅峰积分越高排名越靠前”，而且这里只会显示前100的用户信息</p><p>通过以上信息，我们可以知道，排序的一个条件是确定<strong>排序的规则</strong>（限制），还有一个条件是确定存储这些数据的<strong>容器</strong>（常说的数据结构），最后一个我认为的是采用什么样的<strong>排序算法</strong>可以让性能最优，毕竟需要排序的数据非常之多</p><p>人话就是排序的三要素为：</p><ol><li>排序规则</li><li>数据结构</li><li>排序算法</li></ol><p>排序规则一般取决于业务的实现，每一个榜单的排序规则都不相同；而排序算法的实现和数据结构的选择息息相关，下面我主要介绍一个常见的排序算法，以及其所使用的数据结构的特点</p><h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h3><p>什么是冒泡排序？这里我就不自做修饰了，直接使用<a href="https://www.runoob.com/w3cnote/bubble-sort.html">菜鸟教程</a>的描述，我觉得已经非常贴切了</p><ul><li>冒泡排序（Bubble  Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端，就像碳酸饮料中的二氧化碳气泡最终会上浮到顶端一样</li></ul><p><strong>动画演示</strong>排序的过程</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/28/2kWIq6DNZEQs7vG.gif" alt="出自-菜鸟教程"></li></ul><p><strong>冒泡排序的思想</strong></p><ul><li>首先讲讲上面这个动画演示。每一次的排序过程都是从第一个数字一直比较到最后一个没有排序的数字，已排序的数字标黄；在该过程中，我们会选择较大的那个数字参与下一轮比较，所以在排序的过程中往往伴随着<strong>交换</strong>，一轮下来最大的数字就放在了最前面</li><li>冒泡排序的基本思想是通过不断<strong>比较</strong>相邻元素并<strong>交换</strong>位置，使得较小的元素逐渐<strong>“浮”</strong>到序列的前端，较大的元素逐渐<strong>“沉”</strong>到序列的后端，从而实现排序</li></ul><p><strong>数据结构</strong></p><ul><li>这里主要介绍数组</li><li>数组，顾名思义也就是数据的组合，数组中数据是一种线性排列，就像商场的储物柜一样从第一个柜子一直到最后一个；从储物柜中取东西是通过一张凭证，而从数组中取**元素(element)<strong>，则是通过</strong>索引(index)**；从数组中取元素很简单，而添加和删除元素则耗时间的多</li><li>不同的编程语言对数组的声明和使用有细微差别，我这里是<a href="https://www.runoob.com/java/java-array.html">Java-数组</a></li></ul><p><strong>具体代码实现Bubble Sort</strong></p><ul><li>这里给出一个具体问题来实现代码，更有利于理解，后续同理</li><li>基于冒泡排序算法，对<code>int[] arr = &#123;5,9,3,1,2,8,4,7,6&#125;;</code>进行升序排序，代码如下</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//外层循环是排序的轮数;&lt;=是为了防止索引越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//内层循环浮出当前的最大数;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//元素交换</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于元素交换，其实就是对调两杯水的问题（再找一个新的杯子）；这里也有其他方法且不会引入新的变量；把元素交换部分的代码替换为：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arr[j]为两数之和,再分别相减实现交换</span></span><br><span class="line">arr[j] += arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j] - arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j] -= arr[j + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>题目巩固</p><ul><li><a href="https://www.luogu.com.cn/problem/P1327">洛谷-数列排序</a></li><li><a href="https://www.cnblogs.com/turingteam/articles/18328465">解答</a></li></ul><h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h3><p>什么是选择排序？</p><ul><li>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法</li></ul><p><strong>动画演示</strong>排序的过程</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/07/La2XfzZQht89F3U.gif" alt="selectionSort"></li></ul><p><strong>选择排序的思想</strong></p><ul><li>看动画演示，每一轮都是从未排序数选择一个最小&#x2F;最大的数字放在需要排序位置上，这样就会把这些数字分为两端，一端已排序不用管，另一端未排序。排序地次数：$n - 1$（n为元素个数）</li><li>选择排序的思想就是，重复从待排序地数据中寻找最小值，将其与序列最左边地数字交换（升序）</li></ul><p>数据结构</p><ul><li>选择排序和冒泡一样，使用数组演示</li></ul><p><strong>具体代码实现Selection Sort</strong></p><ul><li>基于选择排序算法，对<code>int[] arr = &#123;5,9,3,1,2,8,4,7,6&#125;;</code>进行升序排序，代码如下</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;  </span><br><span class="line">    <span class="comment">//需要n - 1轮比较  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)  </span><br><span class="line">        <span class="comment">//可能地最小值  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length ;  </span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j])&#123;  </span><br><span class="line">                <span class="comment">//真正地最小值  </span></span><br><span class="line">               minIndex = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//交换  </span></span><br><span class="line">        <span class="keyword">if</span> (i != minIndex)&#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];  </span><br><span class="line">            arr[i] = arr[minIndex];  </span><br><span class="line">            arr[minIndex] = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目巩固</p><ul><li><a href="https://www.luogu.com.cn/problem/P1327">洛谷-数列排序</a></li><li><a href="https://www.cnblogs.com/turingteam/articles/18328465">解答</a></li></ul><h3 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>全局唯一ID</title>
      <link href="/cn/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/"/>
      <url>/cn/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID/</url>
      
        <content type="html"><![CDATA[<h1 id="全局ID（分布式ID）"><a href="#全局ID（分布式ID）" class="headerlink" title="全局ID（分布式ID）"></a>全局ID（分布式ID）</h1><blockquote><p>全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具。</p></blockquote><ul><li>特性<ul><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ul></li></ul><h2 id="ID的组成部分"><a href="#ID的组成部分" class="headerlink" title="ID的组成部分"></a>ID的组成部分</h2><ol><li>符号位：1bit，永远为0。</li><li>时间戳：31bit，可以使用69年，以秒为单位。</li><li>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID。</li></ol><h2 id="生成策略"><a href="#生成策略" class="headerlink" title="生成策略"></a>生成策略</h2><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><blockquote><p>UUID是一种由时间戳、节点ID和随机数生成的128位标识符。</p></blockquote><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>当前日期和时间</li><li>时钟序列</li><li>随机数</li><li>全局唯一的IEEE机器识别号<ul><li>IEEE机器识别号是一种全局唯一的识别码，通常从网络接口控制器（NIC）的MAC地址获取。</li></ul></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="java-util-UUID类"><a href="#java-util-UUID类" class="headerlink" title="java.util.UUID类"></a>java.util.UUID类</h5><ul><li>示例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUUid</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> java.util.UUID.randomUUID().toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">    <span class="comment">//id = ee43a4bb-3405-4e8d-a9ca-95aede99001d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="cn-hutool-core-lang-UUID类"><a href="#cn-hutool-core-lang-UUID类" class="headerlink" title="cn.hutool.core.lang.UUID类"></a>cn.hutool.core.lang.UUID类</h5><ul><li>功能更加完善</li><li>示例<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hutool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUUid</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">id1</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>); <span class="comment">// 没有“-”</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id2</span> <span class="operator">=</span> UUID.randomUUID().toString(); <span class="comment">// 默认false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;id1 = &quot;</span> + id1);</span><br><span class="line">    System.out.println(<span class="string">&quot;id2 = &quot;</span> + id2);</span><br><span class="line">    <span class="comment">//id1 = 82d847deca8c41f5b2ec9171bc3a845a</span></span><br><span class="line">    <span class="comment">//id2 = ee43a4bb-3405-4e8d-a9ca-95aede99001d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>实现简单。</li><li>不依赖于数据库等外部因素。</li></ul></li><li>缺点<ul><li>其值是字符串类型，数据库占用内存大。</li><li>不是严格意义上的递增有序，数据库索引性能差。</li></ul></li></ul><h3 id="Redis自增"><a href="#Redis自增" class="headerlink" title="Redis自增"></a>Redis自增</h3><ul><li>对于大型系统来说，我们可以使用Redis来生成ID，主要是依赖于 Redis 是<strong>单线程</strong>的，因此可以用来生成全局唯一ID</li><li>要实现这个功能我们可以用<strong>Redis 的原子操作 INCR和INCRBY</strong>来实现；主要思想是利用Redis单线程特性以保证操作的原子性，这样读写同一key时不会出现不同的数据</li></ul><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>符号位（1bit） + 时间戳  (31bit) + 计数器 (32bit)</li></ul><h4 id="Redis自增ID策略"><a href="#Redis自增ID策略" class="headerlink" title="Redis自增ID策略"></a>Redis自增ID策略</h4><ul><li>示例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisWorker</span> &#123;</span><br><span class="line">    <span class="comment">//原始时间戳BASE_TIME</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1704067200L</span>;</span><br><span class="line">    <span class="comment">//移动的位数bit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">//1生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowEpochSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="comment">//时间差</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowEpochSecond - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2生成序列号</span></span><br><span class="line">        <span class="comment">//2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        <span class="comment">//3拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BIT | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>Redis是<strong>基于单线程</strong>的，能够保证线程安全性。而且Redis是基于内存的，在<strong>并发性能</strong>相比于数据库较快一些</li><li>redis可以保证ID的唯一性</li><li>不依赖于数据库，灵活方便</li></ul></li><li>缺点<ul><li>可能数据会丢失</li><li>需要编码和配置的工作量比较大</li></ul></li></ul><h3 id="Snowflake算法"><a href="#Snowflake算法" class="headerlink" title="Snowflake算法"></a>Snowflake算法</h3><blockquote><p>Snowflake算法是Twitter开源的一种分布式ID生成算法，可以在分布式系统中生成唯一且有序的ID。<br>生成后是一个 64bit 的 long 型的<strong>数值</strong>，组成部分引入了<strong>时间戳</strong>，基本保持了<strong>自增</strong></p></blockquote><ul><li><a href="https://github.com/cloudyan/snowflake?tab=readme-ov-file">Snowflake-github</a></li></ul><h4 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h4><ul><li>现在的服务基本是分布式、微服务形式的，而大数据量也导致<strong>分库分表</strong>的产生，对于水平分表就需要保证表中 id 的全局唯一性。</li><li>确保水平分表之后的主键 id 唯一性和自增性。</li></ul><h4 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h4><ul><li>SnowFlake算法生成id的结果是一个<strong>64bit大小的整数</strong>，它的结构如下图：</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\zy293\Desktop\1.jpeg" alt="img"></p><ul><li>1bit，不使用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0</li><li>41bit，用来记录时间戳（毫秒）<ul><li>41bit可以表示 <code>2^&#123;41&#125;-1 </code>个数字</li><li>如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 <code>2^&#123;41&#125;-1</code>，减1是因为可表示的数值范围是从0开始算的，而不是1</li><li>也就是说41bit可以表示<code>2^&#123;41&#125;-1</code>个毫秒的值，转化成单位年则是<code>(2^&#123;41&#125;-1) / (1000 * 60 * 60 * 24 * 365) = 69</code>年</li></ul></li><li>10bit，用来记录<strong>工作机器id</strong><ul><li>可以部署在<code>2^&#123;10&#125; = 1024</code>个节点，包括5位<strong>datacenterId</strong>和5位<strong>workerId</strong></li><li>5位（bit）可以表示的最大正整数是<code>2^&#123;5&#125;-1 = 31</code>，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId</li></ul></li><li>12bit，序列号，用来记录<strong>同毫秒内产生的不同id</strong><ul><li>12位（bit）可以表示的最大正整数是<code>2^&#123;12&#125;-1 = 4095</code>，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号</li></ul></li><li><strong>0 - 41位时间戳 - 5位数据中心标识 - 5位机器标识 - 12位序列号</strong></li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zy293</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowFlake</span>&#123;</span><br><span class="line">    <span class="comment">//起始时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> startTimeStamp;</span><br><span class="line">    <span class="comment">//机器ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> workID;</span><br><span class="line">    <span class="comment">//数据中心ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span>  dataCenterID;</span><br><span class="line">    <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> sequence;</span><br><span class="line">    <span class="comment">//数据中心ID移动位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> dataCenterIndex;</span><br><span class="line">    <span class="comment">//机器ID移动位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> workIDIndex;</span><br><span class="line">    <span class="comment">//时间戳移动位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> timeStampIndex;</span><br><span class="line">    <span class="comment">//记录上一次时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> lastTimeStamp;</span><br><span class="line">    <span class="comment">//序列号掩码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> sequenceMask;</span><br><span class="line">    <span class="comment">//序列号长度12位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> sequenceLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据（也可以通过配置yaml文件实现）</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        startTimeStamp = <span class="number">1577808000000L</span>;</span><br><span class="line">        <span class="comment">//设置机器编号 1</span></span><br><span class="line">        workID = <span class="number">1L</span>;</span><br><span class="line">        <span class="comment">//设置数据中心ID 1</span></span><br><span class="line">        dataCenterID = <span class="number">1L</span>;</span><br><span class="line">        <span class="comment">//起始序列号 0开始</span></span><br><span class="line">        sequence = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">//数据中心位移位数</span></span><br><span class="line">        dataCenterIndex = <span class="number">12L</span>;</span><br><span class="line">        <span class="comment">//机器ID位移位数</span></span><br><span class="line">        workIDIndex = <span class="number">17L</span>;</span><br><span class="line">        <span class="comment">//时间戳位移位数</span></span><br><span class="line">        timeStampIndex = <span class="number">22L</span>;</span><br><span class="line">        <span class="comment">//记录上次时间戳</span></span><br><span class="line">        lastTimeStamp = -<span class="number">1L</span>;</span><br><span class="line">        <span class="comment">//序列号长度</span></span><br><span class="line">        sequenceLength = <span class="number">12L</span>;</span><br><span class="line">        <span class="comment">//序列号掩码</span></span><br><span class="line">        sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//当前系统时间小于上一次记录时间</span></span><br><span class="line">        <span class="keyword">if</span> (now &lt; lastTimeStamp)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;时钟回拨异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相同时间 要序列号进制增量</span></span><br><span class="line">        <span class="keyword">if</span> (now == lastTimeStamp)&#123;</span><br><span class="line">            <span class="comment">//防止溢出</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>)&#123;</span><br><span class="line">                <span class="comment">//溢出处理</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取下一毫秒时间 （有锁）</span></span><br><span class="line">                now = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//置0 之前序列号同一时间并发后自增 到这里说明时间不同了 版本号所以置0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录当前时间</span></span><br><span class="line">        lastTimeStamp = now;</span><br><span class="line">        <span class="comment">//当前时间和起始时间插值 右移 22位</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">handleTimeStamp</span> <span class="operator">=</span> (now - startTimeStamp) &lt;&lt; timeStampIndex;</span><br><span class="line">        <span class="comment">// 数据中心数值 右移动 17位 并且 按位或</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">handleWorkID</span> <span class="operator">=</span> (dataCenterID &lt;&lt; dataCenterIndex) | handleTimeStamp;</span><br><span class="line">        <span class="comment">// 机器ID数值 右移动 12位 并且 按位或</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">handleDataCenterID</span> <span class="operator">=</span> (workID &lt;&lt; workIDIndex) | handleWorkID;</span><br><span class="line">        <span class="comment">// 序列号 按位或</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ID</span> <span class="operator">=</span> handleDataCenterID | sequence;</span><br><span class="line">        <span class="keyword">return</span> ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><ul><li>导入实现雪花算法的依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hutool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>示例</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUUid3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Snowflake</span> <span class="variable">snowflake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Snowflake</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> snowflake.nextId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">iDString</span> <span class="operator">=</span> snowflake.nextIdStr();</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    System.out.println(iDString);</span><br><span class="line">    <span class="comment">//1797601410943664128</span></span><br><span class="line">    <span class="comment">//1797601410943664129</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h5><ul><li>IdGenerator-Java<ul><li>雪花飘移算法-Github<code>https://github.com/yitter/idgenerator/tree/master/Java</code></li></ul></li><li>组成<ul><li>第1部分，时间差，是生成ID时的系统时间减去 BaseTime 的总时间差（毫秒单位）。</li><li>第2部分，WorkerId，是区分不同机器或不同应用的唯一ID，最大值由 WorkerIdBitLength（默认6）限定。</li><li>第3部分，序列数，是每毫秒下的序列数，由参数中的 SeqBitLength（默认6）限定。</li></ul></li><li>示例<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.yitter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yitter-idgenerator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局 初始化（应用程序启动时执行一次）</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 IdGeneratorOptions 对象，可在构造函数中输入 WorkerId(默认为0)</span></span><br><span class="line">    <span class="type">IdGeneratorOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGeneratorOptions</span>();</span><br><span class="line">    <span class="comment">// 保存参数（务必调用，否则参数设置不生效）：</span></span><br><span class="line">    YitIdHelper.setIdGenerator(options);</span><br><span class="line">    <span class="comment">// 以上过程只需全局一次，且应在生成ID之前完成。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化后，在任何需要生成ID的地方，调用以下方法：</span></span><br><span class="line"><span class="type">long</span> <span class="variable">newId</span> <span class="operator">=</span> YitIdHelper.nextId();</span><br><span class="line"><span class="comment">//没有初始化也可以生成id,会有一个默认的DefaultIdGenerator</span></span><br><span class="line"><span class="keyword">if</span> (idGenInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">    idGenInstance = <span class="keyword">new</span> <span class="title class_">DefaultIdGenerator</span>(<span class="keyword">new</span> <span class="title class_">IdGeneratorOptions</span>((<span class="type">short</span>)<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h5><ul><li>开源分布式 ID 框架<ul><li>美团 Leaf：<code>https://github.com/Meituan-Dianping/Leaf</code></li><li>百度 Uid：<code>https://github.com/baidu/uid-generator</code></li></ul></li><li>示例<ul><li>引入依赖</li><li>搞定配置</li><li>如无必要，<strong>不建议引入开源方案增加系统复杂度</strong></li></ul></li></ul><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>生成ID时不依赖于数据库，完全在内存生成，高性能高可用</li><li>容量大，每秒可生成几百万ID<ul><li>SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？<ul><li>同一毫秒的ID数量 &#x3D; 1024 * 4096 &#x3D; 4194304</li></ul></li></ul></li><li><strong>所有生成的id按时间趋势递增，后续插入数据库的索引树的时候，性能较高</strong></li><li>整个分布式系统内不会产生重复id（因为有 datacenterId 和 workerId 来做区分）</li></ul></li><li>缺点<ul><li>依赖于系统时钟的一致性。如果某台机器的系统<strong>时钟回拨</strong>，有可能造成ID冲突，或者ID乱序<ul><li>时钟回拨：系统时钟向后跳变</li></ul></li><li>还有，在启动之前，如果这台机器的系统<strong>时间回拨过</strong>，那么有可能出现ID重复的危险</li></ul></li></ul><h3 id="数据库自增"><a href="#数据库自增" class="headerlink" title="数据库自增"></a>数据库自增</h3><ul><li>利用数据库本身来进行设置，在全数据库内保持唯一</li></ul><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>操作简单，建表时设置<code>auto_increment</code>即可</li><li>由于其递增有序，索引性能高</li></ul></li><li>缺点<ul><li>强依赖DB。不同数据库语法和实现不同，数据库迁移的时候、多数据库版本支持的时候、或分表分库的时候需要处理（造成 ID 不全局统一），会比较麻烦。当DB异常时整个系统不可用，属于致命问题</li><li>单点故障。在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险</li><li>数据一致性问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致<strong>重复发号</strong></li><li>难于扩展。在性能达不到要求的情况下，比较难于扩展。ID发号性能瓶颈限制在单台MySQL的读写性能</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库字段设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/cn/SpringCloud/"/>
      <url>/cn/SpringCloud/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在此感谢黑马程序员提供的2024版SprinCloud学习课程~~<br><a href="https://www.bilibili.com/video/BV1S142197x7?vd_source=7341c7fca3b496e9108bb1fd49c634ef">2024最新SpringCloud微服务开发与实战</a><br><a href="https://b11et3un53m.feishu.cn/wiki/FYNkwb1i6i0qwCk7lF2caEq5nRe">黑马文档</a></p></blockquote><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h2><blockquote><p>官网<code>https://baomidou.com/</code></p></blockquote><h3 id="使用MybatisPlus的基本步骤"><a href="#使用MybatisPlus的基本步骤" class="headerlink" title="使用MybatisPlus的基本步骤"></a>使用MybatisPlus的基本步骤</h3><ol><li>引入MybatisPlus依赖，代替Mybatis依赖</li><li>定义Mapper接口并继承BaseMapper</li></ol><h3 id="MybatisPlus概况"><a href="#MybatisPlus概况" class="headerlink" title="MybatisPlus概况"></a>MybatisPlus概况</h3><ol><li>MybatisPlus是如何知道我们要查询的是哪张表？表中有哪些字段呢？<ol><li>首先原理是基于反射</li></ol></li><li>看下图<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/04/fOawPhUYWF7K6Np.png" alt="img"></li><li>泛型中的<code>User</code>就是与数据库对应的表</li><li>MybatisPlus就是根据ROJO实体的信息来推断出表的信息，从而生成SQL</li><li>默认情况下<ul><li>MybatisPlus会把POJO实体的类名<strong>驼峰转下划线</strong>作为表名</li><li>MybatisPlus会把POJO实体的所有变量名<strong>驼峰转下划线</strong>作为表的字段名，并根据变量类型推断字段类型</li><li>MybatisPlus会把名为id的字段作为<strong>主键</strong></li></ul></li></ol></li><li>但很多情况下，默认的实现与实际场景不符，因此MybatisPlus提供了一些<strong>注解</strong>便于我们声明表信息</li></ol><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><h4 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h4><ol><li>该注解用来指定表名，使用位置在实体类</li></ol><h4 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h4><ol><li>该注解标明表的主键以及指定<code>IdType</code>，使用位置在实体类的主键字段</li><li>IdType常见得三种类型<ol><li><code>AUTO</code>：利用数据库的id自增长</li><li><code>INPUT</code>：手动生成id</li><li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略（在表中需要取消自增策略）<ol><li>雪花飘移算法<code>https://github.com/yitter/idgenerator/tree/master/Java</code>也很好用</li></ol></li></ol></li></ol><h4 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h4><ol><li>该注解指明表的普通字段</li><li>一般情况下我们并不需要给字段添加<code>@TableField</code>注解，一些特殊情况除外：<ul><li>成员变量名与数据库字段名不一致</li><li>成员变量是以<code>isXXX</code>命名，按照<code>JavaBean</code>的规范，<code>MybatisPlus</code>识别字段时会把<code>is</code>去除，这就导致与数据库不符</li><li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用<code>@TableField</code>注解给字段名添加转义字符：@TableField(“ ‘order’ “)</li></ul></li></ol><ul><li>示例</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/04/jvaZEyPbl81Vc4X.png" alt="img"></p><h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><ul><li><p>大多数的配置都有默认值；但还有一些是没有默认值的，例如：</p><ul><li><p>实体类的别名扫描包</p></li><li><p>全局id类型</p></li></ul></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/04/5BGcxrsbzAWoiKk.png" alt="img"></p></li></ul><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><h4 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h4><blockquote><p>个人感觉MP对单表的CRUD方法很好用，但是对sql的编写还是在xml文件中更舒适</p></blockquote><ol><li>构建查询条件<ol><li>QueryWrapper</li><li>UpdateWrapper</li><li>LambdaQueryWrapper 和 LambdaUpdateWrapper（推荐）<ol><li>这两种基于反射形式，没有硬编码，而且相对来说使用舒适</li></ol></li></ol></li></ol><h4 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h4><ul><li><p>复杂的where条件通过Wrapper编写，然后自定义SQL语句的剩下部分</p><ul><li>感觉还是不太友好，简单的<code>where</code>不需要，复杂的<code>where</code>不一定好，代码量的确减少</li><li>而且，拼接起来的SQL也非常危险，侵入性也高</li><li>SQL报错，mapper、service都需要看</li></ul></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">    userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Service接口"><a href="#Service接口" class="headerlink" title="Service接口"></a>Service接口</h4><ol><li><p>使用</p><ol><li>自定义Service接口继承IService接口–方法声明</li><li>自定义实现类继承ServiceImpl<code>&lt;xxxMaper,xxx&gt;</code>类–方法实现</li><li>原理如图，虚线实现、实线继承，看源码即可</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/04/U1qyb92xJ3cgAGQ.png" alt="img"></li></ol></li><li><p>使用场景</p><ol><li>对一些极为简单的CRUD操作，在Contoller中就可以直接完成</li><li>对具有复杂业务的操作依然是Contoller-Service-Mapper形式完成</li><li>个人觉得，仅从实现业务的角度上看，二者配合使用效果最好<ol><li><a href="https://www.zhihu.com/question/314745062/answer/3282783134">MP使用看法</a></li></ol></li></ol></li><li><p>Lambda用法</p><blockquote><p>这个相较与前面，使用起来确实更加舒适</p></blockquote><ol><li><p>在IService中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化；我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code>，而是直接调用<code>lambdaQuery</code>和<code>lambdaUpdate</code>方法</p></li><li><p>基于LambdaQuery</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以发现LambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>list()</code>，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用<code>list()</code>，可选的方法有：<ul><li><code>.one()</code>：最多1个结果</li><li><code>.list()</code>：返回集合结果</li><li><code>.count()</code>：返回计数结果</li></ul></li></ol></li><li><p>基于LambdaUpdate</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2.校验用户状态</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.扣减余额 update tb_user set balance = balance - ?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, remainBalance) <span class="comment">// 更新余额</span></span><br><span class="line">            .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 动态判断，是否更新status</span></span><br><span class="line">            .eq(User::getId, id)</span><br><span class="line">            .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>同样，LambdaUpdate方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>update()</code>，表示更新数据</li></ol></li></ol></li><li><p>批量新增</p><ol><li><p>毫无疑问，批量新增比循环新增100000数据快的多</p><ol><li>这里批量插入更快的原因是网络请求的次数减少</li></ol></li><li><p>如果想要进一步提升批量插入的性能，如何做？</p><ol><li>看<code>MybatisPlus</code>源码分析</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);<span class="comment">//逐条插入数据</span></span><br><span class="line">    <span class="keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="type">boolean</span> <span class="title function_">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLimit</span> <span class="operator">=</span> Math.min(batchSize, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据<ol><li>简单看看这篇 <code>https://blog.csdn.net/qq_71443736/article/details/134728125</code>博客了解预编译模式</li></ol></li><li>它SQL类似</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Preparing: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time ) <span class="keyword">VALUES</span> ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br></pre></td></tr></table></figure><ol start="4"><li>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_4, <span class="number">123</span>, <span class="number">18688190004</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li><p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。</p><ol><li>参考文档：<code>https://www.mysql.com/</code></li><li>这个参数的默认值是false，我们需要修改连接参数，将其配置为true。就可以实现上述SQL语句的实现</li><li>在<code>ClientPreparedStatement</code>的<code>executeBatchInternal</code>中，会判断<code>rewriteBatchedStatements</code>值是否为true并重写SQL的功能</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8</span>      <span class="string">&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="string">&amp;rewriteBatchedStatements=true</span> </span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">abc123</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><ol><li><p>代码生成器</p><ul><li>帮助生成通用代码格式</li><li>两款插件，对生成代码来说都可以<ul><li>MyBatis-X</li><li>MyBatisPlus</li></ul></li></ul></li><li><p>静态工具</p><ol><li>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以实现CRUD功能<ol><li>何为循环依赖<code>https://blog.csdn.net/kaka_buka/article/details/139785462</code></li></ol></li></ol></li><li><p>逻辑删除</p><ol><li>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：<ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul></li><li>配置</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>注意，逻辑删除本身也有自己的问题，比如：<ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul></li><li>还有一种解决是，如果数据不能删除，可以采用把数据迁移到其它表的办法</li></ol></li><li><p>枚举处理器</p><ol><li><p>对静态字段的代替，增强代码的可阅读性</p><ol><li>也可以看看这篇blog<code>https://blog.csdn.net/qq_45036591/article/details/104159613</code></li></ol></li><li><p>枚举类型与数据库类型的相互转换</p><ol><li><p>告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值；<code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/1CNwZcoU3SzPy4i.png" alt="img"></p></li><li><p>配置（3.5.2后无需配置）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span>     <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure></li><li><p>这样查询出来的状态字段是枚举类型而不是单纯的0和1</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/eBSgTyYVUPK3kD5.png" alt="img"></li></ol></li></ol></li><li><p>使页面查询结果也是枚举格式</p><ol><li>在UserStatus枚举中通过<code>@JsonValue</code>注解标记JSON序列化时展示的字段：<code>desc</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/DpVHe96PcWxIRSM.png" alt="img"></li></ol></li></ol></li><li><p>JSON处理器</p><ol><li><p>数据库的user表中有一个<code>info</code>字段，是JSON类型</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/ePkSmYw1oALaF7E.png" alt="img"></li><li>而User实体类中却是<code>String</code>类型</li><li>这样一来，我们要读取<code>info</code>中的属性时就非常不方便；如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类</li><li>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦</li></ol></li><li><p>MybatisPlus提供了很多特殊类型字段的类型处理器（TypeHandler），解决特殊字段类型与数据库类型转换的问题</p><ol><li>例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器</li></ol></li><li><p>使用Json处理器完成JSON字段与对象间的转换</p><ol><li><p>定义一个单独实体类来与info字段的属性匹配</p></li><li><p>将User类的info字段修改为UserInfo类型，并声明类型处理器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line"><span class="keyword">private</span> UserInfo info;</span><br></pre></td></tr></table></figure></li><li><p>开启结果集映射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h3><ul><li>MP提供很多插件，分页插件最为常用</li></ul><h4 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h4><ul><li><p>在未引入分页插件的情况下，<code>MybatisPlus</code>是不支持分页功能的，<code>IService</code>和<code>BaseMapper</code>中的分页方法都无法正常起效</p></li><li><p>首先需要配置分页插件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 创建分页插件</span></span><br><span class="line">        <span class="type">PaginationInnerInterceptor</span> <span class="variable">paginationInnerInterceptor</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MysQL);</span><br><span class="line">        paginationInnerInterceptor.setMaxLimit(<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">//2.添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(paginationInnerInterceptor);</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><blockquote><p>版本不同可能API会有改变</p></blockquote><ul><li>当前页pageNo，查询条数pagesize<ul><li><code>Page&lt;User&gt; page = Page.of(pageNo, pagesize);</code></li></ul></li><li>排序条件<ul><li><code>page.addorder(new OrderItem(column: &quot;balance&quot;,asc:true));</code></li></ul></li><li>通过xxxService或xxxMapper调用分页查询<ul><li><code>Page&lt;User&gt; p = userService.page(page);</code></li></ul></li><li>返回结果<ul><li>总数据<code>List&lt;User&gt; records = p.getRecords();</code></li><li>总条数<code>long total = p.getTotal()</code></li><li>总页数<code>long pages = p.getPages()</code></li></ul></li></ul></li></ul><h4 id="通用分页实体"><a href="#通用分页实体" class="headerlink" title="通用分页实体"></a>通用分页实体</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页查询实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageSize;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;排序字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否升序&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//泛型方法,用来直接返回Page&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(OrderItem ... orders)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.分页条件</span></span><br><span class="line">        Page&lt;T&gt; p = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">// 2.排序条件</span></span><br><span class="line">        <span class="comment">// 2.1.先看前端有没有传排序字段</span></span><br><span class="line">        <span class="keyword">if</span> (sortBy != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(sortBy, isAsc));</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.再看有没有手动指定排序字段</span></span><br><span class="line">        <span class="keyword">if</span>(orders != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.addOrder(orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从<code>PageQuery</code>到<code>MybatisPlus</code>的<code>Page</code>之间转换的过程还是比较麻烦；在<code>PageQuery</code>这个实体中定义工具方法，来简化开发</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">empty</span><span class="params">(Page&lt;P&gt; p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voClass 目标VO类型的字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> convertor PO到VO的转换函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类的泛型参数是在<strong>类实例化</strong>时确定的，而静态方法在实例化之前就可以被调用，因此无法直接引用类的泛型参数，而需要重新定义泛型</li><li>泛型没有字节码，所以函数调用者应该传参数<code> Class&lt;V&gt; voClass</code></li><li>调用者自定义PO到VO的转换方式，这就需要传递一个行为，也就是函数式接口<ul><li>函数式编程</li><li>Lambda表达式的使用</li><li>Stream流的使用</li></ul></li><li>自定义工具类完成对MP的转换，而不是把方法放在实体中，完成解耦合</li></ul><hr><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><blockquote><p>快速构建、运行、管理应用的工具</p></blockquote><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><blockquote><p>虚拟机VMware；系统Centos-7；远程连接工具 MobaXterm<br>详细安装<code>https://b11et3un53m.feishu.cn/wiki/FJAnwOhpIihMkLkOKQocdWZ7nUc</code><br>docker官方交流社区<code>https://hub.docker.com</code><br>一个不错的docker容器管理UI <code>https://mp.weixin.qq.com/s/daB65RX41d4KgXQzGKtYOA</code></p></blockquote><ol><li><p>开启虚拟机，远程连接</p></li><li><p>卸载旧版Docker</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker<span class="literal">-client</span> \</span><br><span class="line">    docker<span class="literal">-client-latest</span> \</span><br><span class="line">    docker<span class="literal">-common</span> \</span><br><span class="line">    docker<span class="literal">-latest</span> \</span><br><span class="line">    docker<span class="literal">-latest-logrotate</span> \</span><br><span class="line">    docker<span class="literal">-logrotate</span> \</span><br><span class="line">    docker<span class="literal">-engine</span></span><br></pre></td></tr></table></figure></li><li><p>配置Docker的yum库</p><ol><li>安装yum工具 <code>yum install -y yum-utils</code></li><li>安装成功后，执行命令，配置Docker的yum源(阿里云镜像)<ol><li><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></li></ol></li></ol></li><li><p>开始安装Docker</p><ol><li><code>yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></li></ol></li><li><p>校验是否安装成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 版本查看</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 停止Docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># 查看docker状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><ol><li>使用阿里云的<strong>容器镜像服务</strong>或其他镜像加速器<ol><li>打开aliyun，得到镜像加速地址<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/06/fxRykNFotOMZi72.png" alt="img"></li></ol></li><li>具体命令</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="comment"># 复制内容，注意把其中的镜像加速地址改成自己的</span></span><br><span class="line"><span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://xxxx.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启Docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="3"><li>成功，在&#x2F;etc&#x2F;docker文件夹中有一个daemon.json文件，后续直接通过VScode修改</li></ol><h3 id="快速入门-部署MySQL"><a href="#快速入门-部署MySQL" class="headerlink" title="快速入门-部署MySQL"></a>快速入门-部署MySQL</h3><ul><li><p>如果之前已经部署过MySQL，建议先删除</p><ul><li>具体文档<code>https://www.jb51.net/article/179020.html</code></li><li>删除前先关闭MySQL的服务  <code>systemctl stop mysql 或者 service mysql stop</code><ol><li>关闭后，<code>systemctl status mysql</code> 查看是否关闭</li></ol></li><li>使用 rpm 命令查看已安装的MySQL<ol><li><code>rpm -qa|grep mysql</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/06/QfH5t7LzPC4UA9k.png" alt="img"></li></ol></li><li>使用yum安装的话，需要清除服务<code>yum remove mysql mysql-server mysql-libs mysql-server</code></li><li>再次查询<ol><li><code>rpm -qa|grep mysql</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/06/8nGDXKVCPJWLQk2.png" alt="img"></li><li>通过 <code>rpm -ev + 对应文件名</code> 删除</li></ol></li><li>查找MySQL相关的目录文件并对应删除<ol><li><code> find / -name mysql</code></li><li>使用<code>rm -rf + 查询出来的目录或文件名</code></li></ol></li><li>再次检查是否有遗漏<ol><li><code>rpm -qa|grep mysql</code></li><li><code>find / -name mysql</code></li></ol></li><li>注意<ol><li><code>rpm -ev</code>是软件包管理器，删除的是一个软件包</li><li><code>rm -rf</code>是删除某个目录或文件</li></ol></li></ul></li><li><p>如果是利用传统方式部署MySQL，大概的步骤有：</p><ul><li>搜索并下载MySQL安装包</li><li>上传至Linux环境</li><li>编译和配置环境</li><li>安装</li></ul></li><li><p>我们利用Docker来部署MySQL</p><ul><li><p>一步即可</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/11/5UjOryd3Atzpib9.png" alt="img"></p></li><li><p>部署完毕后，通过任意客户端工具连接MySQL</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/HcoW7NZfAemkF3J.png" alt="img"></li></ul></li><li><p>可以发现，当我们执行命令后，Docker做的第一件事情，是去自动搜索并下载了MySQL，然后会自动运行MySQL，我们完全不用插手</p></li><li><p>这种安装方式你完全不用考虑运行的操作系统环境，它不仅仅在CentOS系统是这样，在Ubuntu系统、macOS系统、甚至是装了WSL的Windows下，都可以使用这条命令来安装MySQL。要知道，<strong>不同操作系统下其安装包、运行环境是都不相同的</strong>！如果是<strong>手动安装，必须手动解决安装包不同、环境不同的、配置不同的问题</strong>！</p></li><li><p>使用Docker，这些完全不用考虑。就是因为Docker会自动搜索并下载MySQL</p><ul><li>注意：这里下载的不是安装包，而是镜像。镜像中不仅包含了MySQL本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器</strong></li><li>镜像的英文是<code>image</code>、容器的英文是<code>container</code></li></ul></li><li><p>因此，Docker安装软件的过程，就是自动搜索下载镜像，然后创建并运行容器的过程</p></li></ul></li><li><p>Docker会根据命令中的镜像名称自动搜索并下载镜像，那么问题来了，它是去哪里搜索和下载镜像的呢？这些镜像又是谁制作的呢？</p><ul><li>Docker官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利</li><li>Docker官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站，这个网站就成了Docker镜像交流的社区<code>https://hub.docker.com</code></li><li>基本上我们常用的各种软件都能在这个网站上找到</li></ul></li><li><p>像这种提供存储、管理Docker镜像的服务器，被称为<strong>DockerRegistry</strong>，可以翻译为镜像仓库</p><ul><li><strong>DockerHub</strong>网站是官方仓库，阿里云、华为云会提供一些第三方仓库，我们也可以自己搭建私有的镜像仓库</li><li>官方仓库在国外，下载速度较慢，一般我们都会使用第三方仓库提供的镜像加速功能，提高下载速度</li><li>企业内部的机密项目，往往会采用私有镜像仓库</li><li>镜像的来源有两种<ul><li>基于官方基础镜像自己制作</li><li>直接去DockerRegistry下载</li></ul></li></ul></li><li><p>总结</p><ul><li>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用</li><li>Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并运行容器，应用就部署完成了</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/06/lBtPNbYkMHxFoO4.png" alt="img"></li></ul></li></ul><h3 id="命令解读"><a href="#命令解读" class="headerlink" title="命令解读"></a>命令解读</h3><ul><li>以下是部署mysql时的命令，他们有什么含义呢？</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><ul><li><p>解读</p><ul><li><p><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器里的进程在后台运行</p></li><li><p><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code> ，全局唯一</p></li><li><p><code>-p 3306:3306</code> : 设置端口映射</p><ul><li>容器其实就是一个小型的服务，也有ip地址，但是我们无法ping通，不过我们可以ping通虚拟机的ip</li><li><strong>容器是隔离环境</strong>，外界不可访问，但是可以将<strong>宿主机（虚拟机）端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><p><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数（配置容器运行时需要的环境变量）</p><ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><p><code>mysql</code> : <strong>镜像</strong>名称（REPOSITORY），Docker会根据这个名字搜索并下载镜像</p><ul><li><p>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</p></li><li><p>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></p></li></ul></li></ul></li><li><p>镜像的名称不是随意的，而是要到DockerRegistry中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在DockerHub网站或者软件的官方网站中都能找到</p></li><li><p>如果我们要安装其它软件，也可以到<a href="https://hub.docker.com/">DockerRegistry</a>中寻找对应的镜像名称和版本，阅读相关配置即可</p></li></ul><h3 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h3><h4 id="Docker常见命令"><a href="#Docker常见命令" class="headerlink" title="Docker常见命令"></a>Docker常见命令</h4><blockquote><p>官方文档<code>https://docs.docker.com/</code></p></blockquote><ul><li><p>常见的命令有</p><ul><li><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="center">docker pull</td><td align="center">拉取镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="center">docker push</td><td align="center">推送镜像到DockerRegistry</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="center">docker images</td><td align="center">查看本地镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="center">docker rmi</td><td align="center">删除本地镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="center">docker run</td><td align="center">创建并运行容器（不能重复创建）</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="center">docker stop</td><td align="center">停止指定容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="center">docker start</td><td align="center">启动指定容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="center">docker restart</td><td align="center">重新启动容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="center">docker rm</td><td align="center">删除指定容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="center">docker ps</td><td align="center">查看容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="center">docker logs</td><td align="center">查看容器运行日志</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="center">docker exec</td><td align="center">进入容器</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="center">docker save</td><td align="center">保存镜像到本地压缩文件</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="center">docker load</td><td align="center">加载本地压缩文件到镜像</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="center">docker inspect</td><td align="center">查看容器详细信息</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table></li><li><p><code>docker command --help</code>查看当前命令的帮助文档</p></li></ul></li><li><p>补充</p><ul><li><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器；通过命令可以实现开机自启</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>命令之间的关系</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/08/bSWLIyFfZn69X2O.png" alt="img"></li></ul></li><li><p>案例</p><ul><li>需求：查看DockerHub，拉取Nginx镜像，创建并运行Nginx容器<ul><li><p>查看DockerHub</p><ul><li><code>https://hub.docker.com/nginx</code></li></ul></li><li><p>拉取Nginx镜像</p><ul><li><code>docker pull nginx</code></li></ul></li><li><p>查看本地镜像列表</p><ul><li><code>docker images</code></li></ul></li><li><p>创建并运行Nginx容器</p><ul><li><code>dokcer run -d --name nginx -p 81:80 nginx</code></li></ul></li><li><p>查看容器</p><ul><li><code>docker ps -a</code></li><li>格式化查询<code>docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</code></li></ul></li><li><p>查看容器运行日志</p><ul><li><code>docker logs nginx</code></li></ul></li><li><p>停止容器</p><ul><li><code>docker stop nginx</code></li></ul></li><li><p>再次启动容器</p><ul><li><code>docker start nginx</code></li></ul></li><li><p>进入Nginx容器</p><ul><li><code>docker exec -it nginx bash</code></li></ul></li><li><p>删除容器</p><ul><li><code>docker rm nginx</code>，需要先关闭nginx容器</li><li>强制删除<code>docker rm -f nginx</code></li></ul></li></ul></li></ul></li><li><p>命令别名</p><ul><li><p>给常用Docker命令起别名，方便访问</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vim /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line">alias <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line">alias <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line">alias <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table&#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> /<span class="type">etc</span>/<span class="type">bashrc</span> ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>配置生效</p><ul><li><code>source /root/.bashrc</code></li></ul></li></ul></li></ul><h4 id="数据卷（volume）"><a href="#数据卷（volume）" class="headerlink" title="数据卷（volume）"></a>数据卷（volume）</h4><ul><li><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便，而以下问题的解决就依赖于数据卷</p><ul><li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让Nginx代理我的静态资源怎么办？</li></ul></li><li><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器</strong>解耦。</p></li><li><p>何为数据卷？</p><ul><li><strong>数据卷</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机</strong>目录之间映射的桥梁</li></ul></li><li><p>案例1-利用Nginx容器部署静态资源</p><ul><li><p>以Nginx为例，我们知道Nginx中有两个关键的目录</p><ul><li><code>html</code>：放置一些静态资源</li><li><code>conf</code>：放置配置文件</li><li>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件</li><li>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/12/cwC6Kz8iNFd9kft.png" alt="img"></li><li>在上图中<ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li><li>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong></li><li>此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内部的<code>/usr/share/nginx/html/_data</code>目录；只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了</li></ul></li></ul></li><li><p><strong>小提示</strong></p><ul><li><p><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code></p></li><li><p>为什么不让容器目录直接指向宿主机目录呢？</p><ul><li>因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了</li></ul></li><li><p>但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与宿主机目录之间的映射关系即可</p></li><li><p>不过，我们通过由于数据卷目录比较深，不好寻找，通常我们也<strong>允许让容器直接与宿主机目录挂载</strong>而不使用数据卷</p></li></ul></li></ul></li><li><p>数据卷的相关命令</p><ul><li><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="center">docker volume create</td><td align="center">创建数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="center">docker volume ls</td><td align="center">查看所有数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="center">docker volume rm</td><td align="center">删除指定数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="center">docker volume inspect</td><td align="center">查看某个数据卷的详情</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="center">docker volume prune</td><td align="center">清除数据卷</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table></li><li><p>注意</p><ul><li>容器与数据卷的挂载要在<strong>创建容器时配置</strong>，对于创建好的容器，是不能设置数据卷的</li><li><strong>创建容器的过程中，数据卷会自动创建</strong></li></ul></li></ul></li><li><p>Nginx的html目录挂载</p><ul><li>首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷<ul><li><code>docker run -d --name nginx -p 81:80 -v html(数据卷名):/usr/share/nginx/html(容器内目录) nginx</code></li></ul></li><li>查看数据卷<ul><li><code>docker volume ls</code></li></ul></li><li>查看数据卷具体信息<ul><li><code>docker volume inspect html(数据卷名)</code></li><li>得到宿主机目录，可以查看和修改</li></ul></li><li>进入容器内部，查看容器内目录内的文件是否变化<ul><li><code>docker exec -it nginx bash</code></li><li><code>cd /usr/share/nginx/html(容器内目录)</code></li></ul></li></ul></li><li><p>本地目录&#x2F;文件挂载</p><ul><li><p>案例2-mysql容器的数据挂载</p><ul><li>需求<ul><li>查看mysql容器，判断是否有数据卷挂载</li><li>基于宿主机目录实现MySQL数据目录、配置文件、初始化脚本的挂载（查阅官方镜像文档）</li></ul></li></ul></li><li><p>查看容器是否挂载</p><ul><li><code>docker inspect 容器名</code></li></ul></li><li><p>匿名数据卷</p><ul><li><p>使用<code>docker inspect 容器名</code>后，关注</p><ul><li><p><code>.Config.Volumes</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;/var/lib/mysql&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是<strong>数据卷未定义</strong>；这就是匿名卷。</p></li><li><p><code>.Mounts</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。</li><li>Source：宿主机目录</li><li>Destination : 容器内的目录</li><li>上述配置是将容器内的<code>/var/lib/mysql</code>这个目录，与数据卷<code>29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</code>挂载。于是在宿主机中就有了<code>/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code>这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别</li></ul></li></ul></li><li><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载</p></li></ul></li><li><p>实现本地目录挂载</p><ul><li><p>查看docker-mysql官方镜像获取各个路径</p><ul><li>mysql的数据目录路径<code>/var/lib/mysql</code></li><li>配置文件路径<code>/etc/mysql/my.cnf</code></li><li>初始化脚本路径<code>/docker-entrypoint-initdb.d</code></li></ul></li><li><p>设计本地挂载目录</p><ul><li><code>/root/mysql/init</code>-&gt; <code>/docker-entrypoint-initdb.d</code></li><li><code>/root/mysql/data</code>-&gt; <code>/var/lib/mysql</code></li><li><code>/root/mysql/conf</code>-&gt;<code>/etc/mysql/my.cnf</code></li><li>注意：本地目录需要绝对路径（&#x2F; 或.&#x2F; 开头），否则会以为是数据卷挂载</li></ul></li><li><p>创建本地目录mysql</p><ul><li><code>mkdir data | mkdir init | mkdir conf</code></li><li>导入黑马的sql和配置文件</li></ul></li><li><p>命令脚本</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  <span class="literal">-v</span> ./mysql/<span class="keyword">data</span>:/var/lib/mysql \</span><br><span class="line">  <span class="literal">-v</span> ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  <span class="literal">-v</span> ./mysql/init:/docker<span class="literal">-entrypoint-initdb</span>.d \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure></li><li><p>通过Navicat等连接mysql查看是否有hmall数据库</p></li></ul></li></ul></li></ul><h4 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h4><ul><li><p>镜像结构</p><ul><li>镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖</li><li>因此，自定义镜像本质就是依次准备好程序运行的<strong>基础环境、依赖、应用本身、运行配置</strong>等文件，分成打包</li><li>举个例子，我们要从0部署一个Java应用，大概流程是这样：<ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行Jar包</li></ul></li><li>那因此，我们打包镜像也是分成这么几步：<ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li><li>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong></li><li>镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作</li><li>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像；然后再搭建其它层即可</li><li>最终整个Java项目的镜像结构如图所示<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/oPfvIlQ2eBN8aRS.png" alt="img"></li></ul></li></ul></li></ul></li><li><p><strong>DockerFile</strong></p><ul><li><p>记录镜像结构的文件</p></li><li><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可</p></li><li><p>对应语法</p><ul><li><table><thead><tr><th align="center"><strong>指令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="center"><strong>FROM</strong></td><td align="center">指定基础镜像</td><td align="center"><code>FROM centos:6</code></td></tr><tr><td align="center"><strong>ENV</strong></td><td align="center">设置环境变量，可在后面指令使用</td><td align="center"><code>ENV key value</code></td></tr><tr><td align="center"><strong>COPY</strong></td><td align="center">拷贝本地文件到镜像的指定目录</td><td align="center"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="center"><strong>RUN</strong></td><td align="center">执行Linux的shell命令，一般是安装过程的命令</td><td align="center"><code>RUN yum install gcc</code></td></tr><tr><td align="center"><strong>EXPOSE</strong></td><td align="center">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="center">EXPOSE 8080</td></tr><tr><td align="center"><strong>ENTRYPOINT</strong></td><td align="center">镜像中应用的启动命令，容器运行时调用</td><td align="center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table></li><li><p>示例</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>问题</p><ul><li>以后会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，极其麻烦</li><li>所以，就有人提供了基础的系统+JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置</li></ul><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>构建镜像</p><ul><li><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了</p></li><li><p>导入hm资料中的demo项目及对应的Dockerfile</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/ErTV7nvMLJA2lRj.png" alt="img"></li></ul></li><li><p>将<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录</p></li><li><p>构建命令</p><ul><li>进入demo目录<code>cd /root/demo</code></li><li><code>docker build -t docker-demo:1.0 .</code></li></ul></li><li><p>命令说明</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0（版本号）</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，</li><li>也可以直接指定Dockerfile目录 <code>docker build -t docker-demo:1.0 /root/demo</code></li></ul></li><li><p>查看镜像列表<code>docker images</code></p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/BS9rsWhfMTNHzLj.png" alt="img"></li></ul></li><li><p>然后尝试运行该镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建并运行容器</span></span><br><span class="line">docker run --name <span class="built_in">dd</span> -p 8080:8080 -d docker-demo:1.0</span><br><span class="line"><span class="comment"># 2.查看容器</span></span><br><span class="line">docker ps -a </span><br><span class="line"><span class="comment"># 3.查看容器运行日志</span></span><br><span class="line">docker logs -f <span class="built_in">dd</span></span><br><span class="line"><span class="comment"># 3.访问</span></span><br><span class="line">虚拟机地址:8080/hello/count</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li><p>Java项目往往需要访问其它各种中间件，例如MySQL、Redis等</p><ul><li>在以往的的单体项目中都是通过导入依赖、配置文件进行访问</li></ul></li><li><p>那容器之间能否互相访问吗？</p><ol><li>进入dd容器<code>docker exec -it dd bash</code></li><li><code>ping ip地址(其他容器)</code></li><li>结果：可以ping通，说明容器之间可以通过ip地址互相访问</li></ol></li><li><p>容器的ip从何而来？</p><ol><li><p>在安装docker时，docker会在虚拟机创建一张网卡<code>docker0</code>，该网卡会创建虚拟网桥<code>172.17.0.1/16</code></p></li><li><p>默认情况下，所有容器都是以“桥接”方式连接到Docker的一个虚拟网桥上，从而得到一个ip</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/bdXyZKP5Qe4JmiI.png" alt="img"></li></ol></li></ol></li><li><p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接失败</p></li><li><p><strong>自定义网络</strong></p><ul><li><p>docker的网络功能</p><ul><li>创建自定义网络，形成新的网桥，加入该网桥的容器可以互联，且加入自定义网络的容器可以通过容器名互相访问</li></ul></li><li><p>常见命令</p><ul><li><table><thead><tr><th align="center"><strong>命令</strong></th><th align="center"><strong>说明</strong></th><th align="center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="center">docker network create</td><td align="center">创建一个网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="center">docker network ls</td><td align="center">查看所有网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="center">docker network rm</td><td align="center">删除指定网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="center">docker network prune</td><td align="center">清除未使用的网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="center">docker network connect</td><td align="center">使指定容器连接加入某网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="center">docker network disconnect</td><td align="center">使指定容器连接离开某网络</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="center">docker network inspect</td><td align="center">查看网络详细信息</td><td align="center"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table></li><li><p><code>docker network --help</code></p></li></ul></li><li><p>示例</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1创建新网络</span></span><br><span class="line">docker network create heima</span><br><span class="line"><span class="comment">#2使指定容器连接加入网络</span></span><br><span class="line">docker network connect 网络名 容器名</span><br><span class="line"><span class="comment">#2(2)使指定容器连接加入网络,在容器创建时就加入</span></span><br><span class="line">docker run <span class="literal">--name</span> dd <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">8080</span> <span class="literal">--network</span> heima <span class="literal">-d</span> docker<span class="literal">-demo</span></span><br><span class="line"><span class="comment">#3进入dd容器中</span></span><br><span class="line">ping 加入该网络的容器名</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><ul><li><p>部署Java项目</p><ol><li>将项目打包</li><li>将项目的hm-service.jar包和dockerfile文件上传至<code>/root/</code>下，构建镜像<code>docker build -t hmall:1.0 /root </code></li><li>创建容器<code>docker run -d --name hmall --network heima -p 8080:8080 hmall</code></li><li>测试，通过浏览器访问：<code>http://你的虚拟机地址:8080/search/list</code></li></ol></li><li><p>部署前端</p><ol><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/w1IveckyO24Q6t7.png" alt="ing"></p></li><li><p>把nginx目录上传到虚拟机的<code>/root</code>目录下</p></li><li><p>实现本地目录挂载</p><ol><li><code>/root/nginx/nginx.conf</code>挂载到<code>/etc/nginx/nginx.conf</code></li><li><code>/root/nginx/html</code>挂载到<code>/usr/share/nginx/html</code></li></ol></li><li><p>创建nginx容器</p><ol><li><p>由于需要让nginx同时代理hmall-portal和hmall-admin两套前端资源，因此我们需要暴露两个端口</p><ol><li>18080：对应hmall-portal</li><li>18081：对应hmall-admin</li></ol></li><li><p>命令如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name nginx \</span><br><span class="line">  -p 18080:18080 \</span><br><span class="line">  -p 18081:18081 \</span><br><span class="line">  -v /root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">  --network hmall \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure></li></ol></li><li><p>测试，通过浏览器访问：<code>http://你的虚拟机ip:18080</code></p></li></ol></li><li><p><strong>DockerCompose</strong></p><ul><li><p>稍微复杂的项目，其中还有各种各样的其它中间件，需要部署的东西远不止3个；如果还像之前那样手动的逐一部署，就太麻烦</p></li><li><p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>；它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器</p></li><li><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）；由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似</p><ul><li><p>用docker run部署MySQL的命令如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure></li><li><p>如果用<code>docker-compose.yml</code>文件来定义</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="comment">#多服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># mysql服务</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>黑马商城的部署文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="comment"># 依赖</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="comment">#网络创建</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>docker compose的命令</p><ul><li>命令格式<code>docker compose [OPTIONS] [COMMAND]</code></li><li>其中，OPTIONS和COMMAND都是可选参数，比较常见的有<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/13/qXnR24BC8OFmM1h.png" alt="img"></li></ul></li></ul></li></ul><hr><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><ul><li>根据黑马课程，导入黑马商城</li></ul><h2 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h2><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><ul><li>单体架构：顾名思义，整个项目中所有功能模块都在一个工程中开发；项目部署时需要对所有模块一起编译、打包；项目的架构设计、开发模式都非常简单<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/14/cCZJiLBnTauj1Ef.jpg" alt="ing"></li></ul></li><li>优点<ul><li>架构简单</li><li>部署成本低</li></ul></li><li>缺点<ul><li>团队协作成本高<ul><li>试想一下，你们团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊；最终要把功能合并到一个分支，你绝对会陷入到解决冲突的泥潭之中</li></ul></li><li>系统发布效率低<ul><li>任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时</li></ul></li><li>系统可用性差<ul><li>单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用</li><li>当某一个接口高并发时，对tomcat的资源占用极大，导致其他接口请求速度降慢</li></ul></li></ul></li><li>总结<ul><li>单体架构可用性是比较差的，功能之间相互影响比较大，适合开发功能相对简单，规模较小的项目</li></ul></li></ul><h3 id="微服务-1"><a href="#微服务-1" class="headerlink" title="微服务"></a>微服务</h3><ul><li>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点<ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过10人（2张披萨能喂饱）</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/14/vfd8lWwXqH7SDgn.jpg" alt="img"></li></ul></li><li>微服务解决了哪些单体项目的问题<ol><li>降低团队协作成本<ul><li>由于服务拆分，每个服务代码量大大减少，参与开发的后台人员在1~3名，协作成本大大降低</li></ul></li><li>提高系统发布效率<ul><li>每个服务都是独立部署，当有某个服务有代码变更时，只需要打包部署该服务即可</li></ul></li><li>提高系统可用性<ul><li>每个服务独立部署，并且做好服务隔离，使用自己的服务器资源，不会影响到其它服务</li><li>不会因为某一个高并发功能而影响其他接口</li></ul></li><li>综上所述，微服务架构解决了单体架构存在的问题，特别适合大型互联网项目的开发，因此被各大互联网公司普遍采用。大家以前可能听说过<strong>分布式架构</strong>，分布式就是服务拆分的过程，其实微服务架构正是分布式架构的一种最佳实践的方案</li></ol></li><li>微服务架构(拆分的过程中)存在的问题<ol><li>如果出现跨服务的业务该如何处理?</li><li>页面请求到底该访问哪个服务？</li><li>如何实现各个服务之间的服务隔离？</li></ol></li></ul><h3 id="SpringCloud-微服务框架"><a href="#SpringCloud-微服务框架" class="headerlink" title="SpringCloud(微服务框架)"></a>SpringCloud(微服务框架)</h3><ul><li>微服务拆分碰到的各种问题都有对应的解决方案和微服务组件，而SpringCloud框架可以说是目前Java领域最全面的微服务组件的集合<ul><li>官方链接<code>https://spring.io/projects/spring-cloud/#overview</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/14/rTHBYRNG1fSzlDx.png" alt="img"></li></ul></li><li>SpringCloud依托于SpringBoot的自动装配能力，大大降低了其项目搭建、组件使用的成本。对于没有自研微服务组件能力的中小型企业，使用SpringCloud全家桶来实现微服务开发可以说是最合适的选择</li><li>SpringCloud版本、SpringBoot版本以及JDK版本需要对应</li></ul><h2 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h2><h3 id="微服务拆分原则"><a href="#微服务拆分原则" class="headerlink" title="微服务拆分原则"></a>微服务拆分原则</h3><ul><li>什么时候拆<ul><li>对于<strong>大多数小型项目来说，一般是先采用单体架构</strong>，随着用户规模扩大、业务复杂后<strong>再逐渐拆分为</strong>微服务架构。这样初期成本会比较低，可以快速试错。但是，这么做的问题就在于后期做服务拆分时，可能会遇到很多代码耦合带来的问题，拆分比较困难（<strong>前易后难</strong>）</li><li>而对于一些大型项目，在立项之初目的就很明确，为了长远考虑，在架构设计时就直接选择微服务架构。虽然前期投入较多，但后期就少了拆分服务的烦恼（<strong>前难后易</strong>）</li></ul></li><li>如何拆<ul><li>微服务拆分时<strong>粒度要小</strong>，这其实是拆分的目标。具体可以从两个角度来分析<ul><li><strong>高内聚</strong>：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高</li><li><strong>低耦合</strong>：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强</li></ul></li><li>明确了拆分目标，接下来就是拆分方式了。我们在做服务拆分时一般有两种方式<ul><li><strong>纵向</strong>拆分<ul><li>所谓<strong>纵向拆分</strong>，就是按照项目的功能模块来拆分。例如黑马商城中，就有用户管理功能、订单管理功能、购物车功能、商品管理功能、支付功能等。那么按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性</li></ul></li><li><strong>横向</strong>拆分<ul><li>而<strong>横向拆分</strong>，是看各个功能模块之间有没有公共的业务部分，如果有将其抽取出来作为通用服务。例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。因此消息发送、风控数据记录就是通用的业务功能，因此可以将他们分别抽取为公共服务：消息中心服务、风控管理服务。这样可以提高业务的复用性，避免重复开发。同时通用业务一般接口稳定性较强，也不会使服务之间过分耦合</li></ul></li></ul></li><li>这里采用的是<strong>纵向</strong>拆分的方式<ul><li>用户服务</li><li>商品服务</li><li>订单服务</li><li>购物车服务</li><li>支付服务</li></ul></li></ul></li></ul><h3 id="拆分服务"><a href="#拆分服务" class="headerlink" title="拆分服务"></a>拆分服务</h3><ul><li><p>工程结构</p><ul><li>独立Project<ul><li>多个project</li></ul></li><li>Maven聚合<ul><li>一个工程，多个子module</li></ul></li><li>这里黑马商城采用的是Maven聚合的方式</li></ul></li><li><p>需求</p><ol><li>将hm-service中与商品管理相关功能拆分到一个微服务module中，命名为item-service</li><li>将hm-service中与购物车有关的功能拆分到一个微服务module中，命名为cart-service</li><li>将hm-service中与用户有关的功能拆分到一个微服务module中，命名为user-service</li><li>将hm-service中与交易有关的功能拆分到一个微服务module中，命名为trade-service</li><li>将hm-service中与支付有关的功能拆分到一个微服务module中，命名为pay-service</li></ol></li><li><p>需求实现</p><ol><li>在hmall工程中新建对应的item-service模块</li><li>新建<code>com.hmall.item</code>包</li><li>新建<code>ItemApplication</code>启动类在<code>com.hmall.item</code>包下</li><li>在<code>com.hmall.item</code>包新建<code>domain、mapper、service、controller</code>包</li><li>在<code>hmall-service</code>中拷贝配置文件到<code>item-service</code>的Resources中，修改其中的端口、以及一些关于<code>item</code>的配置</li><li>将<code>hmall-service</code>中各个有关<code>item</code>的类复制到<code>item-service</code>中，修改异常</li><li>测试实现，在Service中启动<code>item-service</code>，通过doc文档验证接口是否正确</li></ol></li><li><p>其他需求的实现基本同上，可能需要补充其他package</p></li></ul><h3 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h3><ul><li><p>在拆分的时候，我们发现一个问题：就是购物车业务中需要查询商品信息，但商品信息查询的逻辑全部迁移到了<code>item-service</code>服务，导致我们无法查询</p></li><li><p>最终结果就是查询到的购物车数据不完整，因此要想解决这个问题，我们就必须改造其中的代码，把原本本地方法调用，改造成跨微服务的远程调用（RPC，即<strong>R</strong>emote <strong>P</strong>roduce <strong>C</strong>all）</p></li><li><p>因此，现在查询购物车列表的流程变成了这样</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/15/lMZ8hJVdrLKnf4i.png" alt="img"></li></ul></li><li><p>RPC的实现方式有很多，比如</p><ul><li>基于Http协议</li><li>基于Dubbo协议</li><li>hm中使用的是Http方式，这种方式不关心服务提供者的具体技术实现，只要对外暴露Http接口即可，更符合微服务的需要</li></ul></li><li><p>问题是如何实现跨服务调用呢？</p><ol><li>浏览器到购物车是通过一个http请求，所以在两个Java项目中也可以通过一个http请求来实现服务调用获取商品信息</li><li>Spring提供了一个RestTemplate的API，可以方便的实现Http请求的发送<ol><li>其支持常见的Get、Post、Put、Delete请求，如果请求参数比较复杂，还可以使用<code>exchange()</code>方法来构造请求</li></ol></li><li>使用RestTemplate发送http请求只需要注意以下四点<ol><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ol></li></ol></li><li><p>具体是实现</p><ol><li><p>首先需要设置RestTemplate的配置类，将RestTemplate作为一个Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改<code>cart-service</code>中查询商品的方法</p><ol><li>其中的暂时<code>itemDto</code>从<code>item-service</code>复制到<code>cart-service</code>中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.查询商品</span></span><br><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; responseEntity = restTemplate.exchange(</span><br><span class="line">        <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">        HttpMethod.GET,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">);</span><br><span class="line"><span class="comment">//解析响应</span></span><br><span class="line"><span class="keyword">if</span> (!responseEntity.getStatusCode().is2xxSuccessful()) &#123;</span><br><span class="line">    <span class="comment">//查询失败</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;ItemDTO&gt; items = responseEntity.getBody();</span><br></pre></td></tr></table></figure></li></ol></li><li><p>重启两个服务，通过接口文档调用”查询购物车列表“接口，购物车信息应该完整</p></li><li><p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者</p></li><li><p>通过RestTemplate手动实现接口调用的方式仍然存在问题</p></li></ul><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><ul><li>服务调用时存在的问题<ol><li>item-service这么多实例，cart-service如何知道每一个实例的地址？</li><li>http请求要写url地址，<code>cart-service</code>服务到底该调用哪个实例呢？</li><li>如果在运行过程中，某一个<code>item-service</code>实例宕机，<code>cart-service</code>依然在调用该怎么办？</li><li>如果并发太高，<code>item-service</code>临时多部署了N台实例，<code>cart-service</code>如何知道新实例的地址？</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/16/1lrZPSVAy4bd8kN.png" alt="img"></li></ol></li><li>为了解决上述问题，就必须引入注册中心的概念</li></ul><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><ol><li>在微服务远程调用的过程中，包括两个角色<ul><li>服务提供者：提供接口供其它微服务访问，比如<code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如<code>cart-service</code></li></ul></li><li>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/16/6GnOrhqJyIW51QN.jpg" alt="img"></li></ol></li><li>流程如下<ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡（随机、轮询算法），挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul></li><li>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？<ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求检测）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表（推送变更）</li></ul></li><li>注册中心，解决了服务调用时存在的问题，但其实现较为复杂，不过有许多开源框架可以使用</li></ol><h3 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h3><ul><li><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li><strong>Eureka</strong>：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li><strong>Nacos</strong>：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用<ul><li>官网<code>https://nacos.io/zh-cn/</code></li></ul></li><li><strong>Consul</strong>：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul></li><li><p><strong>基于Docker来部署Nacos的注册中心</strong></p><ol><li><p>准备MySQL数据库表，用来存储Nacos的数据</p></li><li><p>由于是Docker部署，将资料中的SQL文件导入到<strong>Docker中的MySQL容器</strong></p></li><li><p>修改黑马资料中<code>nacos/custom.env</code>文件，有一个MYSQL_SERVICE_HOST也就是mysql地址，需要修改为自己的虚拟机IP地址</p></li><li><p>将资料中的<code>nacos</code>和<code>nacos.tar</code>目录上传至虚拟机的<code>/root</code>目录</p></li><li><p>docker拉取镜像&amp;创建容器</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加载image</span></span><br><span class="line">docker load <span class="literal">-i</span> nacos.tar</span><br><span class="line"><span class="comment">#创建容器</span></span><br><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line"><span class="literal">--name</span> nacos \</span><br><span class="line"><span class="literal">--env-file</span> ./nacos/custom.env \</span><br><span class="line"><span class="literal">-p</span> <span class="number">8848</span>:<span class="number">8848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9848</span>:<span class="number">9848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9849</span>:<span class="number">9849</span> \</span><br><span class="line"><span class="literal">--restart</span>=always \</span><br><span class="line">nacos/nacos<span class="literal">-server</span>:v2.<span class="number">1.0</span><span class="literal">-slim</span></span><br></pre></td></tr></table></figure></li><li><p>启动完成后，访问下面地址：http:&#x2F;&#x2F;虚拟机IP地址:8848&#x2F;nacos</p></li><li><p>首次访问会跳转到登录页，<strong>账号密码都是nacos</strong></p></li></ol></li></ul><h3 id="基于Nacos实现服务注册"><a href="#基于Nacos实现服务注册" class="headerlink" title="基于Nacos实现服务注册"></a>基于Nacos实现服务注册</h3><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">  <span class="comment">#服务名</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="comment">#服务地址</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure></li><li><p>启动多个服务，查看nacos即可</p></li></ul><h3 id="基于Nacos实现服务发现"><a href="#基于Nacos实现服务发现" class="headerlink" title="基于Nacos实现服务发现"></a>基于Nacos实现服务发现</h3><ul><li><p>引入依赖、配置信息与前文一致（服务调用者也可以是服务提供者）</p></li><li><p>接下来，服务调用者<code>cart-service</code>订阅<code>item-service</code>服务了</p><ul><li><p><code>item-service</code>有多个实例，而真正发起调用时只需要知道一个实例的地址；因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问‘；常见的负载均衡算法有</p><ul><li><p>随机</p></li><li><p>轮询</p></li><li><p>IP的hash</p></li><li><p>最近最少访问</p></li></ul></li></ul></li><li><p>这里基于随机算法实现负载均衡</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取discoveryClient对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryClient;</span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="comment">//通过注册中心获取商品实例</span></span><br><span class="line">List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;item-service&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (instances == <span class="literal">null</span> || instances.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));</span><br><span class="line"><span class="comment">//实例的ip和端口</span></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> serviceInstance.getUri();</span><br><span class="line"><span class="comment">// 2.查询商品</span></span><br><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; responseEntity = restTemplate.exchange(</span><br><span class="line">        uri + <span class="string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">        HttpMethod.GET,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>通过swagger文档测试，实现远程调用，如商品实例控制台分别输出（先全部清空）</li></ul><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>利用Nacos实现了服务的治理，利用RestTemplate实现了服务的远程调用，但是远程调用的代码太复杂了</li><li>远程调用的关键点就在于四个参数<ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul></li><li><strong>OpenFeign</strong>利用SpringMVC的相关注解来声明以上4个参数，然后基于动态代理帮我们生成远程调用的代码，替换掉RestTemplate</li><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器 旧版中`ribbon`是一种负载均衡器，但一般都是用nginx这种网关来做反向代理和负载均衡--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在<code>cart-service</code>启动类上添加注解<code>@EnableFeignClients</code>，启动OpenFeign功能</li><li>编写Feign客户端</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>客户端详情</p><ul><li>声明接口，无需实现方法；接口中的几个关键信息<ul><li><code>@FeignClient(&quot;item-service&quot;)</code> ：声明服务的名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping(&quot;/items&quot;)</code> ：声明请求路径</li><li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul></li><li>有了上述信息，OpenFeign就可以利用动态代理实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code></li></ul></li><li><p>获取商品信息代码就可简化为</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取itemClient实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ItemClient itemClient;</span><br><span class="line"><span class="comment">//直接调用接口即可</span></span><br><span class="line">List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br></pre></td></tr></table></figure><ul><li>通过Swagger文档调式</li></ul><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><ul><li><p>原理，观看hm视频</p><ul><li>OpenFeign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：<ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池（苍穹外卖实现过）</li><li>OKHttp：支持连接池</li></ul></li><li>通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，使用OK Http</li></ul></li><li><p>使用OKHttp连接池</p><ul><li>引依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在<code>cart-service</code>的<code>application.yml</code>配置文件中开启Feign的连接池功能</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure></li><li><p>验证，在<code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code>中的<code>execute</code>方法中打断点，查看<code>delegate</code></p></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>面对的问题<ul><li>当更多其它的服务需要<code>item-service</code>越来越多时，按照前文的实现，就会创建重复的代码<code>ItemClent</code></li><li>以及<code>ItemDto</code>也会重复导入其他服务的dto包中</li></ul></li><li>解决方案<ul><li>避免重复编码的办法就是<strong>抽取</strong>。不过这里有两种抽取思路：<ul><li>思路1：抽取到微服务之外的公共module</li><li>思路2：每个微服务自己抽取一个module</li></ul></li><li>如图<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/17/KyqLjRZO8AeCrdo.jpg" alt="imag"></li></ul></li><li>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低</li></ul></li><li>这里使用方案1<ol><li>定义公共module：<code>hm-api</code></li><li>引入公共依赖</li><li>定义<code>client和dto</code>包结构以及导入相关包</li><li>解决<code>private final ItemClient itemClient;</code>无法找到bean报错<ul><li>因为<code>ItemClient</code>现在定义到了<code>com.hmall.api.client</code>包下，而<code>cart-service</code>的启动类定义在<code>com.hmall.cart</code>包下，扫描不到<code>ItemClient</code>，所以报错</li><li>解决：在<code>cart-service</code>的启动类上添加声明即可<ol><li>声明扫描包<code>@EnableFeignClients(basePackages = &quot;com.hmall.api.clients&quot;)</code>（范围广）</li><li>声明要用的FeignClient <code>@EnableFeignClients(clients = &#123;ItemClient.class&#125;)</code>(更具体)</li></ol></li></ul></li></ol></li><li>通过swagger文档查询测试</li></ul><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><ul><li><p>OpenFeign只会在FeignClient所在包的日志级别为<strong>DEBUG</strong>时，才会输出日志。而且其日志级别有4级：</p><ul><li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li><li><strong>BASIC</strong>：仅记录请求的方法，URL以及响应状态码和执行时间</li><li><strong>HEADERS</strong>：在BASIC的基础上，额外记录了请求和响应的头信息</li><li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据</li></ul></li><li><p>Feign默认的日志级别就是NONE，所以默认我们看不到请求日志</p></li><li><p>实现</p><ol><li><p>定义一个配置类，在<code>hm-api</code>中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生效</p><ol><li>局部生效：<code>@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class)</code></li><li>全局生效：<code>@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)</code></li></ol></li></ol></li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>将hm-service中的其它业务也都拆分为微服务，并基于OpenFeign完善功能</p><ul><li>user-service：用户微服务，包含用户登录、管理等功能</li><li>trade-service：交易微服务，包含订单相关功能</li><li>pay-service：支付微服务，包含支付相关功能</li></ul><p>其中交易服务、支付服务、用户服务中的业务都需要知道当前登录用户是谁，暂时写死</p><h3 id="用户微服务"><a href="#用户微服务" class="headerlink" title="用户微服务"></a>用户微服务</h3><p>用户微服务需要将<code>hm-service</code>中的config包下的<code>JwtProperties、SecurityConfig </code>类导入到<code>user-service</code>模块下</p><ul><li>JwtProperties是JsonWebToken的属性配置</li><li>SecurityConfig读取JwtProperties的信息，以及创建一个PasswordEncoder的bean用于”密码的判断”</li></ul><p>将<code>hm-service</code>中的utils包下的<code>JwtTool</code>类导入到<code>user-service</code>模块下</p><ul><li>JwtTool类主要是创建token和解析token</li></ul><p>由于拦截器和拦截器的配置没有导入，所以这个token也等同于没有，对登录&#x2F;扣款代码中的<code>UserContext.getUser()</code>统一写为<code>1L</code>。</p><p>通过swagger接口文档进行调试</p><h3 id="交易微服务"><a href="#交易微服务" class="headerlink" title="交易微服务"></a>交易微服务</h3><p>从<code>controller</code>包发现，一共有三个接口</p><ol><li><code>@ApiOperation(&quot;根据id查询订单&quot;)</code></li><li><code>@ApiOperation(&quot;创建订单&quot;)</code></li><li><code>@ApiOperation(&quot;标记订单已支付&quot;)</code></li></ol><p>只有创建订单<code>createOrder()</code>是需要进行远程调用</p><ul><li><code>private final ItemClient itemClient;</code>查询和修改商品信息</li><li><code>private final CartClient cartClient;</code>清空购物车的缓存</li></ul><p>配置信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span></span><br><span class="line"><span class="comment"># okhttp连接池</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在<code>hm-api</code>中</p><ul><li><p><code>ItemCliemt</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; items)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>CartClient</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;cart-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CartClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/carts&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteCartItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>启动类注解以及配置信息</p><ul><li><code>@EnableFeignClients(clients = &#123;ItemClient.class, CartClient.class&#125;,defaultConfiguration = DefaultFeignConfig.class)</code></li></ul><p>完整的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">createOrder</span><span class="params">(OrderFormDTO orderFormDTO)</span> &#123;</span><br><span class="line">    <span class="comment">//订单数据</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    <span class="comment">//查询商品</span></span><br><span class="line">    List&lt;OrderDetailDTO&gt; detailDTOS = orderFormDTO.getDetails();</span><br><span class="line">    <span class="comment">//获取商品id和商品数量的Map</span></span><br><span class="line">    Map&lt;Long, Integer&gt; itemNumMap = detailDTOS.stream()</span><br><span class="line">            .collect(Collectors.toMap(OrderDetailDTO::getItemId, OrderDetailDTO::getNum));</span><br><span class="line">    <span class="comment">//所有的商品id</span></span><br><span class="line">    Set&lt;Long&gt; itemIds = itemNumMap.keySet();</span><br><span class="line">    <span class="comment">//查询商品client</span></span><br><span class="line">    List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br><span class="line">    <span class="keyword">if</span> (items == <span class="literal">null</span> || items.size() &lt; itemIds.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&quot;商品不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于商品价格、购买数量计算商品总价：totalFee</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ItemDTO item : items) &#123;</span><br><span class="line">        total += item.getPrice() * itemNumMap.get(item.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    order.setTotalFee(total);</span><br><span class="line">    <span class="comment">//订单其它属性</span></span><br><span class="line">    order.setPaymentType(orderFormDTO.getPaymentType());</span><br><span class="line">    order.setUserId(<span class="number">1L</span>);<span class="comment">// TODO 下单用户</span></span><br><span class="line">    order.setStatus(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将Order写入数据库order表中</span></span><br><span class="line">    save(order);</span><br><span class="line">    <span class="comment">//保存订单详情</span></span><br><span class="line">    List&lt;OrderDetail&gt; details = buildDetails(order.getId(), items, itemNumMap);</span><br><span class="line">    detailService.saveBatch(details);</span><br><span class="line">    <span class="comment">//清理购物车商品client</span></span><br><span class="line">    cartClient.deleteCartItemByIds(itemIds);</span><br><span class="line">    <span class="comment">//扣减库存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        itemClient.deductStock(detailDTOS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Swagger调式“创建订单”接口是否完成了远程调用</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;addressId&quot;</span><span class="punctuation">:</span> <span class="number">59</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;itemId&quot;</span><span class="punctuation">:</span> <span class="number">317578</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;num&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;itemId&quot;</span><span class="punctuation">:</span> <span class="number">546872</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;num&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;paymentType&quot;</span><span class="punctuation">:</span> <span class="number">3</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="支付微服务"><a href="#支付微服务" class="headerlink" title="支付微服务"></a>支付微服务</h3><p>从<code>PayController</code>发现两个接口</p><ul><li><code>@ApiOperation(&quot;生成支付单&quot;)</code></li><li><code>@ApiOperation(&quot;尝试基于用户余额支付&quot;)</code></li></ul><p>在生成支付单的接口中，仅仅需要修改实现类中的<code>buildPayOrder(PayApplyDTO payApplyDTO)</code>方法</p><ul><li>该接口用来生成支付订单</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PayOrder <span class="title function_">buildPayOrder</span><span class="params">(PayApplyDTO payApplyDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.数据转换</span></span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> BeanUtils.toBean(payApplyDTO, PayOrder.class);</span><br><span class="line">    <span class="comment">// 2.初始化数据</span></span><br><span class="line">    payOrder.setPayOverTime(LocalDateTime.now().plusMinutes(<span class="number">120L</span>));</span><br><span class="line">    payOrder.setStatus(PayStatus.WAIT_BUYER_PAY.getValue());</span><br><span class="line">    payOrder.setBizUserId(<span class="number">1L</span>); <span class="comment">//TODO UserContext.getUser()</span></span><br><span class="line">    <span class="keyword">return</span> payOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在“尝试基于用户余额支付”接口中，需要对用户和订单服务进行远程调用</p><ul><li>导入相关依赖在<code>pay-service</code></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--公共api--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>nacos属性配置</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span></span><br><span class="line"><span class="comment"># okhttp连接池</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>用户和订单的远程调用接口</p><ul><li><p>余额支付</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;user-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/users/money/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductMoney</span><span class="params">(<span class="meta">@RequestParam(&quot;pw&quot;)</span> String pw,<span class="meta">@RequestParam(&quot;amount&quot;)</span> Integer amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改订单状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;trade-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/orders/&#123;orderId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>开启OpenFeign注解</p><ul><li><code>@EnableFeignClients(basePackages = &quot;com.hmall.api.clients&quot;,defaultConfiguration = DefaultFeignConfig.class)</code></li></ul><p>具体代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OrderClient orderClient;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPayOrderByBalance</span><span class="params">(PayOrderFormDTO payOrderFormDTO)</span> &#123;</span><br><span class="line">    <span class="comment">//查询支付单</span></span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">po</span> <span class="operator">=</span> getById(payOrderFormDTO.getId());</span><br><span class="line">    <span class="comment">//判断状态</span></span><br><span class="line">    <span class="keyword">if</span> (!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus())) &#123;</span><br><span class="line">        <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试扣减余额client</span></span><br><span class="line">    userClient.deductMoney(payOrderFormDTO.getPw(), po.getAmount());</span><br><span class="line">    <span class="comment">//修改支付单状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> markPayOrderSuccess(payOrderFormDTO.getId(), LocalDateTime.now()</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记订单已支付client</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">bizOrderNo</span> <span class="operator">=</span> po.getBizOrderNo();</span><br><span class="line">    orderClient.updateById(bizOrderNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Swagger测试，验证远程调用是否成功</p><ul><li>先修改<code>pay-order</code>表中<code>status</code>字段为1（未支付）</li><li>支付单id是表中的id字段</li><li>支付订单id是表中的pay_order_no字段，密码为123</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>如何才能在每个微服务中都拿到用户信息？如何在微服务之间传递用户信息？</p><ul><li>初步想法<ul><li>把拦截器也重新拆分为一个微服务，这样<code>UserContext</code>类就可以获取token中的用户id，从而得到用户信息</li><li>不同服务的线程是否一致呢？确保<code>UserContext</code>在各个服务是如果可以互相联系线程的话，获取到的用户id也就一致</li></ul></li></ul><h3 id="前后联调"><a href="#前后联调" class="headerlink" title="前后联调"></a>前后联调</h3><p>黑马资料提供了一个<code>hmall-nginx</code>目录，其中包含了Nginx以及我们的前端代码</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/kglCi7uMhwqByAp.png" alt="img"></p><p>将其拷贝到一个不包含中文、空格、特殊字符的目录，启动后即可访问到页面</p><ul><li>18080端口是用户端页面</li><li>18081端口是管理端页面，黑马好像没有写完全这个管理端，访问18081端口报错</li></ul><p>之前<code>nginx</code>内部会将发向服务端请求全部代理到8080端口，但是现在拆分了N个微服务，8080不可用了。通过<code>Nginx</code>配置，完成对不同微服务的反向代理</p><ul><li>每一个服务都对应一个端口号，每个请求又对应着不同的服务，也就是不同请求的所访问的服务端口都不一致</li><li>确保每一个请求对应的服务一致，不再是之前统一的8080端口</li></ul><p>如何解决上述问题呢？需要用到微服务当中网关的知识了</p><h2 id="网关及配置管理"><a href="#网关及配置管理" class="headerlink" title="网关及配置管理"></a>网关及配置管理</h2><p>前景提要，碰到的问题</p><ul><li>由于每个微服务都有不同的地址或端口，入口不同，在与前端联调的时候出现一些问题<ul><li>请求不同数据时要访问不同的入口，需要维护多个入口地址，麻烦</li><li>前端无法调用nacos，无法实时更新服务列表</li></ul></li><li>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题<ul><li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li><li>当微服务之间调用时，该如何传递用户信息？</li></ul></li></ul><p>这些问题会通过<strong>网关</strong>技术解决</p><h3 id="何为网关？"><a href="#何为网关？" class="headerlink" title="何为网关？"></a>何为网关？</h3><p>顾明思议，网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一端网络传输到另一端网络时就需要经过网关来做数据的<strong>路由</strong>和<strong>转发</strong>以及数据安全的<strong>校验</strong></p><p>举个例子</p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/nt7jobRyFH1NJEM.jpg" alt="img"></p></li><li><p>网关就像是以前园区传达室的大爷</p><ul><li>路由就像是大爷到你寻找之地的路线</li><li>校验，就是大爷对你身份的怀疑和盘问</li></ul></li><li><p>外面的人要想进入园区，必须经过大爷的认可，如果你是不怀好意的人，肯定被直接拦截（身份验证）</p></li><li><p>外面的人要传话或送信，要找大爷，大爷帮你带给目标人（路由和转发）</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/pGM2RItxH954PCj.jpg" alt="imag"></p></li><li><p>现在，微服务网关就起到同样的作用。前端请求不能直接访问微服务，而是要先请求网关</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li><li>网关可以从Nacos注册中心中获取到服务列表以及具体服务的多个实例信息</li></ul></li></ul><p>在Spring Cloud中网关的实现包括两种：</p><ul><li><strong>Spring cloud Gateway</strong>：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li><li><strong>Netfilx Zuul</strong>：基于Servlet的阻塞式编程，需要调优才能获得与Spring cloud Gateway类似的性能</li></ul><h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li><p>创建网关微服务</p></li><li><p>引入SpringCloudGateway、NacosDiscovery依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置网关路由规则</strong></p><ul><li>在<code>hm-gateway</code>模块的<code>resources</code>目录新建一个<code>application.yaml</code>文件，内容如下：</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br></pre></td></tr></table></figure><ul><li>这样，当前端请求时，网关就会根据路由断言判断时哪一个微服务实例，然后再通过负载均衡调用从nacos获取到的实例</li></ul></li></ul><h4 id="路由属性"><a href="#路由属性" class="headerlink" title="路由属性"></a>路由属性</h4><p>yaml文件中每一个属性都有一个Java类，路由routes对应的Java类是<code>GatewayProperties</code></p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/8gPEKupAa6XOli7.png" alt="image"></p></li><li><p>是一个集合，也就是说可以定义很多路由规则。集合中的<code>RouteDefinition</code>就是具体的路由规则定义，其中常见的属性如下：</p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/gVHZ4DQOKMxkeat.png" alt="img"></p></li><li><p>四个属性含义如下：</p><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件</li><li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问</li></ul></li><li><p>这里我们重点关注<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p></li><li><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host(域名)</td><td align="left">- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method&#x3D;GET,POST</td></tr><tr><td align="left"><strong>Path</strong></td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query&#x3D;name, Jack或者- Query&#x3D;name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td align="left">weight</td><td align="left">权重处理</td><td align="left">Weight&#x3D;group1,2</td></tr><tr><td align="left">XForwardedRemoteAddr</td><td align="left">基于请求的来源IP做判断</td><td align="left">-XForwardedRemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr></tbody></table></li></ul></li><li><p><a href="https://spring.io/projects/spring-cloud-gateway/">官网示例</a></p></li></ul><p>路由过滤器，和拦截器功能有些相似，拦截请求和响应信息，可以做修改</p><p>网关中提供了33种路由过滤器，这里列举几种常见的路由</p><table><thead><tr><th>名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td><td>AddrequestHeader&#x3D;headerName,headerValue</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td><td>RemoveRequestHeader&#x3D;headerName</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td><td>AddResponseHeader&#x3D;headerName,headerVaLue</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td><td>RemoveResponseHeader&#x3D;headerName</td></tr><tr><td>RewritePath</td><td>请求路径重写</td><td>RewritePath&#x3D;&#x2F;red&#x2F;?(?<segment>.*),&#x2F;$\ {segment}</td></tr><tr><td>StripPrefix</td><td>去除请求路径中的N段前缀</td><td>StripPrefix&#x3D;1，则路径&#x2F;a&#x2F;b转发时只保留&#x2F;b</td></tr></tbody></table><p>局部配置路由过滤器</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=truth,never</span> <span class="string">give</span> <span class="string">up</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br></pre></td></tr></table></figure><p>全局配置路由过滤器</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=truth,never</span> <span class="string">give</span> <span class="string">up</span></span><br></pre></td></tr></table></figure><h3 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h3><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取</p><p><em><strong>鉴权思路分析</strong></em></p><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题</p><ul><li>每个微服务都需要知道JWT的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前所有的问题就解决了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/sxTuLYoZqbEOvHD.png" alt="image"></p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li></ul><p>不过，这里存在几个问题：</p><ul><li>网关路由是配置的，请求转发是Gateway内部代码，我们如何在转发之前做登录校验？</li><li>网关校验JWT之后，如何将用户信息传递给微服务？<ul><li>可以通过请求头拦截器添加用户id</li></ul></li><li>微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</li></ul><h4 id="内部的工作原理"><a href="#内部的工作原理" class="headerlink" title="内部的工作原理"></a>内部的工作原理</h4><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/22/cYQuBKo1yHa4vRW.png" alt="image"></p><p>如图所示</p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）</li><li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被转发到微服务</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑</li><li>最终把响应结果返回</li></ol><p>最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最后的一个，<strong>如果我们能够自定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到</strong><code>NettyRoutingFilter</code>之前，这就可以解决转发之前如何做登录校验的问题了</p><h4 id="自定义网关过滤器"><a href="#自定义网关过滤器" class="headerlink" title="自定义网关过滤器"></a>自定义网关过滤器</h4><p>网关过滤器链中的过滤器有两种</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code></li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由</li><li>注意过滤器链之外还有一种过滤器，<strong>HttpHeadersFilter</strong>，用来处理传递到下游微服务的请求头<ul><li>例如<code>org.springframework.cloud.gateway.filter.headers.XForwardedHeadersFilter</code>可以传递代理请求原本的host头到下游微服务</li></ul></li></ul><p>其实<code>GatewayFilter</code>和<code>GlobalFilter</code>这两种过滤器的方法签名完全一致</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理请求并将其传递给下一个过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exchange 当前请求的上下文，其中包含整个过滤器链内共享数据,如request、response等各种数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chain 过滤器链，基于它向下传递请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br></pre></td></tr></table></figure><p><code>FilteringWebHandler</code>在处理请求时，会将<code>GlobalFilter</code>装饰为<code>GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行</p><p>自定义GlobalFilter，在<code>hm-gateway</code>中新建一个<code>filters</code>包，实现一个全局过滤器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 登录校验</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">        System.out.println(<span class="string">&quot;headers =&quot;</span> + headers);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录校验的过滤器应该放在请求转发到微服务<code>NettyRoutingFilter</code>过滤器前，如何实现呢？</p><ul><li>查看<code>GlobalFilter</code>的实现可知<code>NettyRoutingFilter</code>过滤器能够在最后执行的原因是实现了<code>Ordered</code>接口，且排序字段<strong>ORDER</strong>为int最大值<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/t36LwvP5hzFRriT.png" alt="image"></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/beCm7MkDWS2KFPX.png" alt="img"></li><li><code>ORDER</code>值越小，优先级越高，排序越靠前</li></ul></li><li>所以只要实现<code>Ordered</code>接口，<code>ORDER</code>字段值小于<code>Integer.MAX_VALUE</code>即可</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>,Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 登录校验</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">        System.out.println(<span class="string">&quot;headers =&quot;</span> + headers);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>MyGlobalFilter</code>和<code>NettyRoutingFilter</code>的filter方法分别做断点调试</p><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code>，最简单的方式是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求</span></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;过滤器执行了&quot;</span>);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀！（方便后续配置）然后在yaml配置后才会生效</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><ul><li>既可以配置全局路由，也可以配置局部路由</li></ul><p>另外，这种过滤器还可以支持动态配置参数，示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="comment">// 父类泛型是内部类的Config类型</span></span><br><span class="line">                <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;PrintAnyGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span></span><br><span class="line">        <span class="comment">// - GatewayFilter：过滤器</span></span><br><span class="line">        <span class="comment">// - int order值：值越小，过滤器执行优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取config值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> config.getA();</span><br><span class="line">                <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> config.getB();</span><br><span class="line">                <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> config.getC();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">                System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置属性，成员变量名称很重要，下面会用到</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将变量名称依次返回，顺序很重要，将来读取参数时按该顺序获取</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回当前配置类的类型，也就是内部的Config</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;Config&gt; <span class="title function_">getConfigClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Config.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在yaml文件中使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny=1,2,3</span> <span class="comment"># 注意，这里多个参数以&quot;,&quot;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></span><br></pre></td></tr></table></figure><p>上面这种配置方式参数必须严格按照<code>shortcutFieldOrder()</code>方法的返回参数名顺序来赋值</p><p>还有一种用法，无需按照这个顺序，就是手动指定参数名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PrintAny</span></span><br><span class="line">              <span class="attr">args:</span> <span class="comment"># 手动指定参数名，无需按照参数顺序</span></span><br><span class="line">                <span class="attr">a:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">b:</span> <span class="number">2</span></span><br><span class="line">                <span class="attr">c:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这种过滤器的使用较少，一般都是定义全局过滤器</p><h4 id="自定义GlobalFilter实现登录校验"><a href="#自定义GlobalFilter实现登录校验" class="headerlink" title="自定义GlobalFilter实现登录校验"></a>自定义<code>GlobalFilter</code>实现登录校验</h4><p>登录校验需要JWT相关配置</p><ul><li>从<code>hm-service</code>服务config包下导出与登录校验有关的配置：<code>AuthProperties</code>、<code>JwtProperties</code>、<code>SecurityConfig</code></li><li>从<code>hm-service</code>服务utils包下导出<code>JwtUtil</code>工具类</li><li>从<code>hm-service</code>服务中的reasource文件中获取密钥<code>hmall.jks</code></li><li>从<code>hm-service</code>服务的yaml文件中复制对应的属性配置</li></ul><p>实现登录拦截过滤器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>,Ordered &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthProperties authProperties;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtTool jwtTool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//判断该请求是否需要拦截</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">RequestPath</span> <span class="variable">requestPath</span> <span class="operator">=</span> request.getPath();</span><br><span class="line">        <span class="keyword">if</span> (isExcludePath(requestPath.toString())) &#123;</span><br><span class="line">            <span class="comment">//不需要拦截</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">        List&lt;String&gt; requestHeader = headers.get(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//解析得到token</span></span><br><span class="line">        Long userId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = jwtTool.parseToken(requestHeader.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//拦截,设置401状态码</span></span><br><span class="line">            <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//传递用户信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;userId =&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isExcludePath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">//用于路径判断</span></span><br><span class="line">        List&lt;String&gt; excludePaths = authProperties.getExcludePaths();</span><br><span class="line">        <span class="keyword">for</span> (String excludePath : excludePaths) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPathMatcher.match(excludePath,path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需知</p><ul><li>响应状态码的设置API的调用</li><li>对于请求路径的判断API调用</li></ul><h4 id="网关传递用户到微服务"><a href="#网关传递用户到微服务" class="headerlink" title="网关传递用户到微服务"></a>网关传递用户到微服务</h4><p>通过设置请求头，把用户id传到微服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传递用户信息</span></span><br><span class="line"><span class="type">ServerWebExchange</span> <span class="variable">webExchange</span> <span class="operator">=</span> exchange.mutate() <span class="comment">//对下游请求做修改</span></span><br><span class="line">        .request(builder -&gt; builder.header(<span class="string">&quot;user-info&quot;</span>, userId.toString()))</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//放行</span></span><br><span class="line"><span class="keyword">return</span> chain.filter(webExchange);</span><br></pre></td></tr></table></figure><p>微服务获取该信息，可以在每个方法中都获取<code>user-info</code>这个请求头，不过太过麻烦，我们可以在微服务与网关转发之前，再加一个SpringMVC的拦截器，和以往一样，把该用户id保存在<code>ThreadLocal</code>中，如图所示</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/pFzPiCrJWKwI7as.png" alt="image"></p><p>由于每个微服务都有获取登录用户的需求，因此拦截器我们直接写在<code>hm-common</code>中，并写好自动装配。这样微服务只需要引入<code>hm-common</code>就可以直接具备拦截器功能，无需重复编写</p><p>用户信息拦截</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.校验token</span></span><br><span class="line">        <span class="keyword">if</span> (userId == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.存入上下文</span></span><br><span class="line">        UserContext.setUser(Long.valueOf(userId));</span><br><span class="line">        <span class="comment">// 4.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 清理用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>config配置，添加拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span><span class="comment">//表示仅对包含了springMvc的核心类生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.添加拦截器</span></span><br><span class="line">        <span class="type">UserInfoInterceptor</span> <span class="variable">userInfoInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>();</span><br><span class="line">        registry.addInterceptor(userInfoInterceptor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，需要注意的是，这个配置类默认是不会生效的，因为它所在的包是<code>com.hmall.common.config</code>，与其它微服务的扫描包不一致，无法被扫描到，因此无法生效</p><p>需要解决的2个问题：SpringBoot无法扫描到该配置、该拦截器仅仅只在SpringMVC中生效（hm-gatewary也引入了hm-common依赖）</p><ol><li><p>基于SpringBoot的自动装配原理，我们要将其添加到<code>resources</code>目录下的<code>META-INF/spring.factories</code>文件中</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">  com.hmall.common.config.MyBatisConfig,\</span></span><br><span class="line"><span class="string">  com.hmall.common.config.MvcConfig,\</span></span><br><span class="line"><span class="string">  com.hmall.common.config.JsonConfig</span></span><br></pre></td></tr></table></figure></li><li><p><code>@ConditionalOnClass</code>注解是Spring Boot中的一个条件注解，它可以用来指定在类路径中存在特定的类时才加载某个配置类或Bean</p><ul><li>在这里hm-gateway不是基于springMvc的，所以该MvcConfig不应该生效，否则该拦截器会有错误</li></ul></li></ol><p>修改其他微服务中用1L替换的<code>UserContext.getUser()</code>，通过Swagger进行调试</p><h4 id="微服务获取用户"><a href="#微服务获取用户" class="headerlink" title="微服务获取用户"></a>微服务获取用户</h4><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，流程如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/NKjDf8HL5vG7l4E.jpg" alt="image"></p><ul><li>下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户ID。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，而且微服务则是通过OpenFeign发送http请求到购物车服务，所以也不会有<code>user-info</code>的请求头信息！！！</li><li>所以，在购物车服务中的购物车清理过程中因为没有用户ID而失败</li><li>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong></li></ul><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p><ul><li><p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called for every request. </span></span><br><span class="line"><span class="comment">   * Add data using methods on the supplied &#123;<span class="doctag">@link</span> RequestTemplate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>openfeign每次发起远程调用前,都会被<code>RequestInterceptor</code>拦截，底层都会自动调用apply方法！！！</p></li><li><p>我们只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息</p></li><li><p>由于<code>FeignClient</code>全部都是在<code>hm-api</code>模块，因此我们在<code>hm-api</code>模块的<code>com.hmall.api.config.DefaultFeignConfig</code>中编写这个拦截器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">requestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate requestTemplate)</span> &#123;</span><br><span class="line">            <span class="comment">//引入hm-common依赖</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userInfo</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">            <span class="keyword">if</span> (userInfo != <span class="literal">null</span> )&#123;</span><br><span class="line">                requestTemplate.header(<span class="string">&quot;user-info&quot;</span>,userInfo.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样每次远程调用时，都会先拦截，添加<code>user-info</code>请求头</p></li></ul><h4 id="章节小结，一图概括"><a href="#章节小结，一图概括" class="headerlink" title="章节小结，一图概括"></a>章节小结，一图概括</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/23/A4cgCz8jTZwmJua.png" alt="image"></p><p>很多功能的实现依赖于拦截器的配置。</p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>看一看微服务中关于配置的问题：</p><ul><li>网关路由在配置文件中写死了，如果变更必须<strong>重启</strong>微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要<strong>重启</strong>服务</li><li>每个微服务都有很多重复的配置（接口文档、数据库、日志等），维护成本高</li></ul><p>每一次的重启都意味着，当时程序无法运行，着不仅对用户体验不好也增加了运维的工作量。不过也有着解决的方法，这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/dXhbDrm8EngGR7U.jpg" alt="img"></p><ul><li>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置<strong>热更新</strong></li><li>网关的路由同样是配置，因此同样可以基于这个功能实现<strong>动态路由</strong>功能，无需重启网关即可修改路由配置</li></ul><h3 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h3><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在Nacos中添加共享配置</li><li>微服务拉取配置</li></ul><p>这里先进行可以共享的nacos配置，在nacos配置管理下的配置列表栏中新建配置</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/nzZAbUMslgJCFKN.png" alt="image"></p><ul><li>jdbc共享配置</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;&#123;hm.db.host:192.168.80.132&#125;:$&#123;hm.db.port:3306&#125;/$&#123;hm.db.database&#125;?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">$&#123;hm.db.username&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.db.pw&#125;</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><ul><li>注意这里的jdbc的相关参数并没有写死，例如：<ul><li><code>数据库ip</code>：通过<code>$&#123;hm.db.host:192.168.80.132&#125;</code>配置了默认值为<code>192.168.80.132</code>，同时允许通过<code>$&#123;hm.db.host&#125;</code>来覆盖默认值</li><li><code>数据库端口</code>：通过<code>$&#123;hm.db.port:3306&#125;</code>配置了默认值为<code>3306</code>，同时允许通过<code>$&#123;hm.db.port&#125;</code>来覆盖默认值</li><li><code>数据库database</code>：可以通过<code>$&#123;hm.db.database&#125;</code>来设定，无默认值</li></ul></li><li>log共享配置</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmall:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>swagger共享配置</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">$&#123;hm.swagger.title:黑马商城接口文档&#125;</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">$&#123;hm.swagger.desc:&quot;黑马商城接口文档&quot;&#125;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">$&#123;hm.swagger.package&#125;</span></span><br></pre></td></tr></table></figure><ul><li>我们只需要在<code>application.yaml</code>中完善各自项目的配置信息即可</li></ul><p>将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化Spring Boot上下文，去读取<code>application.yaml</code>。也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos地址，该如何去加载nacos中的配置文件呢？</p><ul><li><p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的引导文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/yiUHbdR39FwZ2Np.jpg" alt="image"></p></li></ul><p>因此，微服务整合Nacos配置管理的步骤如下</p><ol><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>新建bootstrap.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure></li><li><p>修改application.yam</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp连接池支持</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">swagger:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">购物车服务接口文档</span></span><br><span class="line">    <span class="attr">package:</span> <span class="string">com.hmall.cart.controller</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">hm-cart</span></span><br></pre></td></tr></table></figure></li></ol><p>调试，验证购物车接口的功能</p><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>配置热更新：当修改配置文件中的配置时，微服务无需重启即可使配置生效</p><p>前提条件：</p><ul><li>nacos的配置文件<ul><li>**<code>spring.active.profile</code>**：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/u3qIc2UtgBrf8DH.png" alt="image"></p><ul><li>微服务中要以特定方式读取需要热更新的配置属性，两种方式，注解不同</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/jnQkBSRhzd3XfVv.png" alt="img"></p><p>通过修改<code>cat-service</code>中添加商品到购物车代码功能，引入<code>CartProperties</code>bean，修改<code>checkCartsFull()</code>方法如下，调试热更新</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkCartsFull</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> lambdaQuery().eq(Cart::getUserId, userId).count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= cartProperties.getMaxItems()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(StrUtil.format(<span class="string">&quot;用户购物车课程不能超过&#123;&#125;&quot;</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够实现热更新，依赖于当nacos的配置服务修改时，会推送最新的配置信息到微服务</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的<strong>路由表</strong>内（一个Map），不会改变。当我们的路由需要做出修改时，就需要重启网关微服务，这样的话其他微服务全部失效了，于是我们需要像配置热更新一样，让路由也实现热更新</p><p>所以，我们必须<strong>监听Nacos的配置变更</strong>，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听Nacos配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><p>在Nacos官网中给出了手动监听Nacos配置变更的SDK：<code>https://nacos.io/zh-cn/docs/sdk.html</code></p><p>如果希望 Nacos 推送配置变更实现监听效果，可以使用 Nacos 动态监听配置接口来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(String dataId, String group, Listener listener)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>请求参数说明</p><table><thead><tr><th align="left"><strong>参数名</strong></th><th align="left"><strong>参数类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">dataId</td><td align="left">string</td><td align="left">配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（”.”、”:”、”-“、”_”）。不超过 256 字节</td></tr><tr><td align="left">group</td><td align="left">string</td><td align="left">配置分组，一般是默认的DEFAULT_GROUP</td></tr><tr><td align="left">listener</td><td align="left">Listener</td><td align="left">监听器，配置变更进入监听器的回调函数</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;&#123;serverAddr&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;&#123;dataId&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;&#123;group&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// 1.创建ConfigService，连接Nacos</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;serverAddr&quot;</span>, serverAddr);</span><br><span class="line"><span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> NacosFactory.createConfigService(properties);</span><br><span class="line"><span class="comment">// 2.读取配置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> configService.getConfig(dataId, group, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 3.添加配置监听器</span></span><br><span class="line">configService.addListener(dataId, group, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置变更的通知处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;recieve1:&quot;</span> + configInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//获取线程池</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>这里核心的步骤有2步：</p><ol><li>创建ConfigService，目的是连接到Nacos</li><li>添加配置监听器，编写配置变更的通知处理逻辑</li></ol><p>由于我们采用了<code>spring-cloud-starter-alibaba-nacos-config</code>自动装配，因此<code>ConfigService</code>已经在<code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code>中自动创建好了：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/758zUjnuNesRDcW.png" alt="image"></p><p>NacosConfigManager中是负责管理Nacos的ConfigService的，具体代码如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/24/HTzaMxrhWItuZdD.png" alt="image"></p><p>因此，只要我们拿到<code>NacosConfigManager</code>就等于拿到了<code>ConfigService</code>，第一步就实现了</p><p>第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getConfigAndSignListener</span><span class="params">(</span></span><br><span class="line"><span class="params">    String dataId, // 配置文件id</span></span><br><span class="line"><span class="params">    String group, // 配置组，走默认</span></span><br><span class="line"><span class="params">    <span class="type">long</span> timeoutMs, // 读取配置的超时时间</span></span><br><span class="line"><span class="params">    Listener listener // 监听器</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> NacosException;</span><br></pre></td></tr></table></figure><p>既可以配置监听器，并且会根据dataId和group读取配置并返回。就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新</p><p><strong>更新路由：</strong></p><p>更新路由要用到<code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code>这个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.gateway.route;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouteDefinitionWriter</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;RouteDefinition&gt; route)</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据路由id删除某个路由</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Mono&lt;Void&gt; <span class="title function_">delete</span><span class="params">(Mono&lt;String&gt; routeId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新的路由，也就是<code>RouteDefinition</code>，包含下列常见字段：</p><ul><li>id：路由id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>我们保存到Nacos的配置也需要符合这个对象结构，如果我们像之前yaml格式配置的话，我们并不知道如何把yaml格式的数据映射到RouteDefinition，但在之前的外卖、redis项目中我们知道Json数据和对象映射，因此对路由的配置我们采用json格式，例如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以上配置等同于：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p><strong>动态路由的实现:</strong></p><ol><li><p>在网关微服务中引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载bootstrap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在网关的<code>resources</code>目录创建<code>bootstrap.yaml</code>文件，网关不需要jdbc和swagger配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure></li><li><p>修改<code>gateway</code>的<code>resources</code>目录下的<code>application.yml</code>，把之前的路由移除:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:hmall.jks</span> <span class="comment"># 秘钥地址</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">hmall</span> <span class="comment"># 秘钥别名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">hmall123</span> <span class="comment"># 秘钥文件密码</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span> <span class="comment"># 登录有效期</span></span><br><span class="line">  <span class="attr">auth:</span></span><br><span class="line">    <span class="attr">excludePaths:</span> <span class="comment"># 无需登录校验的路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/search/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/users/login</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/items/**</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>gateway</code>中定义配置监听器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRouteLoader</span> &#123; <span class="comment">//动态路由加载</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer; <span class="comment">//路由更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager; <span class="comment">//获取ConfigService，获取、监听配置</span></span><br><span class="line">    <span class="comment">// 路由配置文件的id和分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="comment">// 保存更新过的路由id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//当该类加载完成后，执行该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRouteConfigListener</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 1.注册监听器并首次拉取配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">                        <span class="comment">//更新路由配置</span></span><br><span class="line">                        updateConfigInfo(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 2.首次启动时，更新一次配置</span></span><br><span class="line">        updateConfigInfo(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;监听到路由配置变更，&#123;&#125;&quot;</span>, configInfo);</span><br><span class="line">        <span class="comment">// 1.反序列化</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo,                         RouteDefinition.class);</span><br><span class="line">        <span class="comment">// 2.更新前先清空旧路由</span></span><br><span class="line">        <span class="comment">// 2.1.清除旧路由</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            writer.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="comment">// 2.2.判断是否有新的路由要更新</span></span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(routeDefinitions)) &#123;</span><br><span class="line">            <span class="comment">// 无新路由配置，直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.更新路由</span></span><br><span class="line">        routeDefinitions.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3.1.更新路由</span></span><br><span class="line">            writer.save(Mono.just(routeDefinition)).subscribe();</span><br><span class="line">            <span class="comment">// 3.2.记录路由id，方便将来删除</span></span><br><span class="line">            routeIds.add(routeDefinition.getId());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>重启网关，任意访问一个接口，比如 <code>http://localhost:8080/search/list?pageNo=1&amp;pageSize=1</code>,请求404</p><p>我们在Nacos控制台添加路由，路由文件名为<code>gateway-routes.json</code>，类型为<code>json</code>，无需重启网关，再次访问，如果访问成功，那么配置动态路由成功</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/carts/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://cart-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/users/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/addresses/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://user-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trade&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/orders/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://trade-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pay&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/pay-orders/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://pay-service&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="服务保护"><a href="#服务保护" class="headerlink" title="服务保护"></a>服务保护</h2><h3 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h3><p>在微服务远程调用的过程中，还存在几个问题需要解决，一个是<strong>业务健壮性</strong>问题，另一个是服务雪崩问题 </p><p>业务健壮性问题：</p><ul><li>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服务时，是不是也会异常？从而导致购物车查询失败。</li><li>但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息</li></ul><p>雪崩问题产生的原因： </p><ul><li>微服务相互调用，服务提供者出现故障或阻塞</li><li>服务调用者没有做好异常处理，导致自身故障</li><li>调用链中的所有服务级联失败，导致整个集群故障<ul><li>服务与服务之间关联性部分错误，且没有应对措施，导致整个服务集群瘫痪（很多服务之间的远程调用非常多）</li></ul></li></ul><p>解决问题的思路：</p><ul><li>尽量避免服务出现故障或阻塞（服务提供者）<ul><li>保证代码的健壮性</li><li>保证网络的畅通</li><li>能应对较高的并发请求</li></ul></li><li>服务调用者做好远程调用异常的后备方案，避免故障扩散</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题，就属于微服务保护</p><p>服务保护方案</p><ul><li><strong>请求限流</strong>：限制访问微服务的请求的并发量，避免服务因流量激增出现故障<ul><li>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/UVZdzL2aBeP63NG.jpg" alt="限流图"></li><li>QPS（Queries Per Second）衡量的是服务器每秒能够响应的查询次数，‌也就是最大吞吐能力。‌这个指标对于评估系统的性能和容量规划非常重要，‌因为它直接关系到系统能够支持的用户数量和业务规模</li></ul></li><li><strong>线程隔离</strong>：也叫做舱壁模式，模拟船舱隔板的防水原理。通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散<ul><li>轮船的船舱会被隔板分割为N个相互隔离的密闭舱，假如轮船触礁进水，只有损坏的部分密闭舱会进水，而其他舱由于相互隔离，并不会进水。这样就把进水控制在部分船体，避免了整个船舱进水而沉没</li><li>为了避免某个接口故障或压力过大导致整个服务不可用，我们可以限定每个接口可以使用的资源范围，也就是将其“隔离”起来</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/yCu5imlG9fPzUD1.png" alt="线程隔离"></li><li>如图所示，我们给查询购物车业务限定可用线程数量上限为20，这样即便查询购物车的请求因为查询商品服务而出现故障，也不会导致服务器的线程资源被耗尽，不会影响到其它接口</li></ul></li><li><strong>服务熔断</strong>：由断路器统计请求的异常比例或慢调用比例，如果超出阈值则会熔断该业务，则拦截该接口的请求。熔断期间，所有请求快速失败，全都走fallback逻辑（也就是降级逻辑）<ul><li>线程隔离虽然避免了雪崩问题，但故障服务（商品服务）依然会拖慢购物车服务（服务调用方）的接口响应速度。而且商品查询的故障依然会导致查询购物车功能出现故障，从而购物车业务也变的不可用</li><li>所以，我们要做两件事情<ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑</li></ul></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/162UJkNGRPp3nrO.png" alt="服务熔断"></li></ul></li></ul><h3 id="服务保护技术"><a href="#服务保护技术" class="headerlink" title="服务保护技术"></a>服务保护技术</h3><p>微服务保护的技术有很多，目前国内使用较多的还是Sentinel以及Hystrix，我们主要学习Sentinel的使用</p><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件，目前已经加入到SpringCloudAlibaba中</p><ul><li>官方网站：<code>https://sentinelguard.io/zh-cn</code></li></ul><p>Sentinel 的使用可以分为两个部分</p><ul><li><strong>核心库</strong>（Jar包）：不依赖任何框架&#x2F;库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能</li><li><strong>控制台</strong>（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等</li></ul><p><strong>搭建Sentinel的控制台</strong></p><ul><li>下载jar包：<code>https://github.com/alibaba/Sentinel/releases</code>，黑马资料中有1.8.6版本</li><li>运行，将jar包放在任意非中文、不包含特殊字符的目录下<ul><li><code>java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.6.jar</code></li><li>其它启动时可配置参数可参考官方文档：<code>https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9</code></li></ul></li><li>访问<code>http://localhost:8090</code>页面，就可以看到sentinel的控制台，账号和密码均为sentinel<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/REmGzvrtV1PDXAp.png" alt="img"></li></ul></li></ul><p><strong>微服务整合sentinel</strong></p><ul><li><p>在<code>cart-service</code>模块中整合sentinel，连接<code>sentinel-dashboard</code>控制台</p></li><li><p>引入sentinel依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置控制台，修改application.yaml文件，添加下面内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br></pre></td></tr></table></figure></li><li><p>重启<code>cart-service</code>，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台</p></li></ul><p><strong>簇点链路</strong></p><p>所谓簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被<code>Sentinel</code>监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（接口）</p><p>因此，我们看到<code>/carts</code>这个接口路径就是其中一个簇点，我们可以<strong>对其进行限流、熔断、隔离</strong>等保护措施</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/Sx9BP8Zq5gkYElf.png" alt="img"></p><p>不过，需要注意的是，SpringMVC接口是按照Restful风格设计，因此购物车的查询、删除、修改等接口全部都是<code>/carts</code>路径，默认情况下Sentinel会把请求路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的</p><p>所以我们可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><p>重启服务，通过页面访问购物车的相关接口</p><p>在簇点链路后面点击流控按钮，即可对其做限流配置</p><p>在弹出的菜单中这样填写：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/XZu3s2px4TfVgYD.png" alt="img"></p><p>这样就把查询购物车列表这个簇点资源的流量限制在了每秒6个，也就是最大QPS为6.</p><p>利用Jemeter做限流测试，我们每秒发出10个请求，最终监控结果如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/KGkH6vCyhnoIrAW.png" alt="img"></p><p>可以看出<code>GET:/carts</code>这个接口的通过QPS稳定在6附近，而拒绝的QPS在4附近，符合预期</p><h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩</p><p>比如，查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/BTaphNYZQbngc23.png" alt="image"></p><p>这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且<strong>可用的线程资源也被限定在一定范围</strong>，不会导致整个购物车服务，如修改、删除等服务崩溃</p><p>对查询商品的FeignClient接口做线程隔离，开启远程调用feignclient作为簇点，可以被流量监控</p><ul><li>修改cart-service模块的application.yml文件，开启Feign的sentinel功能</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span> </span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure><p>需要注意的是，默认情况下SpringBoot项目的tomcat最大线程数是200，允许的最大连接是8492，单机测试很难打满，所以我们需要配置一下cart-service模块的application.yml文件，修改tomcat连接：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">threads:</span></span><br><span class="line">      <span class="attr">max:</span> <span class="number">50</span> <span class="comment"># 允许的最大线程数</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="number">50</span> <span class="comment"># 最大排队等待数量</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">100</span> <span class="comment"># 允许的最大连接</span></span><br></pre></td></tr></table></figure><p>重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源</p><p><strong>配置线程隔离</strong></p><ul><li><p>点击查询商品的FeignClient对应的簇点资源后面的流控按钮，设置线程隔离数为5</p></li><li><p>注意，这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝</p></li><li><p>利用Jemeter测试，每秒发送100个请求：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/ZztfsLIe23brWp9.png" alt="img"></p></li><li><p>此时如果我们通过页面访问购物车的其它接口，例如添加购物车、修改购物车商品数量，发现并不受高并发的影响</p><ul><li>响应时间非常短，这就证明线程隔离起到了作用，尽管查询购物车这个接口并发很高，但是它能使用的线程资源被限制了，因此不会影响太大到其它接口</li></ul></li></ul><h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><p>在上一节，线程隔离中我们发现购物车的查询功能完全瘫痪，尽管可以新增、修改，但是没有页面上的信息反馈，用户以为没有添加成功于是继续新增（实际上数据库已经新增完毕），很容易导致误操作</p><p>好的做法应该是，即使查询业务出现问题，返回一些默认数据或者友好提示</p><p><strong>Fallback的实现</strong></p><p>给FeignClient编写失败后的降级逻辑有两种方式</p><ul><li>方式一：FallbackClass，无法对远程调用的异常做处理</li><li>方式二：FallbackFactory，可以对远程调用的异常做处理，一般选择这种方式</li></ul><p>步骤一：在hm-api模块中给<code>ItemClient</code>定义降级处理类，实现<code>FallbackFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;远程调用ItemClient#queryItemByIds方法出现异常，参数：&#123;&#125;&quot;</span>, ids, cause);</span><br><span class="line">                <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                <span class="comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当业务请求无异常时着正确调用ItemClient，当出现异常时调用ItemClientFallback</li></ul><p>步骤二：在<code>hm-api</code>模块中的<code>com.hmall.api.config.DefaultFeignConfig</code>类中将<code>ItemClientFallback</code>注册为一个<code>Bean</code></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/p8TM9kHcm2ZBEwI.png" alt="img"></p><ul><li>直接在其类名上加<code>@Component</code>注解，为什么不行？注意该业务是<code>hm-api</code>，不会扫描到fallback包，而config包已经在其他业务的启动项中配置过，可以扫描</li></ul><p>步骤三：在<code>hm-api</code>模块中的<code>ItemClient</code>接口中使用<code>ItemClientFallbackFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;,fallbackFactory = ItemClientFallback.class)</span></span><br></pre></td></tr></table></figure><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>查询商品的RT较高（模拟的500ms），从而导致查询购物车的RT也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差</p><p>对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。当商品服务接口恢复正常后，再允许调用。这其实就是<strong>断路器</strong>的工作模式了</p><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即<strong>拦截访问该接口的一切请求，降级处理</strong>；当该接口恢复正常时，再放行对于该接口的请求</p><p>断路器的工作状态切换有一个<strong>状态机</strong>来控制</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/SGJxiIdasmQuTY3.png" alt="image"></p><p>状态机包括三个状态</p><ul><li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。<ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>通过sentinel添加熔断规则：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/25/nDU13ci6PsqRhuy.png" alt="img"></p><p>这种是按照慢调用比例来做熔断，上述配置的含义</p><ul><li>RT超过200毫秒的请求调用就是慢调用</li><li>统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断</li><li>熔断持续时长20s</li></ul><p>在一开始一段时间是允许访问的，后来触发熔断后，查询商品服务的接口通过QPS直接为0，所有请求都被熔断了。而查询购物车的本身并没有受到影响</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="何为分布式事务"><a href="#何为分布式事务" class="headerlink" title="何为分布式事务"></a>何为分布式事务</h3><p>项目中的下单业务整体流程：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/T5jO4cyzAhUi3dG.png" alt="image"></p><p>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务。这也导致了当库存服务提交事务失败时，只有交易服务与库存服务会回滚，购物车服务不会回滚，ACID失效！</p><ul><li>交易服务：下单事务</li><li>购物车服务：清理购物车事务</li><li>库存服务：扣减库存事务</li></ul><p>通过修改购物车中一商品的库存为0，进行测试，查看各个服务执行情况，购物车会正常清理</p><p>事务并未遵循ACID的原则，归其原因就是参与事务的多个子业务在不同的微服务，跨越了不同的数据库。虽然每个单独的业务都能在本地遵循ACID，但是它们互相之间没有感知，不知道有人失败了，无法保证最终结果的统一，也就无法遵循ACID的事务特性了</p><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。我们必须保证整个全局事务同时成功或失败</p><p>以上分布式事务问题，出现以下情况之一就可能产生分布式事务问题</p><ul><li>业务跨多个服务实现</li><li>业务跨多个数据源实现</li></ul><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在2019年开源的Seata</p><ul><li>官方文档：<code>https://www.seata.io/zh-cn/docs/overview/what-is-seata.html</code></li></ul><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务，就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现</p><p>Seata的工作架构如图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/yzT9GWvVNCuKYnx.png" alt="image"></p><p>Seata的事务管理中有三个重要的角色</p><ul><li><strong>TC (Transaction Coordinator) - 事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚</li><li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务</li><li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li></ul><p>下单业务中，调用<code>createOrder()</code>方法就是开启全局事务，其中的购物车、库存业务就是分支事物的注册和报告，方法结束完毕就会提交、回滚全局事务，那么TC就开始判断是否需要回滚这些分支事务</p><p>其中，<strong>TM</strong>和<strong>RM</strong>可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来<strong>TM</strong>和<strong>RM</strong>就会协助微服务，实现本地分支事务与<strong>TC</strong>之间交互，实现事务的提交或回滚。而<strong>TC</strong>服务则是事务协调中心，是一个独立的微服务，需要单独部署</p><h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><ol><li><p>准备数据库表</p><ul><li>Seata支持多种存储模式，但考虑到持久化的需要，一般选择基于数据库存储。执行黑马资料提供的<code>seata-tc.sql</code>，导入数据库表</li></ul></li><li><p>准备配置文件</p><ul><li>黑马资料准备了一个seata目录，其中包含了seata运行时所需要的配置文件</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/crLJOQfTyi2d9NA.png" alt="image"></li></ul></li><li><p>基于docker部署</p><ul><li><p>拷贝seata目录和seata镜像到docker的<code>/root</code>目录下</p></li><li><p>需要注意，因为配置文件中的连接都是通过服务名称，所以要确保nacos、mysql都在hm-net网络中。如果某个容器不在hm-net网络，可以参考下面的命令将某容器加入指定网络</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network connect [网络名] [容器名]</span><br></pre></td></tr></table></figure></li><li><p>在虚拟机的<code>/root</code>目录执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name seata \</span><br><span class="line">-p 8099:8099 \</span><br><span class="line">-p 7099:7099 \</span><br><span class="line">-e SEATA_IP=192.168.80.132 \</span><br><span class="line">-v ./seata:/seata-server/resources \</span><br><span class="line">--privileged=true \</span><br><span class="line">--network heima \</span><br><span class="line">-d \</span><br><span class="line">seataio/seata-server:1.5.2</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过<code>虚拟机IP:7099</code>查看UI控制台是否部署成功</p></li></ol><h3 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h3><p>为了方便各个微服务集成seata，我们需要把seata配置共享到nacos，因此<code>trade-service</code>模块不仅仅要引入seata依赖，还要引入nacos依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次在nacos上添加一个共享的seata配置，命名为<code>shared.seata.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure><ul><li>一个服务的获取途径：命名空间-分组-服务名称-集群-具体的实例</li><li>注意登录密码修改为nacos（如果之前对nacos登录密码有过修改）</li></ul><p>然后，改造<code>trade-service</code>模块，添加<code>bootstrap.yaml</code>，修改<code>appplication.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">trade-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.80</span><span class="number">.132</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared.jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared.log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared.swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared.seata.yaml</span> <span class="comment"># 共享seata配置</span></span><br></pre></td></tr></table></figure><p>最后，对涉及到分布式服务的购物车和商品服务进行修改</p><p>注意jdk其他版本（非11）如果报错就在服务配置上<code>--add-opens=java.base/java.lang=ALL-UNNAMED</code></p><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>分布式事务解决方案有很多例如：<strong>XA</strong>、<strong>TCC</strong>、<strong>AT</strong>、<strong>SAGA</strong>等，Seata也对这4种方案支持，这里黑马主要讲解XA、AT模式</p><p><code>XA</code> 规范 是<code> X/Open</code> 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范描述了全局的<code>TM</code>与局部的<code>RM</code>之间的接口，几乎所有主流的关系型数据库都对 XA 规范提供了支持</p><p>XA是规范，目前主流数据库都实现了这种规范，实现的原理都是基于<strong>两阶段提交</strong></p><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/CMKzw8ZJk1UrHb6.png" alt="image"></p><ul><li><code>RM</code>一阶段的工作<ol><li>注册分支事务到<code>TC</code></li><li>执行分支业务sql但不提交</li><li>报告执行状态到<code>TC</code></li></ol></li><li><code>TC</code>二阶段的工作<ol><li><code>TC</code>检测各分支事务执行状态</li><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ol></li><li><code>RM</code>二阶段的工作<ol><li>接收<code>TC</code>指令，提交或回滚事务</li></ol></li></ul><p><code>XA</code>模式的优点：</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p><code>XA</code>模式的缺点：</p><ul><li>因为一阶段需要锁定数据库资源（排他锁，一致等待其他分支事务执行完毕，才能提交），等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><p><strong>实现XA模式</strong></p><p>因为导入了seata的stater的依赖，所以实现非常简单</p><ul><li><p>首先，在配置文件中指定要采用的分布式事务模式，在Nacos中的共享shared-seata.yaml配置文件中设置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mde:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure></li><li><p>其次，将<code>@GlobalTransactional</code>标记分布式事务的入口方法</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/JKPdAfDRe9lFCVL.png" alt="image"></p></li></ul><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p>Seata主推的是AT模式，AT模式同样是分阶段提交的事务模型，不过却弥补了XA模型中资源锁定周期过长的缺陷</p><p>Seata的AT模式基本架构如图</p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/26/7rXms39chTb4zVM.png" alt="img"></p></li><li><p>阶段一<code>RM</code>的工作</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul></li><li><p>阶段二提交时<code>RM</code>的工作：删除undo-log即可</p></li><li><p>阶段二回滚时<code>RM</code>的工作：根据undo-log恢复数据到更新前</p></li></ul><p><code>AT</code>模式与<code>XA</code>模式最大的区别：</p><ul><li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源（优点是性能好，缺点是数据一致性问题）</li><li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚</li><li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li></ul><p><strong>AT模式的实现</strong></p><ol><li>去掉nacos配置文件中的XA模式即可（默认是AT）</li><li>将黑马资料中sql文件<code>undo_log</code>表导入到几个分支服务对应的数据库中</li></ol><p>问题：当还未恢复快照时，别人也修改了数据，是否会造成并发问题？、</p><ul><li>在提交数据快照前会向TC（事务协调器）注册分支，申请一个主键等于目标数据主键值的<strong>全局锁</strong></li><li>Seata通过全局锁实现了写隔离，确保其他事务在当前事务未释放全局锁时无法修改同一数值。这意味着，如果别的线程或者进程在全局事务结束前尝试修改相应的数据，将会被阻塞，直到全局锁释放。因此，不会发生脏写问题，从而避免了并发问题</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 黑马学习课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tools</title>
      <link href="/cn/Tools/"/>
      <url>/cn/Tools/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一些小工具的介绍与使用，感谢这些博主！</p></blockquote><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><h2 id="个人博客网站搭建"><a href="#个人博客网站搭建" class="headerlink" title="个人博客网站搭建"></a>个人博客网站搭建</h2><ol><li>这个博主的教程非常详细，且配有文字+视频讲解<code>https://ihcll.cn/83/</code></li><li>Github和Gitee其实都差不多，看个人喜欢</li></ol><h2 id="个人博客网站配置"><a href="#个人博客网站配置" class="headerlink" title="个人博客网站配置"></a>个人博客网站配置</h2><ol><li><code>ButterFly</code> 主题配置&amp;美化<ol><li>官网<code>https://github.com/jerryc127/hexo-theme-butterfly</code></li><li><code>https://www.cnblogs.com/MoYu-zc/p/14395965.html</code></li></ol></li><li>PicGo + Typora + Smms获取图片超链以及上传<ol><li>Smms图床网站官网<code>https://smms.app/</code></li><li><code>https://blog.csdn.net/dante1987/article/details/127706832</code></li></ol></li><li>免费图片压缩<ol><li><code>https://saerasoft.com/caesium/</code></li></ol></li><li>其他免费图床（如果Smms不可用的话可以更换）<ol><li><code>https://www.picgo.net/</code> </li><li><code>https://imgse.com/</code></li><li><code>https://www.imgbed.link/</code></li><li><code>https://www.imgurl.org/</code></li><li><code>https://img.z4a.net/</code></li></ol></li><li>博客URL优化<ol><li>教程：<code>https://blog.csdn.net/qq_45890533/article/details/124185573</code></li></ol></li></ol><h2 id="各种文件的格式转换"><a href="#各种文件的格式转换" class="headerlink" title="各种文件的格式转换"></a>各种文件的格式转换</h2><ol><li>格式化工厂<ol><li>官网<code>http://www.pcgeshi.com/index.html</code>下载</li></ol></li></ol><h2 id="文字扫描、识别工具"><a href="#文字扫描、识别工具" class="headerlink" title="文字扫描、识别工具"></a>文字扫描、识别工具</h2><ol><li>Umi-OCR<ol><li>官网<code>https://github.com/hiroi-sora/Umi-OCR</code></li></ol></li></ol><h2 id="Virtual-Private-Server-虚拟专用服务器"><a href="#Virtual-Private-Server-虚拟专用服务器" class="headerlink" title="Virtual Private Server(虚拟专用服务器)"></a>Virtual Private Server(虚拟专用服务器)</h2><ol><li>国内大厂：腾讯云、阿里云、百度云等</li><li>racknerd<ol><li>国外的，价格便宜，延迟也不算太高</li><li><code>https://my.racknerd.com/cart.php?a=confproduct&amp;i=0</code></li></ol></li><li>小兔互联<ol><li>价格不错，配置也还好</li><li>官网: <code>https://hl.luoltu.com/cart</code></li></ol></li><li>各大VPS商家推荐：<code>https://topvps.info/review</code></li></ol><h2 id="证书签发"><a href="#证书签发" class="headerlink" title="证书签发"></a>证书签发</h2><ol><li>acme自签<ol><li>官网: <code>https://github.com/acmesh-official/acme.sh</code></li></ol></li><li>阿里云、腾讯云</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis实战篇学习笔记</title>
      <link href="/cn/Redis/"/>
      <url>/cn/Redis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在此特别感谢黑马程序员Redis课程~~<br><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=70&vd_source=7341c7fca3b496e9108bb1fd49c634ef">黑马程序员的Redis课程</a></p></blockquote><h1 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h1><ul><li><em><strong>短信登录</strong></em><ul><li>通过Redis共享Session实现</li><li>在苍穹外卖项目中通过Json Web Token实现登录；黑马点评通过Redis共享session实现短-  -信验证登录。</li></ul></li><li><em><strong>添加缓存</strong></em><ul><li>基于Redis实现给商户添加缓存，设置更新策略，满足读写一致</li><li>解决缓存中存在3大问题，缓存穿透、缓存雪崩、缓存击穿</li><li>对锁的理解和线程池的创建&amp;使用（开启独立线程）</li></ul></li><li><em><strong>优惠卷秒杀</strong></em><ul><li>基本优惠卷和秒杀优惠卷以及优惠卷订单的添加</li><li>通过加乐观锁&amp;悲观锁的方式解决库存超卖问题</li><li>通过加锁实现对单机状态下一人一单的细粒度控制</li><li>集群环境下的并发问题分析</li></ul></li><li><em><strong>分布式锁</strong></em><ul><li>分布式锁的实现，以及误删问题、获取、判断、删除锁的原子性问题</li><li>线程标识解决误删问题、</li><li>lua脚本解决原子性问题</li><li><strong>分布式锁-Redisson</strong><ul><li>Redisson实现可重入、可重试、超时续约</li><li>实现的原理以及Watch Dog机制</li><li>Redisson通过联锁实现主从一致性</li></ul></li></ul></li><li><em><strong>秒杀优化</strong></em><ul><li>异步”秒杀”的思路分析</li><li>基于lua脚本完成订单业务的判断</li><li>通过阻塞对垒与独立线程处理订单异步任务完成下单</li></ul></li><li><em><strong>Redis消息队列</strong></em><ul><li>认识什么是消息队列，市面上常用的消息中间件</li><li>基于Redis的List、PubSub、Stream结构实现消息队列</li><li>三种结构对实现消息队列的优缺点</li><li>基于Stream结构的消费者组模式下实现多消费秒杀下单</li></ul></li><li><em><strong>达人探店</strong></em><ul><li>如何基于云存储服务实现照片上传</li><li>基于Redis的Set集合实现用户是否对某博文进行过点赞</li><li>基于Redis的SortedSet集合实现用户是否对某博文进行过点赞，以及点赞用户通过时间先后排序</li><li>了解MySQL的查询结果机制，实现给定顺序上传</li></ul></li><li><em><strong>好友关注</strong></em><ul><li>多对多型表结构关系的建立</li><li>基于SortedSet实现”交集”查询</li><li>什么时Feed流，Feed流的实现方式</li><li>SortedSet的ZREVRANGEBYSCORE命令，实现滚动分</li></ul></li><li><em><strong>附近商铺</strong></em><ul><li>了解Redis中GEO这种数据结构的使用</li><li>通过GEO来实现附近商铺的位置搜索</li></ul></li><li><em><strong>用户签到</strong></em><ul><li>了解Redis中BitMap这种数据结构的使用</li><li>通过BitMap实现签到功能和连续签到次数</li></ul></li><li><em><strong>UV统计</strong></em><ul><li>了解LogLog概率统计算法</li><li>了解Redis中HyperLogLog这种数据结构应用</li></ul></li></ul><hr><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><ul><li>前后端分离开发</li><li>前端通过Nginx服务器启动。<ul><li>在“苍穹外卖”项目中同样是采用Nginx这种轻量的反向代理服务器。</li><li>通过nignx的负载均衡能显著降低Tomcat服务器的压力。</li></ul></li><li>该项目中对mysql的并发需求也会非常大，除了通过mysql集群外，也通过部署Redis集群来减轻对mysql的并发压力。</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/aN8L7DiBSnEY3jF.png" alt="url"></li></ul><h2 id="导入前端工程"><a href="#导入前端工程" class="headerlink" title="导入前端工程"></a>导入前端工程</h2><ol><li><p>在黑马提供的资料中，找到<strong>Nginx包</strong>，把包放到我们的workspace中。</p><ol><li>该workspace不能包含中文路径，不然nginx启动失败</li></ol></li><li><p>启动<code>start nginx</code>，一闪而过说明启动成功；或者查看任务进程有无nginx</p><ol><li>访问<code>http://localhost:8080/</code>即可看到</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/3QyCqIgpf8KPv4X.webp" alt="url" style="zoom:50%;" /></li></ol></li></ol><h2 id="导入后端工程"><a href="#导入后端工程" class="headerlink" title="导入后端工程"></a>导入后端工程</h2><ol><li>在黑马提供的资料中，找到<code>hm-dianping</code>项目导入</li><li>启动项目，在浏览器中访问<code>http://localhost:8081/shop-type/list</code>,如果出现json数据，代表成功。</li><li>示例</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/zxsLiRaClJ2bd43.webp" alt="url" style="zoom: 33%;" /></li></ol><h2 id="数据库搭建"><a href="#数据库搭建" class="headerlink" title="数据库搭建"></a>数据库搭建</h2><h3 id="表结构说明"><a href="#表结构说明" class="headerlink" title="表结构说明"></a>表结构说明</h3><ul><li>导入黑马资料中的sql文件完成数据库的建表</li></ul><table><thead><tr><th align="center">表</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">tb_user</td><td align="center">用户表</td></tr><tr><td align="center">tb_user_info</td><td align="center">用户详情表</td></tr><tr><td align="center">tb_shop</td><td align="center">商户信息表</td></tr><tr><td align="center">tb_shop_type</td><td align="center">商户类型表</td></tr><tr><td align="center">tb_blog</td><td align="center">用户日记表（达人探店日记）</td></tr><tr><td align="center">tb_follow</td><td align="center">用户关注表</td></tr><tr><td align="center">tb_voucher</td><td align="center">优惠券表</td></tr><tr><td align="center">tb_voucher_order</td><td align="center">优惠券的订单表</td></tr></tbody></table><h3 id="字符集-排序字符集"><a href="#字符集-排序字符集" class="headerlink" title="字符集&amp;排序字符集"></a>字符集&amp;排序字符集</h3><ul><li>字符集是<code>utf8mb4</code></li><li><ul><li>在MySQL中保留四字节长度的<code>utf-8</code>编码的字符，兼容性更好（与utf-8相比），空间占用比utf-8稍大，mysql官方建议使用varchar代替char使用</li><li>详细请看<code>https://blog.csdn.net/munangs/article/details/126617226</code></li></ul></li><li>排序字符集是<code>utf8mb4_general_ci</code><ul><li>推荐使用 <code>utf8mb4_0900_ai_ci</code> 作为默认排序字符集；<code>utf8mb4_general_ci</code>在比较和排序的性能上都还行， 但是没有实现 <strong>Unicode</strong> 排序规则，在遇到某些特殊语言或者字符集，排序结果可能不一致</li></ul></li></ul><h2 id="Redis搭建"><a href="#Redis搭建" class="headerlink" title="Redis搭建"></a>Redis搭建</h2><ol><li>配置信息</li></ol> <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ==redis==</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">lettuce:</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure><ol start="2"><li>选择<ol><li>由于是个人操作，直接使用<strong>Windows</strong>系统下的<strong>Redis</strong></li><li>在”苍穹外卖“中使用的是RedisTemplate，然后配置<strong>字符串序列化器</strong>；而这里的StringRedisTemplate继承RedisTemplate且默认序列化器就是<strong>字符串序列化器</strong>，因此之后直接装配StringRedisTemplate使用即可</li><li>RedisTemplate 和 StringRedisTemplate区别<ol><li>详情看<code>https://blog.csdn.net/zhanyu1/article/details/90760226</code></li></ol></li></ol></li></ol><hr><h1 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h1><h2 id="基于Session的登录流程"><a href="#基于Session的登录流程" class="headerlink" title="基于Session的登录流程"></a>基于Session的登录流程</h2><ol><li>通过接收到的手机号发送验证码</li><li>短信验证码登录、注册</li><li>校验登录状态</li></ol><h3 id="发送验证码实现"><a href="#发送验证码实现" class="headerlink" title="发送验证码实现"></a>发送验证码实现</h3><ol><li><p>查看前后端请求接口和传输对象</p><ol><li>Post请求，路径为<code>/user/code</code></li><li>请求参数为<code>String phone, HttpSession session</code></li></ol></li><li><p>电话号码规范校验</p><ol><li>这里通过工具类<code>RegexUtils</code>和<code>RegexPatterns</code>常量类做正则判断</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手机号正则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PHONE_REGEX</span> <span class="operator">=</span> </span><br><span class="line">    <span class="string">&quot;^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d&#123;8&#125;$&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是无效手机格式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> phone 要校验的手机号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true:符合，false：不符合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPhoneInvalid</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mismatch(phone, RegexPatterns.PHONE_REGEX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>生成验证码<ol><li>黑马使用的是一个随机数工具类，生成6位的数字随机数。</li><li><code>RandomUtil</code>工具类</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>保存验证码到session中</p></li><li><p>发送验证码</p></li><li><p>具体service层代码实现</p><ol><li>代码逻辑</li><li>手机号校验</li></ol><ul><li>错误，返回错误信息</li><li>正确，生成6位数字验证码<ul><li>没有短信服务接口，直接输出到控制台查看</li><li>保存到<code>session</code>域中</li></ul></li></ul></li></ol> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送验证码</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(phone);</span><br><span class="line">    <span class="keyword">if</span> (isInvalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.PHONE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">yzm</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,yzm);</span><br><span class="line">    log.info(<span class="string">&quot;yzm:&#123;&#125;&quot;</span>,yzm);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="短信登录实现"><a href="#短信登录实现" class="headerlink" title="短信登录实现"></a>短信登录实现</h3><ol><li><p>查看前后端请求接口和传输对象</p></li><li><p>Post请求路径为<code>/user/login</code></p><ol><li>请求参数为<code>LoginFormDTO loginForm, HttpSession session</code></li></ol></li><li><p>查看<code>LoginFormDTO </code>的组成结构</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFormDTO</span> &#123;</span><br><span class="line">    <span class="comment">//电话</span></span><br><span class="line">    <span class="keyword">private</span> String phone; </span><br><span class="line">    <span class="comment">//输入的验证码</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>实现逻辑</p><ol><li><p>校验手机号是否有效</p><ol><li>无效，返回错误信息</li><li>有效，判断手机号是否一致<ol><li>不一致，返回错误信息</li><li>一致，通过获取<code>session</code>域中yzm进行校验<ol><li>错误，返回错误信息</li><li>正确，根据手机号在数据库中查询用户<ol><li>用户存在，保存用户到session</li><li>用户不存在，创建新用户，保存数据库中</li></ol></li></ol></li></ol></li></ol><p>2.创建新用户</p><ol><li>对User实体类创建一个实现方法</li><li>根据电话号码和<code>IdGenerator</code>构建一个<code>User</code>实体</li><li>保存数据库</li><li>保存到<code>session</code></li></ol></li></ol></li><li><p>具体service层代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(loginForm.getPhone());</span><br><span class="line">    <span class="keyword">if</span> (isInvalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.PHONE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>).toString();    </span><br><span class="line">    <span class="keyword">if</span> (!loginForm.getCode().equals(yzm))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.CODE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getByPhone(loginForm.getPhone());</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>)&#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> createUserWithPhone(loginForm.getPhone());</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> userMapper.insert(newUser);</span><br><span class="line">    <span class="keyword">if</span> (row != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_USER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,newUser);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过电话号码创建用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> phone</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> User <span class="title function_">createUserWithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setPhone(phone);</span><br><span class="line">    user.setId(YitIdHelper.nextId());</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    <span class="comment">//名称采用的是RandomUtil的随机字符串</span></span><br><span class="line">    user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里的主键生成策略采用<strong>雪花算法id</strong>生成</p><ul><li><p>配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.yitter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yitter-idgenerator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>配置详情见官网</p><ul><li><code>https://github.com/yitter/idgenerator/tree/master/Java</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGeneratorUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局 初始化（应用程序启动时执行一次）</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 IdGeneratorOptions 对象，可在构造函数中输入 WorkerId(默认为0)</span></span><br><span class="line">        <span class="type">IdGeneratorOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGeneratorOptions</span>();</span><br><span class="line">        <span class="comment">// 保存参数（务必调用，否则参数设置不生效）：</span></span><br><span class="line">        YitIdHelper.setIdGenerator(options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>流程图</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/ib7vXEtZzQGeTNY.webp" alt="img"></p></li></ol><p></p><h2 id="登录拦截"><a href="#登录拦截" class="headerlink" title="登录拦截"></a>登录拦截</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li><p>为什么需要登录拦截器？</p><ul><li>一般来说，只有静态、登录和注册页面是用户可以直接<code>url</code>访问的。其他一切的<code>url</code>都需要被拦截，进行判断</li><li>简单来说，就是防止用户不登录就访问系统资源</li></ul></li><li><p>登录拦截器的业务实现原理？</p><ul><li>在被拦截的请求中查看session域里是否有用户的登录数据（基于Session实现）</li><li>在”苍穹外卖“中是通过请求头获取登录令牌来判断用户是否登录。</li></ul></li></ul><h3 id="黑马提供的Tomcat的运行原理"><a href="#黑马提供的Tomcat的运行原理" class="headerlink" title="黑马提供的Tomcat的运行原理"></a>黑马提供的Tomcat的运行原理</h3><ol><li><p>运行原理图</p></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/qRTaSxXzjNgB6H8.webp" alt="img" style="zoom: 50%;" /></li><li><p>示例</p><ol><li>当用户发起请求时，会访问我们向<code>tomcat</code>注册的<strong>端口</strong>，任何程序想要运行，都需要有一个线程对当前端口号进行<strong>监听</strong>，<code>tomcat</code>也不例外</li><li>当监听线程知道用户想要和<code>tomcat</code>连接时，会由监听线程创建<code>socket</code>连接</li><li><code>socket</code>都是成对出现的，用户通过<code>socket</code>互相传递数据，当<code>tomcat</code>端的<code>socket</code>接受到数据后，此时监听线程会从<code>tomcat</code>的线程池中取出一个线程执行用户请求</li><li>在我们的服务部署到<code>tomcat</code>后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的<code>controller</code>，<code>service</code>，<code>dao</code>中，并且访问对应的<code>DataBase</code></li><li>在用户执行完请求后，再统一返回，再找到<code>tomcat</code>端的<code>socket</code>，再将数据写回到用户端的<code>socket</code>，完成请求和响应</li></ol></li><li><p>通过以上讲解，可以得知 <strong>每个用户其实都是去tomcat线程池中找的一个线程来完成工作</strong>， 使用完成后再进行回收，既然每个请求都是独立(每一个线程都不一致)的，所以在每个用户去访问我们的工程时，我们可以使用<code>threadlocal</code>来做到<strong>线程隔离</strong>，即每个线程只操作自己的一份数据</p></li></ol><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ol><li>通过<code>threadLocal</code>的源码，会发现在<code>threadLocal</code>中，无论是他的<code>put()</code>方法和他的<code>get()</code>方法，都是先获得当前用户的线程，然后从线程中取出线程的成员变量<code>map</code>，只要线程不一样，<code>map</code>就不一样，所以可以通过这种方式来做到<strong>线程隔离</strong></li><li>源码</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/f5vKJtoRbkAz4Ey.webp" alt="img" style="zoom:50%;" /></li></ol><h3 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题"></a>Session共享问题</h3><ul><li><p>核心思路分析</p><ul><li><p>每个<code>tomcat</code>中都有一份属于自己的<code>session</code>,假设用户第一次访问第一台<code>tomcat</code>，并且把自己的信息存放到第一台服务器的<code>session</code>中</p></li><li><p>但是第二次，这个用户访问到了第二台<code>tomcat</code>，那么在第二台服务器上，肯定没有第一台服务器存放的<code>session</code></p></li><li><p>所以此时整个登录拦截功能就会出现问题</p></li></ul></li><li><p>如何解决这个问题呢？</p><ul><li>早期的方案是<strong>session拷贝</strong>，就是说虽然每个<code>tomcat</code>上都有不同的<code>session</code>，但是每当任意一台服务器的<code>session</code>修改时，都会<strong>同步</strong>给其他的Tomcat服务器的<code>session</code>，这样的话，就可以实现session的共享</li></ul></li><li><p>但是这种方案具有两个大问题</p><ol><li>每台服务器中都需要完整的一份session数据，服务器压力过大。</li><li>session拷贝数据时，可能会出现延迟</li><li>所以这里采用的方案是基于<strong>Redis</strong>来完成，Redis数据本身就是共享的，这样就可以避免session共享的问题</li></ol></li><li><p>这样的实现就需要对登录&amp;注册功能代码，进行一定修改，把用户数据User直接缓存到redis中</p></li><li><p>在session中保存用户数据，如果浏览器信息被截取的话，会存在重要信息泄露问题</p><ul><li>因此黑马会有<code>UserDTO</code>类来对用户数据进行隐藏</li><li>不过在<strong>Redis</strong>中不会存在这些问题，但为了安全，还是需要对缓存的用户数据进行隐藏</li></ul></li></ul><h3 id="Redis的设计"><a href="#Redis的设计" class="headerlink" title="Redis的设计"></a>Redis的设计</h3><ol><li><p>使用Redis，不可避免的需要考虑key和value的设计。</p></li><li><p>KEY需要满足</p><ol><li>唯一性</li><li>非敏感性</li></ol></li><li><p>Value则需要考虑使用何种数据结构缓存<code>User</code>实体数据</p><ol><li>直接字符串，以Json形式存储</li><li>Hash结构，key-field-value形式</li></ol></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/uiY4Lnp8svU2GDb.webp" alt="img" style="zoom: 33%;" /></li><li><p>选择</p><ol><li>KEY通过<code>IdGeneratorUtill</code>工具类随机生成token即可，前端携带这个token访问</li><li>因为<code>User</code>数据已经被隐藏，以及不会通过Redis对其中的个别数据查看，因此选择String类型以Json形式存储</li></ol></li></ol><h3 id="基于Redis实现登录"><a href="#基于Redis实现登录" class="headerlink" title="基于Redis实现登录"></a>基于Redis实现登录</h3><ol><li><p>通过token做登录令牌，30分钟的有效期</p></li><li><p>将<code>UserDto</code>转为Json字符串</p></li><li><p>返回token</p></li><li><p>由于只是对<code>session</code>的功能修改，其他不做太大改变，因此直接贴代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送验证码</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(phone);</span><br><span class="line">    <span class="keyword">if</span> (isInvalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.PHONE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">yzm</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">    stringRedisTemplate.opsForValue()</span><br><span class="line">        .set(RedisConstants.LOGIN_CODE_KEY+phone,yzm,<span class="number">1</span>,TimeUnit.MINUTES);</span><br><span class="line">    log.info(<span class="string">&quot;yzm:&#123;&#125;&quot;</span>,yzm);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//登录</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isInvalid</span> <span class="operator">=</span> RegexUtils.isPhoneInvalid(loginForm.getPhone());</span><br><span class="line">       <span class="keyword">if</span> (isInvalid)&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(MessageConstants.PHONE_ERROR);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">String</span> <span class="variable">yzm</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">           .get(RedisConstants.LOGIN_CODE_KEY + loginForm.getPhone());</span><br><span class="line">       <span class="keyword">if</span> (!loginForm.getCode().equals(yzm))&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(MessageConstants.CODE_ERROR);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getByPhone(loginForm.getPhone());</span><br><span class="line">       <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">       <span class="keyword">if</span> (user != <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">token</span> <span class="operator">=</span> YitIdHelper.nextId();</span><br><span class="line">       BeanUtils.copyProperties(user,userDTO);</span><br><span class="line">       <span class="type">String</span> <span class="variable">userDtoStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(userDTO);</span><br><span class="line">       stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_USER_KEY+token,</span><br><span class="line">                userDtoStr,RedisConstants.LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//注册</span></span><br><span class="line">       <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> createUserWithPhone(loginForm.getPhone());</span><br><span class="line">       <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> userMapper.insert(newUser);</span><br><span class="line">       <span class="keyword">if</span> (row != <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(MessageConstants.NEW_USER_ERROR);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> <span class="variable">token</span> <span class="operator">=</span> YitIdHelper.nextId();</span><br><span class="line">   BeanUtils.copyProperties(newUser,userDTO);</span><br><span class="line">   <span class="type">String</span> <span class="variable">userDtoStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(userDTO);</span><br><span class="line">   stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_USER_KEY+token,userDtoStr</span><br><span class="line">       ,RedisConstants.LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> ![img](https:<span class="comment">//s2.loli.net/2024/07/02/xngTCto7pmvbcaB.webp)</span></span><br><span class="line"></span><br><span class="line">### 实现登录拦截器</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 代码逻辑</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> 从请求头中获取`token`</span><br><span class="line">   <span class="number">1.</span> 根据`token`从**Redis**中获取用户数据</span><br><span class="line">      <span class="number">1.</span> 失败，设置响应状态码<span class="number">401</span>（拦截）</span><br><span class="line">      <span class="number">1.</span> 成功，保存用户到threadlocal中</span><br><span class="line">         <span class="number">1.</span> 刷新`token`的缓存时间</span><br><span class="line">         <span class="number">1.</span> 放行</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 具体代码</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   <span class="comment">//登录拦截器</span></span><br><span class="line">   <span class="meta">@Component</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">       <span class="meta">@Resource</span></span><br><span class="line">       <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">       </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">           Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">userDtoStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">               .get(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">           <span class="keyword">if</span> (userDtoStr == <span class="literal">null</span> )&#123;</span><br><span class="line">               response.setStatus(<span class="number">401</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> JSONUtil.toBean(userDtoStr,UserDTO.class);</span><br><span class="line">           <span class="keyword">if</span> (userDTO == <span class="literal">null</span>)&#123;</span><br><span class="line">               response.setStatus(<span class="number">401</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">          UserHolder.saveUser(userDTO);</span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,</span><br><span class="line">                                  RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>添加拦截器</p><ul><li><p>设置拦截路径和放行路径；这里直接粘贴黑马的代码即可</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;LoginInterceptor拦截器.....&quot;</span>);</span><br><span class="line">        registry.addInterceptor(loginInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="实现状态登录刷新"><a href="#实现状态登录刷新" class="headerlink" title="实现状态登录刷新"></a>实现状态登录刷新</h3><ol><li><p>问题</p><ul><li>登录拦截器只是拦截了需要拦截的路径（url）；如果用户访问不被拦截的<code>url</code>超过30min以上<code>token</code>还是会过期</li></ul></li><li><p>解决</p><ul><li>我们需要一个拦截器专门用来处理令牌刷新问题，至于是否<strong>Redis</strong>缓存用户数据则放行至下一个拦截器处理</li><li>令牌刷新拦截器需要对所有请求进行拦截</li></ul></li><li><p>实现逻辑</p><ol><li><p>第一个拦截器</p></li><li><p>从请求头中获取<code>token</code></p><ol><li>不存在，放行（可能是登录）</li><li>存在，从Redis中获取用户数据<ol><li>不存在，放行（toke过期）</li><li>存在，保存用户数据到<code>threadlocal</code>中<ol><li>刷新token有效期</li><li>放行</li></ol></li></ol></li><li>在请求完成后移除用户<ol><li><code>afterCompletion</code>方法中调用<code>UserHolder.removeUser();</code></li></ol></li></ol></li><li><p>第二个拦截器</p><ol><li><p>直接判断<code>threadlocal</code>中是否存在用户数据</p><ol><li>不存在，响应401，拦截</li><li>存在，放行</li></ol></li><li><p>在请求完成后移除用户</p><ol><li>在<code>afterCompletion</code>方法中<code>UserHolder.removeUser();</code></li></ol></li></ol></li></ol></li><li><p>我们重启服务器，登录，然后去Redis的图形化界面查看<code>token</code>的<code>ttl</code>，如果每次切换界面之后，<code>ttl</code>都会重置，说明代码没有问题  </p></li><li><p>实现代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//令牌刷新拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenRefeshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,HttpServletResponse response,</span></span><br><span class="line"><span class="params">       Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userDtoStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .get(RedisConstants.LOGIN_USER_KEY + token);</span><br><span class="line">        <span class="keyword">if</span> (userDtoStr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> JSONUtil.toBean(userDtoStr, UserDTO.class);</span><br><span class="line">        <span class="keyword">if</span> (userDTO == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,</span><br><span class="line">                                   RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TokenRefeshInterceptor tokenRefeshInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Interceptor拦截器.....&quot;</span>);</span><br><span class="line">        registry.addInterceptor(tokenRefeshInterceptor)</span><br><span class="line">                        .addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">        registry.addInterceptor(loginInterceptor)</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>流程图<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/AQhWkJPjN1po6sa.webp" alt="img"></p></li><li><p>拦截器实现原理图（回忆知识）</p><ol><li>参考别人博客<code>https://cyborg2077.github.io/2022/09/10/SSMIntegration/</code></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/02/XKz4xigFZQ5oBEj.webp" alt="img"></li></ol></li><li><p>实现流程</p><ol><li><p>浏览器发送一个请求，会先到<code>Tomcat</code>服务器的web服务器</p></li><li><p><code>Tomcat</code>服务器接收到请求后，会先去判断请求的是静态资源还是动态资源</p></li><li><p>如果是静态资源，会直接到<code>Tomcat</code>的项目部署目录下直接访问</p></li><li><p>如果是动态资源，就需要交给项目的后台代码进行处理</p></li><li><p>在找到具体的方法之前，我们可以去配置<strong>过滤器</strong>（可以配置多个），按照顺序进行执行（在这里就可以进行权限校验）</p></li><li><p>然后进入到中央处理器（SpringMVC中的内容），SpringMVC会根据配置的规则进行拦截</p></li><li><p>如果满足规则，则进行处理，找到其对应的<code>Controller</code>类中的方法进行，完成后返回结果</p></li><li><p>如果不满足规则，则不进行处理</p></li><li><p>这个时候，如果我们需要在每个<code>Controller</code>方法执行的前后添加业务，具体该如何来实现？ </p><ul><li><p>这个就是拦截器要做的事</p></li><li><p>拦截器（Interceptor）是一种动态拦截方法调用的机制，在<strong>SpringMVC</strong>中动态拦截控制器方法的执行</p><ul><li><p>在指定的方法调用前后执行预先设定的代码</p></li><li><p>阻止原始方法的执行</p></li></ul></li><li><p>总结</p><ul><li>拦截器就是用来作增强</li><li>但是这个拦截器同之前学的过滤器很像，不管是从作用上来看还是从执行顺序上来看</li><li>那么拦截器和过滤器之间的区别是什么呢？ <ul><li>归属不同：<code>Filter</code>属于<strong>Servlet</strong>技术，而<code>Interceptor</code>属于<strong>SpringMVC</strong>技术</li><li>拦截内容不同：<code>Filter</code>对所有访问进行增强，<code>Interceptor</code>仅对<strong>SpringMVC</strong>的访问进行增强</li></ul></li></ul></li></ul></li></ol></li></ol><p></p><hr><h1 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h1><h2 id="缓存介绍"><a href="#缓存介绍" class="headerlink" title="缓存介绍"></a>缓存介绍</h2><h3 id="何为缓存？"><a href="#何为缓存？" class="headerlink" title="何为缓存？"></a>何为缓存？</h3><ul><li><p>缓存就像是自行车,越野车的避震器</p></li><li><p>举个例子</p></li><li><ul><li>越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样</li><li>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪</li></ul></li><li><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地，代码(例如:</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本地用于高并发</span></span><br><span class="line">Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">//用于redis等缓存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); </span><br><span class="line"><span class="comment">//本地缓存</span></span><br><span class="line">Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br></pre></td></tr></table></figure><ul><li>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(map)和对象(new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效</li></ul><h3 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h3><ol><li>缓存的作用<ol><li>降低服务器负载</li><li>提高服务读写响应速度</li></ol></li></ol><h3 id="如何使用缓存？"><a href="#如何使用缓存？" class="headerlink" title="如何使用缓存？"></a>如何使用缓存？</h3><ul><li>实际开发中，会构筑<strong>多级缓存</strong>来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</li><li>缓存类别<ul><li><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</li><li><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</li><li><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</li><li><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</li></ul></li><li>如图<ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/TF29enWVtdBSNav.png" alt="img"></li></ul></li></ul><h3 id="本项目使用缓存及其存在的问题"><a href="#本项目使用缓存及其存在的问题" class="headerlink" title="本项目使用缓存及其存在的问题"></a>本项目使用缓存及其存在的问题</h3><blockquote><p>详细介绍见“缓存”</p></blockquote><ol><li><p>该黑马点评下项目，主要是使用Redis缓存</p></li><li><p>Redis缓存有着以下问题</p><ol><li><p>缓存穿透</p></li><li><p>缓存雪崩</p></li><li><p>缓存击穿</p></li></ol></li><li><p>Redis缓存的更新策略的选择</p></li><li><p>内存淘汰</p></li><li><p>超时剔除</p></li><li><p>主动更新</p></li></ol><h2 id="商户缓存添加"><a href="#商户缓存添加" class="headerlink" title="商户缓存添加"></a>商户缓存添加</h2><h3 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h3><ul><li><p>操作方式</p></li><li><ul><li>查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</li></ul></li><li><p>流程图</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/SeLHug4r79CMJox.png" alt="img"></li></ul></li></ul><h3 id="商户缓存查询"><a href="#商户缓存查询" class="headerlink" title="商户缓存查询"></a>商户缓存查询</h3><ol><li><p>前后端请求接口和传输对象</p><ol><li><p>GET请求，请求路径为<code>/shop/&#123;id&#125;</code></p></li><li><p>请求参数为<code>Long id</code></p></li></ol></li><li><p>返回数据对象</p><ol><li><code>pojo/entity/Shop</code></li></ol></li><li><p>代码逻辑</p><ol><li>从redis中根据商户id查询缓存<ol><li>有，直接返回数据</li><li>无，根据商户id查询数据库<ol><li>无，返回错误信息</li><li>有，写入Redis，返回数据</li></ol></li></ol></li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.OPERATE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,jsonStr);</span><br><span class="line">    stringRedisTemplate.expire(RedisConstants.CACHE_SHOP_KEY+id,RedisConstants.CACHE_SHOP_TTL,      TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><ul><li><p>在缓存更新策略的选择上，通过“<strong>主动更新</strong>”方式来绝大程度上保障“<strong>数据一致性</strong>”</p></li><li><p>在<strong>主动更新的三大策略中</strong>选择Cache Aside Pattern（由缓存的调用者，在更新数据库的同时更新缓存）方式，在对数据库进行操作时，同时更新缓存</p><ul><li>这样做的对数据一致性解决的更好，但是对性能的要求较高</li></ul></li><li><p><strong>而在对缓存问题的处理上</strong></p><ul><li>先删除缓存</li><li>单体系统–缓存与数据库操作放在一个事务</li><li>先操作数据库，再处理缓存</li></ul></li></ul><h3 id="实现商铺缓存与数据库双写一致"><a href="#实现商铺缓存与数据库双写一致" class="headerlink" title="实现商铺缓存与数据库双写一致"></a>实现商铺缓存与数据库双写一致</h3><ol><li><p>前后端请求接口和传输对象</p><ol><li>Put请求，请求路径为<code>/shop</code></li><li>请求参数为<code>Shop shop</code></li></ol></li><li><p>实现逻辑</p><ol><li><p>确保缓存处理和数据库操作为一个原子性操作</p><ol><li>在更新方法上添加<code>@Transactional</code>注解</li></ol></li><li><p>先对shop数据进行数据库修改</p><ol><li>失败，返回异常信息</li><li>成功，删除该shop对应的缓存信息</li></ol></li><li><p>返回成功信息</p></li></ol></li><li><p>实现代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shop.getId() == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        shopMapper.updateById(shop);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_UPDATE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + shop.getId());</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三大缓存问题"><a href="#三大缓存问题" class="headerlink" title="三大缓存问题"></a>三大缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ul><li><p>缓存穿透指的是大量的请求<strong>避开了对缓存的调用</strong>，而直接将请求打到了数据库</p></li><li><p>举个例子</p><ul><li>在对商户查询是通过<code>id</code>；如果人为修改<code>id=-1</code>进行恶意查询</li><li><code>String shopStr = stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</code>返回的<strong>shopStr</strong>一定为<strong>null</strong>（主键id策略为auto，所以id一定&gt;&#x3D;1），从而大量请求打到数据库中，造成破坏</li><li><code>Shop shop = shopMapper.selectById(id);</code>该对数据的查询结果<strong>shop</strong>也一定为<strong>null；</strong>既不会响应正确数据，也不会缓存数据到redis中，陷入恶性循环</li></ul></li><li><p>解决方法</p><ol><li><strong>缓存null值</strong><ol><li>我们都知道数据库能够承载的并发不如Redis高，如果大量的请求同时过来访问这种<strong>不存在的数据</strong>，这些请求就都会访问到数据库，简单的解决方案就是‘哪怕这个数据在数据库中也不存在’，我们也把这个数据存入到Redis中去，这样，下次用户过来访问这个不存在的数据，那么在Redis中也能找到这个数据就不会打到到数据库了</li></ol></li><li><strong>布隆过滤器</strong><ol><li>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行；这个请求会去访问Redis，哪怕Redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到Redis中；假设布隆过滤器判断这个数据不存在，则直接返回。</li><li>布隆过滤器走的是哈希思想，只要是哈希思想，就可能存在哈希冲突</li></ol></li><li>流程图<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/Ki7VfZRHNEMCG9x.webp" alt="img"></li></ol></li><li><strong>增强id的复杂度，避免被猜测id规律</strong><ol><li>对于基础数据表中id的自增策略的修改\</li></ol></li><li><strong>做好数据的基础格式校验</strong><ol><li>对id的特判，例如，对id&lt;&#x3D;0的请求直接返回</li></ol></li><li><strong>加强用户权限校验</strong></li><li><strong>做好热点参数的限流</strong></li></ol></li></ul><h4 id="代码逻辑（缓存null值）"><a href="#代码逻辑（缓存null值）" class="headerlink" title="代码逻辑（缓存null值）"></a>代码逻辑（缓存null值）</h4><ul><li>对id判断是否&lt;&#x3D;0以及是否为null<ul><li>是，返回错误信息</li><li>否，通过id查询缓存</li><li>空值，返回错误信息<ul><li>有，返回数据信息</li><li>无，查询数据库<ul><li>有，写入redis，返回数据</li><li>无，将null值也写入redis，返回错误</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="literal">null</span> || id &lt; SystemConstants.ONE )&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(shopStr, <span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().</span><br><span class="line">                set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key,jsonStr);</span><br><span class="line">    stringRedisTemplate.expire(key,RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/6u2dBt5fG9ObhLl.png" alt="img"></p><h4 id="代码逻辑（布隆过滤器）"><a href="#代码逻辑（布隆过滤器）" class="headerlink" title="代码逻辑（布隆过滤器）"></a>代码逻辑（布隆过滤器）</h4><ul><li><p>实现原理<code>https://www.cnblogs.com/z941030/p/9218356.html</code></p><ul><li><p>布隆过滤器实现较为复杂，这里通过封装了布隆过滤器的Java工具类库（<code>https://www.hutool.cn/docs/#/</code>）实现。</p></li><li><p>导入<code>hutool</code>的依赖即可</p></li></ul></li><li><p>根据<code>hutool</code>的布隆过滤器实现自定义一个工具类，方便使用</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleBloomFilterUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前过滤器预先开辟的最大包含记录,通常要比预计存入的记录多一倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CURRENT_BIT</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前过滤器预计所要包含的记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash函数个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_NUMBER</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BitMap的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BitSetBloomFilter BIT_SET_BLOOM_FILTER;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BitMapBloomFilter BIT_MAP_BLOOM_FILTER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化配置</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">        BIT_SET_BLOOM_FILTER = BloomFilterUtil.createBitSet(CURRENT_BIT, N, HASH_NUMBER);</span><br><span class="line">        BIT_MAP_BLOOM_FILTER = BloomFilterUtil.createBitMap(M);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实现逻辑</p><ul><li><p>添加商户数据</p><ul><li>失败，返回错误信息</li><li>成功，添加对应字符串（KEY）到布隆过滤器，返回成功信息。</li></ul></li><li><p>查询商户数据</p><ul><li>查看请求中的商户id生成的KEY是否在布隆过滤器中<ul><li>不存在，返回错误信息</li><li>存在，放行到Redis中查询</li><li>后续逻辑一致</li></ul></li></ul></li></ul></li><li><p>实现代码</p><ol><li>前后端请求接口和传输对象<ol><li>Post请求 <code>/shop</code></li><li>请求参数为<code>Shop shop</code></li></ol></li></ol></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加商户数据</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveShop</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        shopMapper.insert(shop);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY+id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">add</span> <span class="operator">=</span> SingleBloomFilterUtil.BIT_MAP_BLOOM_FILTER.add(key);</span><br><span class="line">    <span class="keyword">if</span> (!add)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;添加布隆过滤器错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="literal">null</span> || id &lt; SystemConstants.ONE )&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> SingleBloomFilterUtil.BIT_MAP_BLOOM_FILTER.contains(key);</span><br><span class="line">    <span class="keyword">if</span> (!contains)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key,jsonStr);</span><br><span class="line">    stringRedisTemplate.expire(key,RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul><li><p>缓存雪崩是指在<strong>同一时段大量的缓存key同时失效</strong>或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力</p></li><li><p>形象地说就是Redis不工作了，许多客户地请求都转向了数据库，导致数据库压力过大</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/wHomaTDXNALB5ht.webp" alt="img"></li></ul></li><li><p>这里地解决对象主要分为2种</p><ol><li><p><strong>针对数据同时过期处理方案</strong></p><ol><li>给不同的Key的TTL添加随机值；确保大量地key不会同一时间失效</li><li>设置多级缓存<ol><li>浏览器访问静态资源时，优先读取浏览器本地缓存</li><li>访问非静态资源（ajax查询数据）时，访问服务端，请求到达Nginx后，优先读取Nginx本地缓存</li><li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li><li>如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库</li></ol></li></ol></li><li><p><strong>Redis服务宕机方案（</strong>集群、降级限流涉及微服务架构，这里了解即可<strong>）</strong></p><ol><li>利用Redis集群提高服务的可用性</li><li>服务熔断或请求限流机制</li></ol></li></ol></li><li><p><strong>代码实现</strong></p></li><li><p>前后端请求接口和传输对象</p><ul><li>GET请求，请求路径为<code>/shop/&#123;id&#125;</code></li><li>请求参数为<code>Long id</code></li></ul></li><li><p>代码逻辑</p><ul><li>对Redis缓存的TTL做修改即可</li><li>新建一个缓存工具类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheUtil</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cache</span><span class="params">(String key,String value, <span class="type">long</span> ttl, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,value,ttl,unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;缓存失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>把随机数加基本缓存时间作为整体TTL</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0-9的随机数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">randomTime</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//自动拆/装</span></span><br><span class="line"><span class="type">long</span> <span class="variable">keyTtl</span> <span class="operator">=</span> Long.parseLong(randomTime) + RedisConstants.CACHE_SHOP_TTL;</span><br><span class="line"><span class="comment">//自定义的工具类使用</span></span><br><span class="line">cacheUtil.cache(key,jsonStr,keyTtl,TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><ul><li><p>实现成功标识</p><ul><li><p>点击<code>美食-&gt;102茶餐厅</code></p></li><li><p>查看缓存信息，TTL是一个固定值加上随机值</p></li><li><p>再次刷新浏览器，若没有进行数据库查询，则成功</p></li></ul></li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul><li><p>缓存击穿问题也叫<strong>热点Key</strong>问题，就是一个被<strong>高并发访问</strong>并且缓存<strong>重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的<strong>冲击</strong></p></li><li><p>形象来说，就是有一个商家被非常多的人光顾（请求）；但是有一天🔑坏了，并且修复这把钥匙花费的时间较长，这时就有非常多的客人被拒之门外无法查看（无法获取该高并发的缓存），它们只好一股脑地去找老板开门（对数据库请求），但由于数量太多、修复时间长，老板的家炸了（数据库无法承受这些压力）</p></li><li><p>区分</p><ul><li>缓存穿透是没有数据而绕过Redis查询，且数据库也无法获取数据</li><li>缓存击穿是Redis中的数据失效了，但是数据库中有数据，只不过访问量过于庞大</li></ul></li><li><p>缓存击穿问题分析</p><ul><li>假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/8NcgrRnM7VPFt5u.png" alt="img"></li></ul></li><li><p>解决方案有两种</p><ol><li><strong>互斥锁</strong></li><li><strong>逻辑过期</strong></li></ol></li></ul><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><ol><li><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从<strong>并行变成了串行</strong>，我们可以采用<strong>tryLock方法 + double check</strong>来解决这样的问题。</p></li><li><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了</p></li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/fJsEceWOzwG637q.png" alt="img" style="zoom:50%;" /></li><li><p>前置知识</p><ol><li>利用Redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在<code>stringRedisTemplate</code>调用的方法中返回true， 如果有这个key则插入失败，则返回0，在<code>stringRedisTemplate</code>调用的方法中返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程</li></ol></li><li><p>流程图</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/ARcgeuNtTh1sviL.png" alt="img"></li></ol></li><li><p>代码逻辑</p><ol><li>根据id查询缓存<ol><li>命中，直接返回</li><li>未命中，尝试获取锁<ol><li>获取失败，休眠、双重检查（判断）、重新查找（递归）</li><li>成功，根据id查询数据库<ol><li>无，返回错误信息</li><li>有，写入Redis并返回数据</li><li>释放锁</li></ol></li></ol></li></ol></li></ol></li><li><p>具体代码</p><ol><li>RedisUtil</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key,String value)</span>&#123;</span><br><span class="line">    <span class="comment">//设置超时时间防止死锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> stringRedisTemplate</span><br><span class="line">            .opsForValue()</span><br><span class="line">            .setIfAbsent(key, value,RedisConstants.LOCK_SHOP_TTL,</span><br><span class="line">                    TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>queryWithMutex</code>实现</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="literal">null</span> || id &lt; SystemConstants.ONE )&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//锁的key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//锁的是id对应的商户查询线程</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockValue</span> <span class="operator">=</span> RandomUtil.randomString(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//申明shop</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> redisUtil.tryLock(lockKey, lockValue);</span><br><span class="line">            <span class="comment">//获取失败</span></span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                Thread.sleep(RedisConstants.TTL * <span class="number">10</span>);</span><br><span class="line">                <span class="comment">//双重检查</span></span><br><span class="line">                shopStr = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">                <span class="keyword">if</span> (shopStr != <span class="literal">null</span>)&#123;</span><br><span class="line">                    shop = JSONUtil.toBean(shopStr, Shop.class);</span><br><span class="line">                    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//再次尝试</span></span><br><span class="line">                queryWithMutex(id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取成功</span></span><br><span class="line">            shop = shopMapper.selectById(id);</span><br><span class="line">            <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//写入redis</span></span><br><span class="line">            shopStr = JSONUtil.toJsonStr(shop);</span><br><span class="line">          stringRedisTemplate.opsForValue().</span><br><span class="line">              set(key,shopStr,RedisConstants.CACHE_SHOP_TTL,TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            redisUtil.unlock(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Jmeter进行测试 </p><ol><li>首先将Redis中的热点商品数据删除，模拟TTL到期，然后用Jmeter进行压力测试，开100个线程来访问这个没有缓存的热点数据</li><li>如果后台日志<strong>只输出了一条SQL语句</strong>，则说明我们的互斥锁是生效的，没有造成大量用户都去查询数据库，执行SQL语句。</li></ol></li></ol><h4 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><ol><li><p>逻辑过期是指不给<strong>热点KEY</strong>设置过期时间，而是手动给<strong>热点KEY</strong>设置<strong>逻辑过期值</strong>，这样除了Redis集群宕机，否则的话都可以获取到热点数据（热点key不会失效）；不过在对数据的精确上需要根据逻辑过期值来判断</p></li><li><p>逻辑分析</p><ol><li>当用户开始查询Redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回Redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁</li></ol></li><li><p>流程图</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/x4sVjAmkf2RtXeJ.png" alt="img"></li></ol></li><li><p>设计逻辑过期值</p><ol><li>数据缓存时，对<code>shop</code>数据多一个<code>expiredTime</code>字段值<ol><li>对<code>Shop</code>类新增字段<code>expiredTime</code>（侵入性且对实体类做了修改）</li><li>新建RedisData属性类，含逻辑过期字段，继承<code>Shop</code>（可以）</li><li>新建RedisData属性类，含逻辑过期字段和<code>Object data</code>-&gt;<code>Shop</code>（最好）</li></ol></li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="comment">//过期时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="comment">//商户数据</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>代码逻辑</p><ol><li>对需要缓存的数据预处理<ol><li>将逻辑过期值在添加商户的时候就进行缓存</li></ol></li><li>根据id查询缓存<ol><li>未命中，返回错误信息</li><li>命中，查看逻辑过期值是否过期<ol><li>未过期，直接返回数据</li><li>过期，尝试获取锁<ol><li>失败，返回旧的商户信息(不精确) + 消息提示说明</li><li>成功，<strong>开启独立线程</strong>（缓存重建）<ol><li>查询数据库（独立线程）<ol><li>失败，返回错误信息(没有特殊情况都是一定有)</li><li>成功，写入Redis，设置逻辑过期时间</li><li>返回数据</li></ol></li></ol></li></ol></li><li>释放锁</li></ol></li></ol></li></ol></li><li><p>缓存预处理代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存预热</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShopWithRedisData</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE)&#123;</span><br><span class="line">        log.error(MessageConstants.ID_ERROR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        log.info(MessageConstants.CACHE_PRE_SAVE_SUCCESS);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逻辑过期值2分钟</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span>  <span class="operator">=</span> LocalDateTime.now().plusSeconds(RedisConstants.CACHE_NULL_TTL);</span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> RedisData.builder()</span><br><span class="line">            .expireTime(expireTime)</span><br><span class="line">            .data(shop).build();</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisDataStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(redisData);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key,redisDataStr);</span><br><span class="line">    log.info(MessageConstants.CACHE_PRE_SAVE_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>缓存重建代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓存重建任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getCacheRunnable2</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//建立一个任务</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="comment">//查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopMapper.selectById(id);</span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//逻辑过期值2分钟</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span>  <span class="operator">=</span> LocalDateTime.now().plusSeconds(RedisConstants.CACHE_SHOP_TTL);</span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> RedisData.builder()</span><br><span class="line">                .expireTime(expireTime)</span><br><span class="line">                .data(shop).build();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisDataStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(redisData);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,redisDataStr);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>线程池创建<ol><li>创建线程池（手动，黑马通过<code>Executors</code>工具自动生成线程池{<strong>不推荐</strong>）</li><li>原因可看，<a href="https://blog.csdn.net/weixin_43702295/article/details/135354378?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-135354378-blog-132420498.235%5Ev43%5Epc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.1&utm_relevant_index=3">ThreadPoolExecutor手动创建线程池</a></li><li>具体参数说明<code>https://blog.csdn.net/c85736722/article/details/135738604</code></li><li>增强，轻量级的动态可控线程池&#96;<a href="https://dynamictp.cn/%60%60%60">https://dynamictp.cn/```</a></li><li>&#96;&#96;&#96;excute&amp;submit<code>方法的使用区别</code><a href="https://www.cnblogs.com/jxxblogs/p/11882381.html%60">https://www.cnblogs.com/jxxblogs/p/11882381.html`</a></li><li>流程图<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/sMIaeoTgH6WnB4u.webp" alt="img"></li></ol></li><li>线程池工具类</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_CORE_POOL</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_MAX_POOL</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存活时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ALIVE_TIME</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放任务的阻塞队列(使用有界队列可以避免资源耗尽的问题)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的拒绝策略，AbortPolicy() 抛异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">DEFAULT_HANDLER</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动创建线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(SIZE_CORE_POOL,</span><br><span class="line">                    SIZE_MAX_POOL,</span><br><span class="line">                    ALIVE_TIME,</span><br><span class="line">                    TimeUnit.MILLISECONDS,</span><br><span class="line">                    queue,</span><br><span class="line">                    ThreadPoolUtil.myDefaultThreadFactory(),</span><br><span class="line">                    DEFAULT_HANDLER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预启动所有核心线程</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        pool.prestartAllCoreThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程池</span></span><br><span class="line"><span class="comment">     * ‘<span class="doctag">@Data</span>’注解对static变量无效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">getPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">myDefaultThreadFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyDefaultThreadFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义线程工厂</span></span><br><span class="line"><span class="comment">     * 用于创建具有特定命名规则和默认属性的新线程,方便出错时回溯</span></span><br><span class="line"><span class="comment">     * 这里和源码一致-Executors.defaultThreadFactory()的源码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyDefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">        <span class="comment">//一个原子整数，用于生成线程池编号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">POOL_NUMBER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//线程组，用于指定新线程所属的线程组</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="comment">//一个原子整数，用于生成线程编号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//线程名称前缀，用于标识线程所属的线程池和线程编号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 告诉编译器忽略与&quot;removal&quot;相关的警告,用于处理即将被移除或已过时的API时</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;removal&quot;)</span></span><br><span class="line">        MyDefaultThreadFactory() &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                    Thread.currentThread().getThreadGroup();</span><br><span class="line">            <span class="comment">//设置线程名称前缀</span></span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                    POOL_NUMBER.getAndIncrement() +</span><br><span class="line">                    <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(<span class="meta">@NonNull</span> Runnable r)</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个新线程，传入线程组、任务（Runnable对象）、线程名称和栈大小</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                    namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                    <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//设置线程是否为守护线程</span></span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon()) &#123;</span><br><span class="line">                t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置线程优先级，默认为正常优先级（NORM_PRIORITY）</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY) &#123;</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>具体代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisDataStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(redisDataStr, RedisData.class);</span><br><span class="line">    <span class="keyword">if</span> (redisDataStr == <span class="literal">null</span> || redisData == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取逻辑过期值</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">//商户数据,这里的转换很重要</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="comment">//当前时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (expireTime.isAfter(now))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">//获取线程池</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> threadPoolUtil.getPool();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> redisUtil.tryLock(lockKey, RedisConstants.KEY_VALUE);</span><br><span class="line">        <span class="comment">//获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//获取任务</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">cacheRunnable</span> <span class="operator">=</span> getCacheRunnable2(id);</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            pool.execute(cacheRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        redisUtil.unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回旧数据</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li><p>使用Jmeter进行测试 </p><ul><li><p>先来复现一遍场景，当某个用户去Redis中访问缓存的数据时，发现该数据已经过期了，于是新开一个线程去重构缓存数据，但在重构完成之前，用户得到的数据都是旧数据，重构完成之后，才是新数据</p></li><li><p>我把逻辑过期方法作为一个新的请求<code>/cache/&#123;id&#125;</code>,所以先发送一个该请求完成<strong>缓存预热</strong>，过期时间为2分钟，使其快速过期；再使用基于逻辑过期的请求方法查询商户信息</p></li><li><p>之后去数据库把这个数据修改一下，这样逻辑过期前和逻辑过期后的数据就不一致，当用户来访问数据的时候，需要花时间来进行重构缓存数据，但是在重构完成之前，都只能获得脏数据（也就是我们修改前的数据），只有当重构完毕之后，才能获得新数据（我们修改后的数据）  </p></li><li><p>注意：测试线程数不能过大，否则线程池会爆掉</p></li><li><p>结果</p><ul><li>前两分钟逻辑过期值存在，控制台不会输出sql查询；结束后，通过jmeter测试，逻辑缓存时间变为为30分钟，且缓存数据得到修改</li></ul></li></ul></li><li><p>缓存效果图</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/dgj3bwH1LocX7uz.png" alt="img"></p></li><li><p>互斥锁与逻辑过期比较图</p></li><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/05/dgj3bwH1LocX7uz.png" alt="img"></p></li></ol><h3 id="缓存工具类"><a href="#缓存工具类" class="headerlink" title="缓存工具类"></a>缓存工具类</h3><ul><li>对于缓存问题的解决，都是特定情况特定使用，因此会去构建一个缓存工具类来使用</li><li>这里直接贴黑吗代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息w</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="优惠卷秒杀"><a href="#优惠卷秒杀" class="headerlink" title="优惠卷秒杀"></a>优惠卷秒杀</h1><h2 id="Redis实现全局唯一ID"><a href="#Redis实现全局唯一ID" class="headerlink" title="Redis实现全局唯一ID"></a>Redis实现全局唯一ID</h2><h3 id="何为全局唯一ID"><a href="#何为全局唯一ID" class="headerlink" title="何为全局唯一ID"></a>何为全局唯一ID</h3><ul><li>查看文档 “何为全局唯一ID”</li></ul><h3 id="优惠卷介绍"><a href="#优惠卷介绍" class="headerlink" title="优惠卷介绍"></a>优惠卷介绍</h3><ol><li><p>每个店铺都可以发布优惠券</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/8r2BmCj1dcEUbuM.webp" alt="img"></li></ol></li><li><p>当用户抢购时，就会生成订单并保存到<code>tb_voucher_order</code>这张表中，而订单表如果使用数据库自增ID就存在一些问题</p><ol><li>id的规律性太明显</li><li>受单表数据量的限制</li></ol></li><li><p>场景分析</p><ol><li>如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适</li><li>随着我们商城规模越来越大，<strong>mysql</strong>的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性</li></ol></li><li><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具</p></li></ol><h3 id="基于Redis实现全局唯一ID"><a href="#基于Redis实现全局唯一ID" class="headerlink" title="基于Redis实现全局唯一ID"></a>基于Redis实现全局唯一ID</h3><ol><li><p>前提</p></li><li><p>redis的<code>incr命令</code></p><ol><li>Redis的<code>INCR</code>命令是一个用于对存储在Redis键中的整数值进行自增操作的命令；如果目标键不存在，则首先将其初始化为0，然后执行自增操作；此命令返回自增后的值<ol start="2"><li>对于<code>INCR</code>命令，其核心作用是实现对<strong>数字字符串的自增操作</strong>；由于Redis没有专用的整数类型，键对应的字符串在执行<code>INCR</code>命令时会被解释为十进制（64位有符号整数）<ol start="3"><li><code>INCR</code>命令具有<strong>原子性特征</strong>，这意味着在多线程或并发环境下，多个客户端可以同时对同一个键执行INCR命令，而不会出现竞态条件或数据不一致的问题</li></ol></li></ol></li></ol></li><li><p>RedisUtil</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line">    <span class="comment">//原始时间戳BASE_TIME</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1704067200L</span>;</span><br><span class="line">    <span class="comment">//移动的位数bit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">//1生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowEpochSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="comment">//时间差</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowEpochSecond - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2生成序列号</span></span><br><span class="line">        <span class="comment">//2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        <span class="comment">//3拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BIT | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch-信号枪"><a href="#CountDownLatch-信号枪" class="headerlink" title="CountDownLatch 信号枪"></a>CountDownLatch 信号枪</h3><blockquote><p>补充知识，了解即可</p></blockquote><ol><li>主要的作用是同步协调在多线程的等待于唤醒问题</li><li>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</li><li>CountDownLatch 中有两个最重要的方法<ol><li>countDown</li><li>await<ol><li>await方法是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞</li><li>那么什么时候main线程不再阻塞呢？当CountDownLatch 内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch 维护的变量变为0 呢?</li><li>我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间</li></ol></li></ol></li></ol><h2 id="优惠卷"><a href="#优惠卷" class="headerlink" title="优惠卷"></a>优惠卷</h2><h3 id="优惠卷简介"><a href="#优惠卷简介" class="headerlink" title="优惠卷简介"></a>优惠卷简介</h3><ol><li><p>每个店铺都可以发布优惠券，分为平价券和<strong>特价券</strong>。平价券可以任意购买，而特价券需要秒杀抢购</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/L8cAIHxgqzKe9hW.webp" alt="img"></li></ol></li><li><p>优惠卷的表结构信息</p></li><li><ol><li><code>tb_voucher</code> 优惠卷表，主要包含优惠的商家id、优惠卷类型、是否上架、优惠价格、开始、结束时间</li><li><code>tb_seckill_voucher</code>秒杀卷表，主要包含关联的优惠卷id、库存、抢购、结束时间</li></ol></li></ol><h3 id="添加优惠卷"><a href="#添加优惠卷" class="headerlink" title="添加优惠卷"></a>添加优惠卷</h3><h4 id="新增普通优惠卷"><a href="#新增普通优惠卷" class="headerlink" title="新增普通优惠卷"></a>新增普通优惠卷</h4><ol><li><p>前后端请求接口和传输对象</p></li><li><ol><li>Post请求<code>/vocher</code></li><li>传输参数<code>Voucher voucher</code></li></ol></li><li><p>代码实现</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherMapper.insert(voucher);</span><br><span class="line">    <span class="keyword">if</span> (row != SystemConstants.ONE)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新增秒杀优惠卷"><a href="#新增秒杀优惠卷" class="headerlink" title="新增秒杀优惠卷"></a>新增秒杀优惠卷</h4><ol><li><p>前后端请求接口和传输对象</p><ol><li>Post请求<code>/vocher/seckill</code></li><li>传输参数<code>Voucher voucher</code></li><li>存储对象实体<code>SeckillVoucher</code></li></ol></li><li><p>代码逻辑</p><ol><li><p>判断<code>voucher</code>是否为空</p><ol><li><p>是，返回错误信息</p></li><li><p>不是，存入数据库中</p><ol><li>得到优惠卷id，new<code>SeckillVoucher</code>对象保存秒杀卷信息</li><li>存储数据库</li></ol></li><li><p>由于涉及两张表之间的操作</p><ol><li>开启事务注解<code>@Transactional(rollbackFor = Exception.class)</code></li></ol></li></ol></li></ol></li><li><p>具体实现</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (voucher == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    voucherMapper.insert(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherMapper.insert(seckillVoucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>测试<ol><li>由于这里并没有后台管理页面，所以用apifox&#x2F;postman等模拟发送请求来新增秒杀券</li><li>请求路径<code>http://localhost:8081/voucher/seckill</code>， 请求方式POST</li><li>JSON数据如下，注意优惠券的截止日期设置，若优惠券过期，则不会在页面上显示。</li></ol></li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;shopId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;100元代金券&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subTitle&quot;</span><span class="punctuation">:</span><span class="string">&quot;周一至周五可用&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span><span class="string">&quot;全场通用\\n无需预约\\n可无限叠加&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;payValue&quot;</span><span class="punctuation">:</span><span class="number">8000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;actualValue&quot;</span><span class="punctuation">:</span><span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;beginTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2024-06-21T00:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;endTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2024-06-30T23:59:59&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="优惠卷查询"><a href="#优惠卷查询" class="headerlink" title="优惠卷查询"></a>优惠卷查询</h3><ol><li><p>前后端请求接口和传输对象</p><ol><li>GET请求<code>/vocher/list/&#123;shopId&#125;</code></li><li>传输参数<code>Long shopId</code></li></ol></li><li><p>代码实现</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryVoucherOfShop</span><span class="params">(Long shopId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shopId == <span class="literal">null</span> || shopId &lt; SystemConstants.ONE)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据shopId查询优惠卷集合</span></span><br><span class="line">    List&lt;Voucher&gt; vouchers = voucherMapper.queryVoucherOfShop(shopId);</span><br><span class="line">    <span class="keyword">if</span> (vouchers == <span class="literal">null</span> || vouchers.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(vouchers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="秒杀下单"><a href="#秒杀下单" class="headerlink" title="秒杀下单"></a>秒杀下单</h2><h3 id="何为秒杀下单"><a href="#何为秒杀下单" class="headerlink" title="何为秒杀下单"></a>何为秒杀下单</h3><ol><li><p>下单核心思路：当我们点击抢购时，会触发抢购请求</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/F8UDYuExPikIjVv.webp" alt="img"></li></ol></li><li><p>秒杀下单需要考虑的问题</p><ul><li><p>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</p></li><li><p>库存是否充足，不足则无法下单</p></li></ul></li><li><p>下单核心逻辑分析</p></li><li><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息</p></li><li><p>判断是否满足秒杀条件</p></li><li><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束</p></li></ol><h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><ol><li><p>前后端请求接口和传输对象</p><ol><li>Post请求<code>/vocher-order/seckill/&#123;id&#125;</code></li><li>传输参数<code>Long id</code></li></ol></li><li><p>代码逻辑</p><ol><li>优惠卷id判断<ol><li>不可用，返回错误信息</li><li>可用，查询优惠卷信息<ol><li>判断时间状态是否满足<ol><li>不满足，返回错误信息</li><li>满足，判断库存是否足够<ol><li>不足，返回错误信息</li><li>足够，库存-1，并创建优惠卷订单保存到数据库中<ol><li>优惠劵订单id采用<code>RedisUtil</code>的全局唯一id</li><li>返回订单id</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li><li><p>实际代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">getOrder</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">    <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    stock = stock - <span class="number">1</span>;</span><br><span class="line">    seckillVoucher.setStock(stock);</span><br><span class="line">    seckillVoucherMapper.updateById(seckillVoucher);</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(id);</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(voucherOrder);</span><br><span class="line">    <span class="keyword">if</span> (row != SystemConstants.ONE)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="库存超卖"><a href="#库存超卖" class="headerlink" title="库存超卖"></a>库存超卖</h2><h3 id="库存超卖问题分析"><a href="#库存超卖问题分析" class="headerlink" title="库存超卖问题分析"></a>库存超卖问题分析</h3><ol><li>库存判断代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line"><span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">&#125;</span><br><span class="line">stock = stock - <span class="number">1</span>;</span><br><span class="line">seckillVoucher.setStock(stock);</span><br><span class="line">seckillVoucherMapper.updateById(seckillVoucher);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>分析</p><ol><li><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题</p></li><li><p>分析图<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/mOqj71hNkaIl9BS.webp" alt="img"></p></li></ol></li><li><p>我们之前的代码其实是有问题的，当遇到高并发场景时，会出现超卖现象</p><ol><li>我们可以用<code>Jmeter</code>开200个线程来模拟抢优惠券的场景，URL ：<code>localhost:8081/voucher-order/seckill/13</code>，POST请求</li><li>结果图异常率应在50%左右<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/I5JjWySKV8m9YQr.webp" alt="img"></li><li>秒杀卷库存应为0<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/25zIhH9RDJsBja6.webp" alt="img"></li><li>Redis序列号值应为100</li><li>订单数据应在100</li></ol></li></ol><h3 id="超卖问题解决"><a href="#超卖问题解决" class="headerlink" title="超卖问题解决"></a>超卖问题解决</h3><ol><li><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁；而对于加锁，通常有两种解决方案：</p><ol><li><p>悲观锁</p><ol><li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行</li><li>例如synchronized、Lock都属于悲观锁</li></ol></li><li><p>乐观锁</p><ol><li>认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时丢判断有没有其它线程对数据做了修改</li><li>如果没有修改则认为是安全的，自己才更新数据</li><li>如果已经被其线程修改说明发生了安全问题，此时可以重试或异常</li></ol></li></ol></li><li><p>悲观锁实现</p><ol><li><p>通过<code>Synchronized</code>关键字实现</p><ol><li>直接对抢购方法加锁</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">getOrder</span><span class="params">(Long id)</span> &#123;....&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过synchronized(资源)加锁，更为精确</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">    <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    stock = stock - <span class="number">1</span>;</span><br><span class="line">    seckillVoucher.setStock(stock);</span><br><span class="line">    seckillVoucherMapper.updateById(seckillVoucher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>乐观锁实现</p><ol><li><p>版本号法</p><ol><li>逻辑：每一数据会有一个<strong>版本号</strong>，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过</li><li>黑马课程中并没有对数据表新增一个字段version来进行判断，因为库存stock本身也可用来进行判断是否被修改过；再直接，就是判断库存是否&gt;0即可</li><li>代码逻辑<ol><li>再对库存进行-1时，判断库存是否大于0<ol><li>有，抢购失败</li><li>无，抢购成功</li></ol></li></ol></li><li>实际代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getOrderWithPositive</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键sql</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> seckillVoucherMapper.updateByIdAndStock(seckillVoucher);</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(id);</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(voucherOrder);</span><br><span class="line">    <span class="keyword">if</span> (row != SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.乐观锁实现</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> id<span class="operator">=</span>&quot;updateByIdAndStock&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">update</span> hmdp.tb_seckill_voucher </span><br><span class="line">        <span class="comment">-- 不是用查询到的#&#123;stock&#125;-1,而是本来的stock - 1</span></span><br><span class="line">        <span class="keyword">set</span> stock <span class="operator">=</span> tb_seckill_voucher.stock <span class="operator">-</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="comment">-- 如果判断stock = #&#123;stock&#125;，那么当100个线程判断时只有1个可以完成错误率较高</span></span><br><span class="line">        voucher_id <span class="operator">=</span> #&#123;voucherId&#125; <span class="keyword">and</span> stock <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>时间戳法</p><ol><li>时间戳法实现乐观锁是<strong>在数据表中增加一个时间戳字段，当数据被读取时记录下当前的时间戳，当数据被更新时，检查当前时间戳是否与读取时的时间戳一致</strong>，如果不一致，则说明数据已被其他事务修改，当前事务执行失败</li><li>和版本号法原理一致</li></ol></li><li><p>CAS( Compare And Swap  )自旋法</p></li><li><p>Jmeter测试</p><ol><li>测试结果符合应符合200人100订单，库存为0</li></ol></li></ol><h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><ol><li><p>需求 : 修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p></li><li><p>现在的问题：</p><ol><li>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一单，而不是让一个用户下多单</li><li>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</li><li>流程图<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/6UVt8aApBmqLJoc.webp" alt="img"></li></ol></li></ol></li><li><p>代码逻辑</p><ol><li>Id非空判断</li><li>根据ID查询秒杀卷信息<ol><li>无，返回错误信息</li><li>有，判断开始和结束时间<ol><li>不在范围，返回错误信息</li><li>在范围，判断库存是否满足<ol><li><p>不满足，返回错误信息</p></li><li><p>满足，根据优惠卷id和用户id查询</p><ol><li>已购，返回错误信息</li><li>未购，库存-1，且新增订单</li></ol></li><li><p>返回订单Id</p></li></ol></li></ol></li></ol></li></ol></li><li><p>具体代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">getOrderOnly</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">        <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> voucherOrderMapper.selectByUserIdAndVoucherId(userId,id);</span><br><span class="line">        <span class="keyword">if</span> (voucherOrder != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.ORDER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//库存修改</span></span><br><span class="line">        seckillVoucherMapper.updateByIdAndStock(seckillVoucher);</span><br><span class="line">        <span class="comment">//创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        order.setId(orderId);</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line">        order.setVoucherId(id);</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(order);</span><br><span class="line">        <span class="keyword">if</span> (row != SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>存在问题</strong></p><ol><li><p>高并发时，查询数据库都不存在订单的情况</p></li><li><p>所以我们还是需要加锁，但是<strong>乐观锁比较适合更新数据</strong>，而现在是插入数据，所以我们需要使用悲观锁操作</p></li><li><p>在对悲观锁操作时，需要考虑细粒度问题</p><ol><li>如果直接对整个方法加锁，固然可以实现一人一单</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">getOrderOnly</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">    <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> voucherOrderMapper.selectByUserIdAndVoucherId(userId, id);</span><br><span class="line">    <span class="keyword">if</span> (voucherOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.ORDER_ERROR);</span><br><span class="line">    </span><br><span class="line">    seckillVoucherMapper.updateByIdAndStock(seckillVoucher);</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    order.setVoucherId(id);</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(order);</span><br><span class="line">    <span class="keyword">if</span> (row != SystemConstants.ONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong>是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  Result <span class="title function_">getOrderOnly</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span> || id &lt; SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.ID_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherMapper.selectById(id);</span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.DATA_QUERY_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="keyword">if</span> (now.isBefore(beginTime) || now.isAfter(endTime)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_TIME_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">        <span class="keyword">if</span> (stock &lt; SystemConstants.ONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.VOUCHER_STOCK_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//只需要对同一个用户的进程进行锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> voucherOrderMapper.</span><br><span class="line">                selectByUserIdAndVoucherId(userId, id);</span><br><span class="line">            <span class="keyword">if</span> (voucherOrder != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(MessageConstants.ORDER_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            seckillVoucherMapper.updateByIdAndStock(seckillVoucher);</span><br><span class="line">            <span class="comment">//创建订单</span></span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">            <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisUtil.getId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            order.setId(orderId);</span><br><span class="line">            order.setUserId(userId);</span><br><span class="line">            order.setVoucherId(id);</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> voucherOrderMapper.insert(order);</span><br><span class="line">            <span class="keyword">if</span> (row != SystemConstants.ONE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(MessageConstants.NEW_DATA_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>分析</p><ol><li><p>因为一人一单只是防止同一个用户多次获取秒杀卷，所以在对进程加锁时，只需要对同一用户的不同进程加锁</p></li><li><p>他们有着共同的锁资源就是他们的用户ID</p></li><li><p>又因为<code>userId.toString()</code>的对象是new出来的，不能保障共同锁资源，所以资源对象为<code>userId.toString().intern()</code>，这是从字符串常量池中获取用户Id，确保了唯一性</p></li><li><p>源码分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stringSize(i);</span><br><span class="line">    <span class="keyword">if</span> (COMPACT_STRINGS) &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">        getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, LATIN1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size * <span class="number">2</span>];</span><br><span class="line">        StringUTF16.getChars(i, size, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, UTF16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/DzYkTI5KfyUhQ8B.webp" alt="img"></p></li></ol></li></ol></li></ol></li></ol><h2 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h2><blockquote><p>来源：黑马资料</p></blockquote><h3 id="集群环境模拟"><a href="#集群环境模拟" class="headerlink" title="集群环境模拟"></a>集群环境模拟</h3><ul><li><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了</p></li><li><p>我们将服务启动两份，端口分别为8081和8082：</p><ol><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/dayKHhn1wQkilqY.webp" alt="img"></p></li><li><p>然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡</p><ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/TXO42QwxqrF7ZMP.webp" alt="img"></li></ol></li></ol></li><li><p>后续具体操作，观看黑马视频</p></li></ul><h3 id="有关锁失效原因分析"><a href="#有关锁失效原因分析" class="headerlink" title="有关锁失效原因分析"></a>有关锁失效原因分析</h3><ul><li>由于现在我们部署了多个tomcat，每个tomcat都有一个<strong>属于自己的jvm</strong>，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的</li><li>但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥</li><li>这就是集群环境下，synchronized锁失效的原因(基于JVM内存实现)，在这种情况下，我们就需要使用<strong>分布式锁</strong>来解决这个问题</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/07/GVv4HNpIJlWXyDj.webp" alt="img"></li></ul><hr><h1 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h1><h2 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h2><blockquote><p>在黑马的“苍穹外卖中”通过百度地图的api调用来完成对地理位置的判断</p><p>MongoDB、Elasticsearch等技术均可实现GEO</p><p>三者的比较<code>https://blog.csdn.net/u014401141/article/details/134646577</code></p></blockquote><ol><li><code>GEO</code>就是Geolocation的简写，代表地理坐标</li><li>Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据</li><li>常见的命令有<ul><li><code>GEOADD</code>添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li><code>GEODIST</code>计算指定的两个点之间的距离并返回</li><li><code>GEOHASH</code>将指定<code>member</code>的坐标转为hash字符串形式并返回</li><li><code>GEOPOS</code>返回指定member的坐标</li><li><code>GEORADIUS</code>指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回；6.2版本以后已废弃</li><li><code>GEOSEARCH</code>在指定范围内搜索<code>member</code>，并按照与指定点之间的距离排序后返回；范围可以是圆形或矩；6.2.新功能</li><li><code>GEOSEARCHSTORE</code>与<code>GEOSEARCH</code>功能一致，不过可以把结果存储到一个指定的key；6.2.新功能</li></ul></li></ol><h2 id="导入店铺数据到GEO"><a href="#导入店铺数据到GEO" class="headerlink" title="导入店铺数据到GEO"></a>导入店铺数据到GEO</h2><ol><li>需求<ol><li>将数据库表中的数据导入到Redis中的GEO去</li><li>GEO在Redis中就一个menber和一个经纬度，我们把x和y轴传入到Redis做的经纬度位置，但不能把所有的数据都放入到member</li><li>Redis作为一个内存级数据库，如果存海量数据，Redis还是力不从心，所以在这个地方存储他的商家id即可</li><li>还有一个问题，就是在Redis中并没有存储type，无法根据type来对数据进行筛选；所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以<code>typeId</code>为key存入同一个GEO集合中即可</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/ThWJZilfkvMeLyD.png" alt="img" style="zoom:50%;" /></li></ol></li><li>代码编写<ol><li>在<code>HmDianPingApplicationTests</code>测试类完成对商户数据的导入</li><li>Stream流的使用根据商户类型id分组，得到特定的<code>List&lt;Shop&gt;</code>集合</li><li>具体代码如下</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()),    shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>成功示例<ol><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/BCQlSUaI91NHFyX.png" alt="img"></li></ol></li></ol><h2 id="实现附近商户搜索功能"><a href="#实现附近商户搜索功能" class="headerlink" title="实现附近商户搜索功能"></a>实现附近商户搜索功能</h2><ol><li><p>版本修改</p><ul><li>SpringDataRedis的 2.3.9 版本并不支持Redis 6.2 提供的<code>GEOSEARCH</code>命令，需要修改版本</li><li>修改pom文件如下</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-data-redis&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lettuce-core&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>具体场景说明</p><ul><li>当点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式</li><li>此时关注的是距离，这个地方就需要使用到GEO，向后台传入当前app收集的地址(此处前端是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的商户数据再返回</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/K1btmcF8uJPN7Dp.png" alt="img" style="zoom:50%;" /></li></ul></li><li><p>依照上图修改<code>ShopController代码</code></p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据商铺类型分页查询商铺信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> current 当前页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeId 类型Id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y 纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 商铺列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据类型分页查询</span></span><br><span class="line">    <span class="keyword">return</span> shopService.typeOfPage(typeId,current,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>业务代码实现，由于涉及到许多不常用api的调用，这里直接导入黑马代码再做修改<ol><li>查询到的是<code>&lt;ShopId,distance&gt;</code>，对其解析和封装</li><li>逻辑分页的实现，<code>Map</code>、<code>List</code>集合的使用</li><li>需要返回的是包含<code>distance</code>信息的商户集合</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">typeOfPage</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要根据坐标查询</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">        PageHelper.startPage(current, SystemConstants.MAX_PAGE_SIZE);</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>().setTypeId(Long.valueOf(typeId));</span><br><span class="line">        Page&lt;Shop&gt; page = shopMapper.pageQuery(shop);</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(MessageConstants.PAGE_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Shop&gt; pageResult = page.getResult();</span><br><span class="line">        <span class="keyword">if</span> (pageResult.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(pageResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算分页参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">    <span class="comment">// 查询redis、按照距离排序、分页；结果：shopId、distance</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.SHOP_GEO_KEY + typeId;</span><br><span class="line">    <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 5 WITHDISTANCE</span></span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo()</span><br><span class="line">            .radius(</span><br><span class="line">            key,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Circle</span>(x, y, <span class="number">10000</span>),</span><br><span class="line">            <span class="comment">//从一开始返回end个数据</span></span><br><span class="line">            RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().limit(end)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 解析出id</span></span><br><span class="line">    <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是返回Zset中的数据</span></span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">    <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">        <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 截取 from ~ end的部分</span></span><br><span class="line">    <span class="comment">//查询到的商户id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">    <span class="comment">//每一个商户ID对应的距离map</span></span><br><span class="line">    Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">    <span class="comment">//将前from个数据跳过</span></span><br><span class="line">    list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取店铺id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">        ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">        <span class="comment">// 获取距离</span></span><br><span class="line">        distanceMap.put(shopIdStr, result.getDistance());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 根据id查询Shop</span></span><br><span class="line">    List&lt;Shop&gt; shops = shopMapper.selectByIds(ids);</span><br><span class="line">    <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">        <span class="comment">//根据id获取对应距离</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> shop.getId().toString();</span><br><span class="line">        shop.setDistance(distanceMap.get(idStr).getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>示例<ol><li>由于Redis版本为5.x，无法使用GEOSEARCH，无法显示距离值</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/s6VtWB15UfQNk4p.png" alt="img"></li></ol></li></ol><hr><h1 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h1><h2 id="Redis-BitMap-位图-功能"><a href="#Redis-BitMap-位图-功能" class="headerlink" title="Redis-BitMap(位图)功能"></a>Redis-BitMap(位图)功能</h2><h3 id="为何使用BitMap"><a href="#为何使用BitMap" class="headerlink" title="为何使用BitMap"></a>为何使用BitMap</h3><ul><li><p>针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/ZvRdbJB3MPfT5oC.png" alt="img"></li><li>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</li><li>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</li></ul></li><li><p><strong>如何解决这个问题？</strong></p><ul><li><p>其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看你在当天是否有打勾</p><ul><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/bkmguLt5KiyxdVX.png" alt="img" style="zoom:50%;" /></li><li><p>可以采用类似这样的方案来实现我们的签到需求，而Redis的BitMap恰好可以实现按月来统计用户签到信息，签到记录为1，未签到则记录为0</p><ul><li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/gSw9XfQOMN1ZAmq.png" alt="img"></p></li><li><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）这样就用极小的空间，来实现了大量数据的表示</p></li></ul></li></ul></li></ul></li><li><p>Redis中是利用String类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位</p></li></ul><h3 id="BitMap的操作命令"><a href="#BitMap的操作命令" class="headerlink" title="BitMap的操作命令"></a>BitMap的操作命令</h3><ul><li><code>SETBIT</code>：向指定位置（offset）存入一个0或1</li><li><code>GETBIT </code>：获取指定位置（offset）的bit值</li><li><code>BITCOUNT</code> ：统计BitMap中值为1的bit位的数量</li><li><code>BITFIELD</code> ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值（一般都用作查询）</li><li><code>BITFIELD_RO</code> ：获取BitMap中bit数组，并以十进制形式返回</li><li><code>BITOP</code> ：将多个BitMap的结果做位运算（与 、或、异或）</li><li><code>BITPOS</code>：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h2 id="实现用户签到功能"><a href="#实现用户签到功能" class="headerlink" title="实现用户签到功能"></a>实现用户签到功能</h2><ol><li>需求<ul><li>实现签到接口，将当前用户当天签到信息保存到Redis中</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/6wkTK9svhFqYouW.png" alt="img" style="zoom:50%;" /></li></ul></li><li>思路<ul><li>我们可以把年和月作为<code>bitMap</code>的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到</li><li>通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改<code>bitMap</code></li></ul></li><li>代码如下</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户数据</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">if</span> (userDTO == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.LOGIN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> userDTO.getId();</span><br><span class="line">    <span class="comment">//当天日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyy-MM&quot;</span>).format(now);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">//当天在该月第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h2><ol><li><p>什么叫做连续签到天数？</p><ul><li>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数</li></ul></li><li><p>Java逻辑代码</p><ul><li>获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</li></ul></li><li><p>如何得到本月到今天为止的所有签到数据？</p><ul><li>命令<code>  BITFIELD key GET u[dayOfMonth] 0</code></li><li>假设今天是10号，那么从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位；去拿这段时间的数据，就能拿到所有的数据了</li></ul></li><li><p>那么这10天里边签到了多少次呢？</p><ul><li>统计有多少个1即可</li></ul></li><li><p>如何从后向前遍历每个bit位？</p><ul><li><code>bitMap</code>返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做<strong>与运算</strong>就可以了</li><li>因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行<strong>与</strong>操作，每与一次，就把签到结果<strong>向右移</strong>动一位，依次内推，就能完成逐个遍历的效果了</li></ul></li><li><p>需求</p><ol><li>实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</li><li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/07/03/Azuv8UpeX3DYrJB.png" alt="img" style="zoom:50%;" /></li></ol></li><li><p>代码逻辑</p><ol><li>与签到功能一样得到用户id、key、dateOfMonth<ol><li>根据key获取bitMap数据<ol><li>通过&amp;和&gt;得到连续签到次数count</li><li>返回count</li></ol></li></ol></li></ol></li><li><p>具体代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户数据</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">if</span> (userDTO == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(MessageConstants.LOGIN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> userDTO.getId();</span><br><span class="line">    <span class="comment">//当天日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyy-MM&quot;</span>).format(now);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">//当天在该月第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">//获取bitMap数据</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue()</span><br><span class="line">        .bitField(key, BitFieldSubCommands.create()                                           .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sign</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sign &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        sign = sign &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用bitmap来解决缓存穿透的方案"><a href="#使用bitmap来解决缓存穿透的方案" class="headerlink" title="使用bitmap来解决缓存穿透的方案"></a>使用bitmap来解决缓存穿透的方案</h2><blockquote><p>值得一提的是布隆过滤器底层就是基于BitMap</p></blockquote><ol><li><p>回顾<strong>缓存穿透</strong></p><ol><li>客户端发起了一个数据库不存在，Redis里边也不存在的数据</li><li>通常你可以把这种行为看成一个攻击</li></ol></li><li><p>解决方案</p><ol><li>判断id&lt;0</li><li>缓存空数据</li></ol></li><li><p>问题</p><ul><li>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</li><li>第二种解决方案：如果是不同的id那下次过来依然直击数据</li></ul></li><li><p>如何解决呢？</p><ul><li>将数据库中的ID写入List集合中</li><li>每一次查询判断id是否在集合中<ul><li>不在，直接返回</li><li>在，放行</li></ul></li></ul></li><li><p>新的问题是这个主键很长，占用内存</p><ol><li>所以如果采用以上方案，这个List也会很大，所以我们可以使用<code>bitmap</code>来减少List的存储空间</li></ol></li><li><p>内存问题的解决</p><ol><li>可以把list数据抽象成一个非常大的<code>bitmap</code>，不再使用list，而是将db中的id数据利用哈希思想</li><li>例如<ol><li>id % <code>bitmap.size</code>  &#x3D; xx 算出当前这个id应该落在<code>bitmap</code>的哪个索引上，然后将这个值从0变成1</li><li>然后当用户来查询数据时，此时已经没有了List，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在<code>bitmap</code>的哪一位</li><li>然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在</li><li>采用这种方式来处理，需要重点考虑一个事情，就是误差率（指当发生哈希冲突的时候，产生的误差）</li><li>是不是很熟悉，就是布隆过滤器的原理</li></ol></li></ol></li></ol><hr><h1 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h1><h2 id="HyperLogLog概率统计算法"><a href="#HyperLogLog概率统计算法" class="headerlink" title="HyperLogLog概率统计算法"></a>HyperLogLog概率统计算法</h2><blockquote><p>这里主要理解何为HyperLogLog和LogLog统计算法以及有何应用</p><p><code>https://juejin.cn/post/6844903785744056333#heading-0</code>很好的解释</p></blockquote><ol><li><p>首先搞懂两个概念</p><ol><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量</li></ol></li><li><p>通常来说UV会比PV大很多，所以衡量一个网站的访问量，需要综合考虑很多因素；所以我们只是单纯的把这两个值作为一个参考值</p></li><li><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p></li><li><p><strong>Hyperloglog(HLL)<strong>是从</strong>Loglog</strong>算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理可以参考</p><ol><li><code>https://juejin.cn/post/6844903785744056333#heading-0</code>写的很好</li></ol></li><li><p>Redis中的HLL是基于String结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 黑马学习课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/cn/hello-world/"/>
      <url>/cn/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Remove-generated-files-and-cache"><a href="#Remove-generated-files-and-cache" class="headerlink" title="Remove generated files and cache"></a>Remove generated files and cache</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
